{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-bo.js","webpack:/webpack/bootstrap f19dda89bdc4710c95f7","webpack:///index.bo.js","webpack:///lib/fish-topo-bo/lib/FishTopoBo.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/graphic/helper/text.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/graphic/helper/image.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///lib/fish-topo-bo/lib/node/BoNode.js","webpack:///lib/fish-topo-bo/lib/models/Const.js","webpack:///lib/fish-topo-bo/lib/node/BoName.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/helper/fixClipWithShadow.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///~/zrender/lib/graphic/States.js","webpack:///lib/fish-topo-bo/lib/node/EventDecisionNode.js","webpack:///lib/fish-topo-bo/lib/node/LineNode.js","webpack:///lib/fish-topo-bo/lib/node/BoAttrNode.js","webpack:///lib/fish-topo-bo/lib/node/Relation.js","webpack:///lib/fish-topo-core/lib/objectAssignPolyfill.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoBo","dom","opts","nowZoom","canScale","_zr","zr","init","renderer","devicePixelRatio","util","BoNode","Relation","Const","graphic","eventTool","fishTopoProto","prototype","group","Group","groupDrag","add","zrScale","resize","addBo","boData","_setParent","layout","x","startPos","y","level","_bfs","_moveRightByParent","boNode","getShape","addChildBo","child","childCnt","length","childBoArr","i","parent","next","_levelMaxPos","_queue","push","tmp","shift","BO_NODE_WIDTH","_moveRightByChild","BO_NODE_OFFSET_X","width","moved","_moveRightByPrevious","parentBoNode","boNodeHeight","getBoundingRect","height","getLayout","BO_NODE_OFFSET_Y","getData","relationNode","relation","_relationLen","j","sourceId","targetId","sourceText","targetText","childOfName","lineStyle","lineHoverStyle","arrowStyle","arrowHoverStyle","setCurrentBo","boId","style","childCount","childAt","name","setCurrent","clear","type","zoom","zoomDelta","zoomX","zoomY","that","target","pos","position","scale","newZoom","_zoom","zoomScale","attr","getWidth","getHeight","on","e","stop","event","wheelDelta","offsetX","offsetY","groupDragFunction","moveDrag","gx","gy","min","max","sX","clientX","startX","sY","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","endDrag","off","moveFunction","upFunction","cancelBubble","drag","node","GroupNode","nodeMessage","shape","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","ConnectionManager","refreshLineByNode","layoutNode","forceLayoutOption","nodes","allNodes","_","indexOf","alarmPositionX","alarmPositionY","isdraggable","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoBo","version","dependencies","zrender","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","zrUtil","isDom","isDisposed","ZRender","guid","hasOwnProperty","getInstance","registerPainter","Ctor","painterCtors","delInstance","env","Handler","Storage","Painter","Animation","HandlerProxy","useVML","canvasSupported","canvas","self","storage","rendererType","vml","painter","handerProxy","getViewportRoot","handler","animation","stage","update","bind","flush","start","_needsRefresh","oldDelFromStorage","delFromStorage","oldAddToStorage","addToStorage","el","removeSelfFromZr","addSelfToZr","constructor","getId","addRoot","remove","delRoot","configLayer","zLevel","config","refreshImmediately","refresh","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","dpr","setCursorStyle","cursorStyle","findHover","eventName","eventHandler","context","trigger","_default","idStart","detect","ua","os","browser","firefox","match","ie","edge","weChat","test","document","createElement","getContext","svgSupported","SVGRect","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","$override","fn","methods","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","overlay","_ctx","createCanvas","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","slice","Function","normalizeCssArray","val","assert","condition","message","setAsPrimitive","primitiveKey","HashMap","set","createHashMap","noop","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","HASH_MAP_PREFIX","HASH_MAP_PREFIX_LENGTH","get","prefixedKey","removeKey","makeEventPacket","eveType","targetInfo","topTarget","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","which","EmptyProxy","isHover","displayable","rectHover","isSilent","clipPath","contain","silent","SILENT","vec2","Draggable","Eventful","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","lastHoveredTarget","__zr","hovered","hoveredTarget","setCursor","cursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","out","hoverCheckResult","ignore","_downEl","_downPoint","_upEl","dist","create","ArrayCtor","copy","v","a","b","v1","v2","scaleAndAdd","sub","Math","sqrt","lenSquare","mul","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","applyTransform","Float32Array","lengthSquare","distSquare","_dragStart","_drag","_dragEnd","param","draggingTarget","draggable","_draggingTarget","dragging","_x","_y","dx","dy","drift","dropTarget","lastDropTarget","_dropTarget","arrySlice","_$handlers","one","_h","h","ctx","newList","l","argLen","splice","triggerWithContext","shapeCompareFunc","zlevel","z","z2","timsort","_roots","_displayList","_displayListLen","traverse","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","clipPaths","beforeUpdate","__dirty","afterUpdate","userSetClipPath","currentClipPath","parentClipPath","updateTransform","isGroup","children","_children","__clipPaths","__storage","addChildrenToStorage","delChildrenFromStorage","idx","dirty","_renderList","displayableSortFunc","Element","BoundingRect","_doAdd","addBefore","nextSibling","removeAll","eachChild","includeChildren","rect","tmpRect","tmpMat","invisible","childRect","transform","getLocalTransform","union","Transformable","Animatable","decomposeTransform","attrKV","hide","show","setClipPath","removeClipPath","__clipTarget","animators","addAnimator","removeAnimator","isNotAroundZero","EPSILON","matrix","vector","mIdentity","identity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","invTransform","invert","setTransform","restoreTransform","tmpTransform","sx","sy","atan2","getGlobalScale","transformCoordToLocal","transformCoordToGlobal","rotate","m1","m2","out0","out1","out2","out3","out4","out5","translate","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","Animator","log","_util","animate","path","loop","animatingShape","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","animateTo","time","delay","easing","callback","forceAnimate","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isNaN","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","color","parse","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","r","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","replace","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","colorArr","stringify","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","_config","debugMode","console","v2ApplyTransform","mathMin","mathMax","other","lt","rb","lb","rt","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","minRunLength","n","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","gallopLeft","hint","lastOffset","maxOffset","offset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","beginPath","buildPath","createRoot","domRoot","cssText","Layer","requestAnimationFrame","Image","MAX_PROGRESSIVE_LAYER_NUMBER","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","hoverStyle","__hoverMir","elMirror","__from","setStyle","hoverElements","hoverLayer","getLayer","scope","save","originalEl","_doPaintEl","restore","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","globalAlpha","shadowBlur","currentLayer","drawImage","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","opacity","culling","prevClipLayer","prevElClipPaths","prevEl","beforeBrush","brush","afterBrush","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","progressive","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","Infinity","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","image","returnFalse","createDom","newDom","newDomStyle","top","Style","Pattern","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","globalCompositeOperation","clearColorGradientOrPattern","colorStops","__canvasGradient","getGradient","getCanvasPattern","fillStyle","fillRect","createLinearGradient","x2","y2","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","host","extendFrom","fill","stroke","lineDash","lineDashOffset","strokeNoScale","text","font","textFont","fontStyle","fontWeight","fontSize","fontFamily","textTag","textFill","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textPosition","textRect","textOffset","textAlign","textVerticalAlign","textDistance","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevStyle","firstDraw","styleName","strokeStyle","getLineScale","hasFill","otherStyle","newStyle","method","addColorStop","styleProto","repeat","createPattern","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","ZImage","Displayable","imageHelper","src","_image","createOrUpdateImage","onload","isImageReady","aspect","sWidth","sHeight","drawRectText","_rect","RectText","rectContain","coord","animateStyle","useStyle","textHelper","normalizeTextStyle","needDrawText","renderText","normalizeStyle","textContain","makeFont","VALID_TEXT_ALIGN","textBaseline","VALID_TEXT_VERTICAL_ALIGN","hostEl","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","tokenStyle","isLineHolder","isPlainBg","roundRectHelper","closePath","onBgImageLoaded","blockHeiht","parsePercent","res","adjustTextPositionOnRect","maxValue","lastIndexOf","center","bottom","middle","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getRichTextRect","getPlainTextRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","padding","truncOuterHeight","truncOuterWidth","lastIndex","STYLE_REG","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","findExistImage","paddingW","remianTruncWidth","block","isEmptyStr","strs","tokensLen","newImageOrSrc","cachedImgObj","globalImageCache","cbPayload","__zrImageSrc","pendingWrap","pending","imageOnLoad","__cachedImgObj","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","_event","Dispatcher","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","button","undefined","MOUSE_EVENT_REG","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","notLeftMouse","preventDefault","stopPropagation","returnValue","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","points","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","BO","nodeOptions","_data","_oriStartPos","_nextStartPos","_displayAttrDataType","displayAttrDataType","_displayAttrEvent","displayAttrEvent","_boClickable","boClickable","_boPopupOpts","boPopupOpts","_boEventClickable","boEventClickable","_boEventPopupOpts","boEventPopupOpts","_attrEventClickable","attrEventClickable","_attrEventPopupOpts","attrEventPopupOpts","_isCurrent","isCurrent","_boShapeHeight","_group","_boShape","assign","_render","BoName","EventDecision","Line","BoAttr","boProto","_createBoName","_createEventDecision","_createBoAttr","_createBoShape","_boNameShape","clickable","onclick","_click","_calNextShapeStartPos","boEventArr","_eventShape","_boEventArr","_boEventLen","_eventOpts","popupOpts","bindBoClickEvent","boAttrArr","_boAttrShape","_lineShape","_boAttrArr","_boAttrLen","_attrEventStartPos","BoLine","AttrLine","displayDataType","displayEventDecision","eventClickable","eventPopupOpts","AttrEventLine","curShape","BO_NODE_DEFAULT_HEIGHT","Rect","brushType","lineCape","DATA","BO_NAME_FONT","BO_NAME_PADDING_TOP","BO_NAME_PADDING_BOTTOM","BO_EVENT_HEIGHT","BO_EVENT_WIDTH","BO_EVENT_FONT","BO_ATTR_FONT","BO_ATTR_PADDING_TOP","BO_ATTR_PADDING_BOTTOM","BO_ATTR_PADDING_LEFT","BO_ATTR_DATA_TYPE_PADDING_RIGHT","BO_ATTR_EVENT_WIDTH","LINE_DASH","RELATION_OFFSET","RELATION_ARROW_WIDTH","RELATION_ARROW_HEIGHT","RELATION_TEXT_OFFSET_X","RELATION_TEXT_OFFSET_Y","Text","doSingleEnterHover","__isHover","__hoverStlDirty","__hoverStl","colorTool","Gradient","normalStyle","__normalStl","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","postfix","duration","getShallow","animationEasing","pathTool","Path","Util","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","States","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","boundingRect","cx","cy","resizePath","mergePath","pathRect","subPixelOptimizeLine","subPixelOptimize","x1","y1","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","getModel","getFont","getTextColor","updateProps","initProps","getTransform","ancestor","mat","vertex","transformDirection","direction","hBase","abs","vBase","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","ctlPtx","ctlPty","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","rebuildPath","transformPath","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","vMag","acos","pathContain","pathProxyForDraw","strokeContainThreshold","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","setLineDash","setScale","setLineDashOffset","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","containStroke","dirtyPath","animateShape","setShape","Sub","defaultShape","thisShape","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","_vector","v2Create","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","PI2","end","angle","extremity","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_l","_a","_b","_s","_curve","nPoint","mathAtan2","shadowColor","fixClipWithShadow","r0","clockwise","unitX","unitY","orignalBrush","modified","shadowTemp","polyHelper","smooth","smoothConstraint","controlPoints","smoothBezier","cp1","cp2","smoothSpline","interpolate","isLoop","v2Distance","segs","w2","w3","constraint","prevPoint","nextPoint","cps","v2Min","v2Max","point","v2Clone","v2Sub","v2Scale","d0","sum","cp0","v2Add","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","tangentAt","globalCoord","vec2Copy","transitionProperties","TransitionObject","_fromStr","property","GraphicStates","_states","_el","_subStates","_transitionAnimators","initialState","_initialState","optsStates","states","state","_addState","setState","_currentState","transition","_extendFromInitial","transiting","_stopTransition","prevState","onleave","onenter","getState","transitionState","styleShapeReg","propPathMap","transitionCfg","animatingCount","animationDone","_animProp","subProp","subStates","subPropKey","stateObj","elObj","availableProp","transitionAnimators","dealy","addSubStates","removeSubStates","EventDecisionNode","_startPos","_type","_clickable","_popupOpts","eventProto","_createEventShape","_createEVentName","eventNameShape","endPos","_line","attrHeight","_style","strokeColor","boAttrData","_keyValue","keyValue","_displayDataType","_displayEventDecision","_eventClickable","_eventPopupOpts","boAttrProto","_createText","_createDataType","attrNameShape","_dataTypeShape","dataType","_boAttrEventArr","boAttrEventArr","_boAttrEventLen","sourceShape","targetShape","_sourceText","_targetText","_lStartPos","_lEndPos","_rStartPos","_rEndPos","_leftDirection","_lineStyle","_lineHoverStyle","_arrowStyle","_arrowHoverStyle","relationProto","_createLine","_createArrow","_linePoints","_createHoverStyle","_arrowPoints","_arrowShape","_sourceTextPos","_targetTextPos","_textAlign","_srcTextShape","_targetTextShape","defineProperty","varArgs","TypeError","to","nextSource","nextKey","writable","configurable","_zrender","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","createNode","pathDataToString","cmdStr","dataLength","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","size","family","body","ex","createTextNode","offsetWidth","fromTextEl","align","verticalAlign","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","coords","textVmlElStyle","toFixed","string","proto","doCreateNode","initVML","vmlInited","styleSheets","createStyleSheet","addRule","urn","win","namespaces","zrvml","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","currentStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom"],"mappings":"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","file":"fish-topo-bo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//IE8 VML IE8\r\n\t__webpack_require__(82);\r\n\t\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t *\r\n\t */\r\n\t\r\n\t    var zr = __webpack_require__(3);\r\n\t    var util = __webpack_require__(6);\r\n\t    var BoNode = __webpack_require__(42);\r\n\t    var Relation = __webpack_require__(80);\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var eventTool = __webpack_require__(39);\r\n\t    __webpack_require__(81);\r\n\t\r\n\t    function FishTopoBo(dom, opts) {\r\n\t        /**\r\n\t         * \r\n\t         * @type {number}\r\n\t         */\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t\r\n\t        /**\r\n\t         * zrender\r\n\t         */\r\n\t        this._zr = zr.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoBo.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     */\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     *   \r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {Object} boData, bo\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} ,\r\n\t     *          displayAttrDataType: boolean ,\r\n\t     *          displayAttrEvent: boolean ,\r\n\t     *          boClickable: boolean BO,  false\r\n\t     *          boPopupUrl: String BO\r\n\t     *          boEventClickable: boolean BO,  false\r\n\t     *          boEventPopupUrl: String BO\r\n\t     *          bindBoClickEvent: function(options) BOoptionsDATA\r\n\t     *          attrEventClickable: boolean BO,  false\r\n\t     *          attrEventPopupUrl: String BO\r\n\t     *          isCurrent: boolean BO\r\n\t     *          lineStyle: {stroke: string, lineWidth: number, lineDash: Array} \r\n\t     *          lineHoverStyle: {stroke: string, lineWidth: number, lineDash: Array} hover\r\n\t     *          arrowStyle: {fill: string, stroke: string} \r\n\t     *          arrowHoverStyle: {fill: string, stroke: string} hover\r\n\t     *          }} opts\r\n\t     * @returns {*}\r\n\t     */\r\n\t    fishTopoProto.addBo = function (boData, opts) {\r\n\t        //BO\r\n\t        this._setParent(boData);\r\n\t\r\n\t        //layout BOx,y, level:\r\n\t        boData.layout = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y,\r\n\t            level: 1\r\n\t        };\r\n\t\r\n\t        //BOX\r\n\t        this._bfs(boData);\r\n\t\r\n\t        //\r\n\t        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\t\r\n\t        //BO\r\n\t        var boNode = new BoNode(boData, opts);\r\n\t        this.group.add(boNode.getShape());\r\n\t\r\n\t        //BO\r\n\t        this.addChildBo(boNode, opts);\r\n\t\r\n\t        return boNode;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {Object} boData BO\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._setParent = function (boData) {\r\n\t        if (boData.child) {\r\n\t            var childCnt = boData.child.length,\r\n\t                childBoArr = boData.child;\r\n\t            for (var i = 0; i < childCnt; i++) {\r\n\t                childBoArr[i].parent = boData;\r\n\t                if (childBoArr[i + 1]) {\r\n\t                    childBoArr[i].next = childBoArr[i + 1];\r\n\t                }\r\n\t                //next=\r\n\t                else if (boData.next && boData.next.child) {\r\n\t                    childBoArr[i].next = boData.next.child[0];\r\n\t                }\r\n\t                this._setParent(childBoArr[i]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Breadth-First-Search X\r\n\t     * BOBOX\r\n\t     * BOBOY\r\n\t     * @param boData\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._bfs = function (boData) {\r\n\t        //level\r\n\t        this._levelMaxPos = {};\r\n\t\r\n\t        this._queue = [];   //BO\r\n\t        this._queue.push(boData);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift();\r\n\t            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //level\r\n\t            if (!this._levelMaxPos[tmp.layout.level]) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //\r\n\t            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //\r\n\t            else {\r\n\t                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //x\r\n\t            if (tmp.child) {\r\n\t                var childCnt = tmp.child.length;\r\n\t\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t\r\n\t                    tmp.child[i].layout = {\r\n\t                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n\t                        level: tmp.layout.level + 1\r\n\t                    };\r\n\t\r\n\t                    this._queue.push(tmp.child[i]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByChild = function (boData, width) {\r\n\t        if (boData) {\r\n\t\r\n\t            if (!boData.layout.moved) {\r\n\t\r\n\t                if (boData.layout.level == 1) {\r\n\t                    boData.layout.x += width / 2;\r\n\t                } else {\r\n\t                    boData.layout.x += width;\r\n\t                }\r\n\t\r\n\t                boData.layout.moved = true;\r\n\t            }\r\n\t            //\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t            //\r\n\t            this._moveRightByChild(boData.parent, width);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            //\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByParent = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            if (boData.child) {\r\n\t                for (var i = 0; i < boData.child.length; i++) {\r\n\t                    this._moveRightByParent(boData.child[i], width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {BoNode} parentBoNode\r\n\t     * @param {Object} opts\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\t\r\n\t        this._queue = []; //BOYBoNode\r\n\t        this._queue.push(parentBoNode);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift(),\r\n\t                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n\t            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            //Level\r\n\t            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n\t                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n\t                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            if (tmp.getData().child) {\r\n\t\r\n\t                var childBoArr = tmp.getData().child,\r\n\t                    childCnt = childBoArr.length,\r\n\t                    boNode,\r\n\t                    relationNode;\r\n\t\r\n\t                //levelY\r\n\t                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t                    opts.startPos.x = childBoArr[i].layout.x;\r\n\t                    childBoArr[i].layout.y = opts.startPos.y;\r\n\t                    boNode = new BoNode(childBoArr[i], opts);\r\n\t                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\t\r\n\t                    this.group.add(boNode.getShape());\r\n\t                    this._queue.push(boNode);\r\n\t\r\n\t                    //BO\r\n\t                    if (childBoArr[i].relation) {\r\n\t                        var _relationLen = childBoArr[i].relation.length;\r\n\t                        for (var j = 0; j < _relationLen; j++) {\r\n\t                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n\t                                targetId = childBoArr[i].relation[j].targetId,\r\n\t                                sourceText = childBoArr[i].relation[j].sourceText,\r\n\t                                targetText = childBoArr[i].relation[j].targetText;\r\n\t\r\n\t                            relationNode = new Relation(\r\n\t                                boNode.getShape().childOfName(sourceId),\r\n\t                                tmp.getShape().childOfName(targetId),\r\n\t                                sourceText,\r\n\t                                targetText,\r\n\t                                opts.lineStyle,\r\n\t                                opts.lineHoverStyle,\r\n\t                                opts.arrowStyle,\r\n\t                                opts.arrowHoverStyle\r\n\t                            );\r\n\t                            this.group.add(relationNode.getShape());\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {String} boId, BO\r\n\t     * @param {Object} style, BO,\r\n\t     */\r\n\t    fishTopoProto.setCurrentBo = function (boId, style) {\r\n\t        var length = this.group.childCount();\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (this.group.childAt(i).name == boId) {\r\n\t                this.group.childAt(i).setCurrent(style);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param type\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        var that = this;\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta = 1 / 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t        } else {\r\n\t            that._zr.on('mousewheel', function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n\t                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n\t            });\r\n\t        }\r\n\t        ;\r\n\t        function zoom(zoomDelta, zoomX, zoomY) {\r\n\t            if (that.canScale == false) {\r\n\t                return;\r\n\t            }\r\n\t            var target = that.group;\r\n\t            if (target) {\r\n\t                var pos = target.position;\r\n\t                var scale = target.scale;\r\n\t                var newZoom = that._zoom = that._zoom || 1;\r\n\t                newZoom *= zoomDelta;\r\n\t                var zoomScale = newZoom / that._zoom;\r\n\t                // if(newZoom>2.6||newZoom<0.38){\r\n\t                //     return;\r\n\t                // };\r\n\t                that._zoom = newZoom;\r\n\t\r\n\t                that.nowZoom = newZoom;\r\n\t                // Keep the mouse center when scaling\r\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t                scale[0] *= zoomScale;\r\n\t                scale[1] *= zoomScale;\r\n\t                target.attr(\"position\", [pos[0], pos[1]]);\r\n\t                target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Group\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function () {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function (e) {\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param node\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function (e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = node.alarm.position;\r\n\t                alarmPositionX = node.alarm.position[0];\r\n\t                alarmPositionY = node.alarm.position[1];\r\n\t            }\r\n\t            ;\r\n\t            function moveDrag(e) {\r\n\t                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //nodegroup\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                } else {\r\n\t                    nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                    nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                    node.attr(\"position\", nowGroupPosition);\r\n\t                    if (node.alarm) {\r\n\t                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                        node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                    }\r\n\t                    ;\r\n\t                }\r\n\t                ConnectionManager.refreshLineByNode(node);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t            //\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\"node\": node});\r\n\t                }\r\n\t                if (that.forceLayoutOption) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (_.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                ;\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    // ---------fishTopoBo------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n\t    var fishTopoBo = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '3.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoBo.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        util.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoBo = new FishTopoBo(dom, opts);\r\n\t        fishTopoBo.init();\r\n\t\r\n\t        fishTopoBo.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoBo.id] = fishTopoBo;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\t\r\n\t        return fishTopoBo;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoBo.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoBo.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoBo.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoBo;\r\n\t\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(4);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Handler = __webpack_require__(7);\n\t\n\tvar Storage = __webpack_require__(11);\n\t\n\tvar Painter = __webpack_require__(26);\n\t\n\tvar Animation = __webpack_require__(38);\n\t\n\tvar HandlerProxy = __webpack_require__(40);\n\t\n\t/*!\n\t* ZRender, a high performance 2d drawing library.\n\t*\n\t* Copyright (c) 2013, Baidu Inc.\n\t* All rights reserved.\n\t*\n\t* LICENSE\n\t* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t*/\n\tvar useVML = !env.canvasSupported;\n\tvar painterCtors = {\n\t  canvas: Painter\n\t};\n\tvar instances = {}; // ZRendermap\n\t\n\t/**\n\t * @type {string}\n\t */\n\t\n\tvar version = '3.7.4';\n\t/**\n\t * Initializing a zrender instance\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\tfunction init(dom, opts) {\n\t  var zr = new ZRender(guid(), dom, opts);\n\t  instances[zr.id] = zr;\n\t  return zr;\n\t}\n\t/**\n\t * Dispose zrender instance\n\t * @param {module:zrender/ZRender} zr\n\t */\n\t\n\t\n\tfunction dispose(zr) {\n\t  if (zr) {\n\t    zr.dispose();\n\t  } else {\n\t    for (var key in instances) {\n\t      if (instances.hasOwnProperty(key)) {\n\t        instances[key].dispose();\n\t      }\n\t    }\n\t\n\t    instances = {};\n\t  }\n\t\n\t  return this;\n\t}\n\t/**\n\t * Get zrender instance by id\n\t * @param {string} id zrender instance id\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\t\n\tfunction getInstance(id) {\n\t  return instances[id];\n\t}\n\t\n\tfunction registerPainter(name, Ctor) {\n\t  painterCtors[name] = Ctor;\n\t}\n\t\n\tfunction delInstance(id) {\n\t  delete instances[id];\n\t}\n\t/**\n\t * @module zrender/ZRender\n\t */\n\t\n\t/**\n\t * @constructor\n\t * @alias module:zrender/ZRender\n\t * @param {string} id\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t */\n\t\n\t\n\tvar ZRender = function (id, dom, opts) {\n\t  opts = opts || {};\n\t  /**\n\t   * @type {HTMLDomElement}\n\t   */\n\t\n\t  this.dom = dom;\n\t  /**\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = id;\n\t  var self = this;\n\t  var storage = new Storage();\n\t  var rendererType = opts.renderer; // TODO WebGL\n\t\n\t  if (useVML) {\n\t    if (!painterCtors.vml) {\n\t      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t    }\n\t\n\t    rendererType = 'vml';\n\t  } else if (!rendererType || !painterCtors[rendererType]) {\n\t    rendererType = 'canvas';\n\t  }\n\t\n\t  var painter = new painterCtors[rendererType](dom, storage, opts);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t  /**\n\t   * @type {module:zrender/animation/Animation}\n\t   */\n\t\n\t  this.animation = new Animation({\n\t    stage: {\n\t      update: zrUtil.bind(this.flush, this)\n\t    }\n\t  });\n\t  this.animation.start();\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._needsRefresh; //  storage.delFromStorage, \n\t  // FIXME ugly\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t    el && el.removeSelfFromZr(self);\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    oldAddToStorage.call(storage, el);\n\t    el.addSelfToZr(self);\n\t  };\n\t};\n\t\n\tZRender.prototype = {\n\t  constructor: ZRender,\n\t\n\t  /**\n\t   * \n\t   * @return {string}\n\t   */\n\t  getId: function () {\n\t    return this.id;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  add: function (el) {\n\t    this.storage.addRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  remove: function (el) {\n\t    this.storage.delRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Change configuration of layer\n\t   * @param {string} zLevel\n\t   * @param {Object} config\n\t   * @param {string} [config.clearColor=0] Clear color\n\t   * @param {string} [config.motionBlur=false] If enable motion blur\n\t   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t  */\n\t  configLayer: function (zLevel, config) {\n\t    this.painter.configLayer(zLevel, config);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Repaint the canvas immediately\n\t   */\n\t  refreshImmediately: function () {\n\t    // var start = new Date();\n\t    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t    // Or it will cause zrender refreshes again and again.\n\t    this._needsRefresh = false;\n\t    this.painter.refresh();\n\t    /**\n\t     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t     */\n\t\n\t    this._needsRefresh = false; // var end = new Date();\n\t    // var log = document.getElementById('log');\n\t    // if (log) {\n\t    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n\t    // }\n\t  },\n\t\n\t  /**\n\t   * Mark and repaint the canvas in the next frame of browser\n\t   */\n\t  refresh: function () {\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Perform all refresh\n\t   */\n\t  flush: function () {\n\t    if (this._needsRefresh) {\n\t      this.refreshImmediately();\n\t    }\n\t\n\t    if (this._needsRefreshHover) {\n\t      this.refreshHoverImmediately();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element to hover layer\n\t   * @param  {module:zrender/Element} el\n\t   * @param {Object} style\n\t   */\n\t  addHover: function (el, style) {\n\t    if (this.painter.addHover) {\n\t      this.painter.addHover(el, style);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element from hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  removeHover: function (el) {\n\t    if (this.painter.removeHover) {\n\t      this.painter.removeHover(el);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clear all hover elements in hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  clearHover: function () {\n\t    if (this.painter.clearHover) {\n\t      this.painter.clearHover();\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Refresh hover in next frame\n\t   */\n\t  refreshHover: function () {\n\t    this._needsRefreshHover = true;\n\t  },\n\t\n\t  /**\n\t   * Refresh hover immediately\n\t   */\n\t  refreshHoverImmediately: function () {\n\t    this._needsRefreshHover = false;\n\t    this.painter.refreshHover && this.painter.refreshHover();\n\t  },\n\t\n\t  /**\n\t   * Resize the canvas.\n\t   * Should be invoked when container size is changed\n\t   * @param {Object} [opts]\n\t   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t   */\n\t  resize: function (opts) {\n\t    opts = opts || {};\n\t    this.painter.resize(opts.width, opts.height);\n\t    this.handler.resize();\n\t  },\n\t\n\t  /**\n\t   * Stop and clear all animation immediately\n\t   */\n\t  clearAnimation: function () {\n\t    this.animation.clear();\n\t  },\n\t\n\t  /**\n\t   * Get container width\n\t   */\n\t  getWidth: function () {\n\t    return this.painter.getWidth();\n\t  },\n\t\n\t  /**\n\t   * Get container height\n\t   */\n\t  getHeight: function () {\n\t    return this.painter.getHeight();\n\t  },\n\t\n\t  /**\n\t   * Export the canvas as Base64 URL\n\t   * @param {string} type\n\t   * @param {string} [backgroundColor='#fff']\n\t   * @return {string} Base64 URL\n\t   */\n\t  // toDataURL: function(type, backgroundColor) {\n\t  //     return this.painter.getRenderedCanvas({\n\t  //         backgroundColor: backgroundColor\n\t  //     }).toDataURL(type);\n\t  // },\n\t\n\t  /**\n\t   * Converting a path to image.\n\t   * It has much better performance of drawing image rather than drawing a vector path.\n\t   * @param {module:zrender/graphic/Path} e\n\t   * @param {number} width\n\t   * @param {number} height\n\t   */\n\t  pathToImage: function (e, dpr) {\n\t    return this.painter.pathToImage(e, dpr);\n\t  },\n\t\n\t  /**\n\t   * Set default cursor\n\t   * @param {string} [cursorStyle='default']  crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    this.handler.setCursorStyle(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * Find hovered element\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @return {Object} {target, topTarget}\n\t   */\n\t  findHover: function (x, y) {\n\t    return this.handler.findHover(x, y);\n\t  },\n\t\n\t  /**\n\t   * Bind event\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {Function} eventHandler Handler function\n\t   * @param {Object} [context] Context object\n\t   */\n\t  on: function (eventName, eventHandler, context) {\n\t    this.handler.on(eventName, eventHandler, context);\n\t  },\n\t\n\t  /**\n\t   * Unbind event\n\t   * @param {string} eventName Event name\n\t   * @param {Function} [eventHandler] Handler function\n\t   */\n\t  off: function (eventName, eventHandler) {\n\t    this.handler.off(eventName, eventHandler);\n\t  },\n\t\n\t  /**\n\t   * Trigger event manually\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {event=} event Event object\n\t   */\n\t  trigger: function (eventName, event) {\n\t    this.handler.trigger(eventName, event);\n\t  },\n\t\n\t  /**\n\t   * Clear all objects and the canvas.\n\t   */\n\t  clear: function () {\n\t    this.storage.delRoot();\n\t    this.painter.clear();\n\t  },\n\t\n\t  /**\n\t   * Dispose self.\n\t   */\n\t  dispose: function () {\n\t    this.animation.stop();\n\t    this.clear();\n\t    this.storage.dispose();\n\t    this.painter.dispose();\n\t    this.handler.dispose();\n\t    this.animation = this.storage = this.painter = this.handler = null;\n\t    delInstance(this.id);\n\t  }\n\t};\n\texports.version = version;\n\texports.init = init;\n\texports.dispose = dispose;\n\texports.getInstance = getInstance;\n\texports.registerPainter = registerPainter;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\tvar idStart = 0x0907;\n\t\n\tfunction _default() {\n\t  return idStart++;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * echarts\n\t *\n\t * @desc echartsCanvasJavascript\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\tvar env = {};\n\t\n\tif (typeof navigator === 'undefined') {\n\t  // In node\n\t  env = {\n\t    browser: {},\n\t    os: {},\n\t    node: true,\n\t    // Assume canvas is supported\n\t    canvasSupported: true,\n\t    svgSupported: true\n\t  };\n\t} else {\n\t  env = detect(navigator.userAgent);\n\t}\n\t\n\tvar _default = env; // Zepto.js\n\t// (c) 2010-2013 Thomas Fuchs\n\t// Zepto.js may be freely distributed under the MIT license.\n\t\n\tfunction detect(ua) {\n\t  var os = {};\n\t  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t  // var touchpad = webos && ua.match(/TouchPad/);\n\t  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t  // var playbook = ua.match(/PlayBook/);\n\t  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t\n\t  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t\n\t  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n\t  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n\t  // - discern (more) between multiple browsers on android\n\t  // - decide if kindle fire in silk mode is android or not\n\t  // - Firefox on Android doesn't specify the Android version\n\t  // - possibly devide in os, device and browser hashes\n\t  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t  // if (android) os.android = true, os.version = android[2];\n\t  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t  // if (webos) os.webos = true, os.version = webos[2];\n\t  // if (touchpad) os.touchpad = true;\n\t  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t  // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t  // if (playbook) browser.playbook = true;\n\t  // if (kindle) os.kindle = true, os.version = kindle[1];\n\t  // if (silk) browser.silk = true, browser.version = silk[1];\n\t  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t\n\t  if (firefox) {\n\t    browser.firefox = true;\n\t    browser.version = firefox[1];\n\t  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t  // if (webview) browser.webview = true;\n\t\n\t\n\t  if (ie) {\n\t    browser.ie = true;\n\t    browser.version = ie[1];\n\t  }\n\t\n\t  if (edge) {\n\t    browser.edge = true;\n\t    browser.version = edge[1];\n\t  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t  // not be set on win phone. So we do not consider Win Phone.\n\t\n\t\n\t  if (weChat) {\n\t    browser.weChat = true;\n\t  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t\n\t  return {\n\t    browser: browser,\n\t    os: os,\n\t    node: false,\n\t    // canvas\n\t    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t    canvasSupported: !!document.createElement('canvas').getContext,\n\t    svgSupported: typeof SVGRect !== 'undefined',\n\t    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t    // works on most browsers\n\t    // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t    // default, so we dont check navigator.maxTouchPoints for them here.\n\t    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t    // <http://caniuse.com/#search=pointer%20event>.\n\t    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t    // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t    // Although IE 10 supports pointer event, it use old style and is different from the\n\t    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t    && (browser.edge || browser.ie && browser.version >= 11)\n\t  };\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t// mergeDate\n\tvar BUILTIN_OBJECT = {\n\t  '[object Function]': 1,\n\t  '[object RegExp]': 1,\n\t  '[object Date]': 1,\n\t  '[object Error]': 1,\n\t  '[object CanvasGradient]': 1,\n\t  '[object CanvasPattern]': 1,\n\t  // For node-canvas\n\t  '[object Image]': 1,\n\t  '[object Canvas]': 1\n\t};\n\tvar TYPED_ARRAY = {\n\t  '[object Int8Array]': 1,\n\t  '[object Uint8Array]': 1,\n\t  '[object Uint8ClampedArray]': 1,\n\t  '[object Int16Array]': 1,\n\t  '[object Uint16Array]': 1,\n\t  '[object Int32Array]': 1,\n\t  '[object Uint32Array]': 1,\n\t  '[object Float32Array]': 1,\n\t  '[object Float64Array]': 1\n\t};\n\tvar objToString = Object.prototype.toString;\n\tvar arrayProto = Array.prototype;\n\tvar nativeForEach = arrayProto.forEach;\n\tvar nativeFilter = arrayProto.filter;\n\tvar nativeSlice = arrayProto.slice;\n\tvar nativeMap = arrayProto.map;\n\tvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * Those data types can be cloned:\n\t *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t * Those data types will be assgined using the orginal data:\n\t *     BUILTIN_OBJECT\n\t * Instance of user defined class will be cloned to a plain object, without\n\t * properties in prototype.\n\t * Other data types is not supported (not sure what will happen).\n\t *\n\t * Caution: do not support clone Date, for performance consideration.\n\t * (There might be a large number of date in `series.data`).\n\t * So date should not be modified in and out of echarts.\n\t *\n\t * @param {*} source\n\t * @return {*} new\n\t */\n\t\n\t\n\tfunction clone(source) {\n\t  if (source == null || typeof source != 'object') {\n\t    return source;\n\t  }\n\t\n\t  var result = source;\n\t  var typeStr = objToString.call(source);\n\t\n\t  if (typeStr === '[object Array]') {\n\t    result = [];\n\t\n\t    for (var i = 0, len = source.length; i < len; i++) {\n\t      result[i] = clone(source[i]);\n\t    }\n\t  } else if (TYPED_ARRAY[typeStr]) {\n\t    var Ctor = source.constructor;\n\t\n\t    if (source.constructor.from) {\n\t      result = Ctor.from(source);\n\t    } else {\n\t      result = new Ctor(source.length);\n\t\n\t      for (var i = 0, len = source.length; i < len; i++) {\n\t        result[i] = clone(source[i]);\n\t      }\n\t    }\n\t  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t    result = {};\n\t\n\t    for (var key in source) {\n\t      if (source.hasOwnProperty(key)) {\n\t        result[key] = clone(source[key]);\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overwrite=false]\n\t */\n\t\n\t\n\tfunction merge(target, source, overwrite) {\n\t  // We should escapse that source is string\n\t  // and enter for ... in ...\n\t  if (!isObject(source) || !isObject(target)) {\n\t    return overwrite ? clone(source) : target;\n\t  }\n\t\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      var targetProp = target[key];\n\t      var sourceProp = source[key];\n\t\n\t      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n\t        // merge\n\t        merge(targetProp, sourceProp, overwrite);\n\t      } else if (overwrite || !(key in target)) {\n\t        // overwritetrue\n\t        // NOTE target[key] \n\t        target[key] = clone(source[key], true);\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t * @param {boolean} [overwrite=false]\n\t * @return {*} target\n\t */\n\t\n\t\n\tfunction mergeAll(targetAndSources, overwrite) {\n\t  var result = targetAndSources[0];\n\t\n\t  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t    result = merge(result, targetAndSources[i], overwrite);\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction extend(target, source) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overlay=false]\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction defaults(target, source, overlay) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t\n\tvar createCanvas = function () {\n\t  return methods.createCanvas();\n\t};\n\t\n\tmethods.createCanvas = function () {\n\t  return document.createElement('canvas');\n\t}; // FIXME\n\t\n\t\n\tvar _ctx;\n\t\n\tfunction getContext() {\n\t  if (!_ctx) {\n\t    // Use util.createCanvas instead of createCanvas\n\t    // because createCanvas may be overwritten in different environment\n\t    _ctx = createCanvas().getContext('2d');\n\t  }\n\t\n\t  return _ctx;\n\t}\n\t/**\n\t * index\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction indexOf(array, value) {\n\t  if (array) {\n\t    if (array.indexOf) {\n\t      return array.indexOf(value);\n\t    }\n\t\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === value) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  return -1;\n\t}\n\t/**\n\t * \n\t *\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} clazz \n\t * @param {Function} baseClazz \n\t */\n\t\n\t\n\tfunction inherits(clazz, baseClazz) {\n\t  var clazzPrototype = clazz.prototype;\n\t\n\t  function F() {}\n\t\n\t  F.prototype = baseClazz.prototype;\n\t  clazz.prototype = new F();\n\t\n\t  for (var prop in clazzPrototype) {\n\t    clazz.prototype[prop] = clazzPrototype[prop];\n\t  }\n\t\n\t  clazz.prototype.constructor = clazz;\n\t  clazz.superClass = baseClazz;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Function} target\n\t * @param {Object|Function} sorce\n\t * @param {boolean} overlay\n\t */\n\t\n\t\n\tfunction mixin(target, source, overlay) {\n\t  target = 'prototype' in target ? target.prototype : target;\n\t  source = 'prototype' in source ? source.prototype : source;\n\t  defaults(target, source, overlay);\n\t}\n\t/**\n\t * Consider typed array.\n\t * @param {Array|TypedArray} data\n\t */\n\t\n\t\n\tfunction isArrayLike(data) {\n\t  if (!data) {\n\t    return;\n\t  }\n\t\n\t  if (typeof data == 'string') {\n\t    return false;\n\t  }\n\t\n\t  return typeof data.length == 'number';\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t */\n\t\n\t\n\tfunction each(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.forEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(cb, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      cb.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (obj.hasOwnProperty(key)) {\n\t        cb.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction map(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.map && obj.map === nativeMap) {\n\t    return obj.map(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      result.push(cb.call(context, obj[i], i, obj));\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {Object} [memo]\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction reduce(obj, cb, memo, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.reduce && obj.reduce === nativeReduce) {\n\t    return obj.reduce(cb, memo, context);\n\t  } else {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      memo = cb.call(context, memo, obj[i], i, obj);\n\t    }\n\t\n\t    return memo;\n\t  }\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction filter(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.filter && obj.filter === nativeFilter) {\n\t    return obj.filter(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      if (cb.call(context, obj[i], i, obj)) {\n\t        result.push(obj[i]);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {*}\n\t */\n\t\n\t\n\tfunction find(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  for (var i = 0, len = obj.length; i < len; i++) {\n\t    if (cb.call(context, obj[i], i, obj)) {\n\t      return obj[i];\n\t    }\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @param {*} context\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction bind(func, context) {\n\t  var args = nativeSlice.call(arguments, 2);\n\t  return function () {\n\t    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction curry(func) {\n\t  var args = nativeSlice.call(arguments, 1);\n\t  return function () {\n\t    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArray(value) {\n\t  return objToString.call(value) === '[object Array]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isFunction(value) {\n\t  return typeof value === 'function';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isString(value) {\n\t  return objToString.call(value) === '[object String]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type === 'function' || !!value && type == 'object';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isBuiltInObject(value) {\n\t  return !!BUILTIN_OBJECT[objToString.call(value)];\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isDom(value) {\n\t  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n\t}\n\t/**\n\t * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction eqNaN(value) {\n\t  return value !== value;\n\t}\n\t/**\n\t * If value1 is not null, then return value1, otherwise judget rest of values.\n\t * Low performance.\n\t * @memberOf module:zrender/core/util\n\t * @return {*} Final value\n\t */\n\t\n\t\n\tfunction retrieve(values) {\n\t  for (var i = 0, len = arguments.length; i < len; i++) {\n\t    if (arguments[i] != null) {\n\t      return arguments[i];\n\t    }\n\t  }\n\t}\n\t\n\tfunction retrieve2(value0, value1) {\n\t  return value0 != null ? value0 : value1;\n\t}\n\t\n\tfunction retrieve3(value0, value1, value2) {\n\t  return value0 != null ? value0 : value1 != null ? value1 : value2;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} arr\n\t * @param {number} startIndex\n\t * @param {number} endIndex\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction slice() {\n\t  return Function.call.apply(nativeSlice, arguments);\n\t}\n\t/**\n\t * Normalize css liked array configuration\n\t * e.g.\n\t *  3 => [3, 3, 3, 3]\n\t *  [4, 2] => [4, 2, 4, 2]\n\t *  [4, 3, 2] => [4, 3, 2, 3]\n\t * @param {number|Array.<number>} val\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\tfunction normalizeCssArray(val) {\n\t  if (typeof val === 'number') {\n\t    return [val, val, val, val];\n\t  }\n\t\n\t  var len = val.length;\n\t\n\t  if (len === 2) {\n\t    // vertical | horizontal\n\t    return [val[0], val[1], val[0], val[1]];\n\t  } else if (len === 3) {\n\t    // top | horizontal | bottom\n\t    return [val[0], val[1], val[2], val[1]];\n\t  }\n\t\n\t  return val;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {boolean} condition\n\t * @param {string} message\n\t */\n\t\n\t\n\tfunction assert(condition, message) {\n\t  if (!condition) {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\tvar primitiveKey = '__ec_primitive__';\n\t/**\n\t * Set an object as primitive to be ignored traversing children in clone or merge\n\t */\n\t\n\tfunction setAsPrimitive(obj) {\n\t  obj[primitiveKey] = true;\n\t}\n\t\n\tfunction isPrimitive(obj) {\n\t  return obj[primitiveKey];\n\t}\n\t/**\n\t * @constructor\n\t * @param {Object} obj Only apply `ownProperty`.\n\t */\n\t\n\t\n\tfunction HashMap(obj) {\n\t  obj && each(obj, function (value, key) {\n\t    this.set(key, value);\n\t  }, this);\n\t} // Add prefix to avoid conflict with Object.prototype.\n\t\n\t\n\tvar HASH_MAP_PREFIX = '_ec_';\n\tvar HASH_MAP_PREFIX_LENGTH = 4;\n\tHashMap.prototype = {\n\t  constructor: HashMap,\n\t  // Do not provide `has` method to avoid defining what is `has`.\n\t  // (We usually treat `null` and `undefined` as the same, different\n\t  // from ES6 Map).\n\t  get: function (key) {\n\t    return this[HASH_MAP_PREFIX + key];\n\t  },\n\t  set: function (key, value) {\n\t    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n\t    // used in this case: `var someVal = map.set('a', genVal());`\n\t\n\t    return value;\n\t  },\n\t  // Although util.each can be performed on this hashMap directly, user\n\t  // should not use the exposed keys, who are prefixed.\n\t  each: function (cb, context) {\n\t    context !== void 0 && (cb = bind(cb, context));\n\t\n\t    for (var prefixedKey in this) {\n\t      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n\t    }\n\t  },\n\t  // Do not use this method if performance sensitive.\n\t  removeKey: function (key) {\n\t    delete this[HASH_MAP_PREFIX + key];\n\t  }\n\t};\n\t\n\tfunction createHashMap(obj) {\n\t  return new HashMap(obj);\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.$override = $override;\n\texports.clone = clone;\n\texports.merge = merge;\n\texports.mergeAll = mergeAll;\n\texports.extend = extend;\n\texports.defaults = defaults;\n\texports.createCanvas = createCanvas;\n\texports.getContext = getContext;\n\texports.indexOf = indexOf;\n\texports.inherits = inherits;\n\texports.mixin = mixin;\n\texports.isArrayLike = isArrayLike;\n\texports.each = each;\n\texports.map = map;\n\texports.reduce = reduce;\n\texports.filter = filter;\n\texports.find = find;\n\texports.bind = bind;\n\texports.curry = curry;\n\texports.isArray = isArray;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isObject = isObject;\n\texports.isBuiltInObject = isBuiltInObject;\n\texports.isDom = isDom;\n\texports.eqNaN = eqNaN;\n\texports.retrieve = retrieve;\n\texports.retrieve2 = retrieve2;\n\texports.retrieve3 = retrieve3;\n\texports.slice = slice;\n\texports.normalizeCssArray = normalizeCssArray;\n\texports.assert = assert;\n\texports.setAsPrimitive = setAsPrimitive;\n\texports.isPrimitive = isPrimitive;\n\texports.createHashMap = createHashMap;\n\texports.noop = noop;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar Draggable = __webpack_require__(9);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\tvar SILENT = 'silent';\n\t\n\tfunction makeEventPacket(eveType, targetInfo, event) {\n\t  return {\n\t    type: eveType,\n\t    event: event,\n\t    // target can only be an element that is not silent.\n\t    target: targetInfo.target,\n\t    // topTarget can be a silent element.\n\t    topTarget: targetInfo.topTarget,\n\t    cancelBubble: false,\n\t    offsetX: event.zrX,\n\t    offsetY: event.zrY,\n\t    gestureEvent: event.gestureEvent,\n\t    pinchX: event.pinchX,\n\t    pinchY: event.pinchY,\n\t    pinchScale: event.pinchScale,\n\t    wheelDelta: event.zrDelta,\n\t    zrByTouch: event.zrByTouch,\n\t    which: event.which\n\t  };\n\t}\n\t\n\tfunction EmptyProxy() {}\n\t\n\tEmptyProxy.prototype.dispose = function () {};\n\t\n\tvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\t/**\n\t * @alias module:zrender/Handler\n\t * @constructor\n\t * @extends module:zrender/mixin/Eventful\n\t * @param {module:zrender/Storage} storage Storage instance.\n\t * @param {module:zrender/Painter} painter Painter instance.\n\t * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t */\n\t\n\tvar Handler = function (storage, painter, proxy, painterRoot) {\n\t  Eventful.call(this);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  this.painterRoot = painterRoot;\n\t  proxy = proxy || new EmptyProxy();\n\t  /**\n\t   * Proxy of event. can be Dom, WebGLSurface, etc.\n\t   */\n\t\n\t  this.proxy = proxy; // Attach handler\n\t\n\t  proxy.handler = this;\n\t  /**\n\t   * {target, topTarget, x, y}\n\t   * @private\n\t   * @type {Object}\n\t   */\n\t\n\t  this._hovered = {};\n\t  /**\n\t   * @private\n\t   * @type {Date}\n\t   */\n\t\n\t  this._lastTouchMoment;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastX;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastY;\n\t  Draggable.call(this);\n\t  util.each(handlerNames, function (name) {\n\t    proxy.on && proxy.on(name, this[name], this);\n\t  }, this);\n\t};\n\t\n\tHandler.prototype = {\n\t  constructor: Handler,\n\t  mousemove: function (event) {\n\t    var x = event.zrX;\n\t    var y = event.zrY;\n\t    var lastHovered = this._hovered;\n\t    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n\t    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n\t    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n\t    // See #6198.\n\t\n\t    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n\t      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n\t      lastHoveredTarget = lastHovered.target;\n\t    }\n\t\n\t    var hovered = this._hovered = this.findHover(x, y);\n\t    var hoveredTarget = hovered.target;\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\t\n\t    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(lastHovered, 'mouseout', event);\n\t    } // Mouse moving on one element\n\t\n\t\n\t    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\t\n\t    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(hovered, 'mouseover', event);\n\t    }\n\t  },\n\t  mouseout: function (event) {\n\t    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n\t    // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t    // dom created by echarts), where 'globalout' event should not\n\t    // be triggered when mouse enters these doms. (But 'mouseout'\n\t    // should be triggered at the original hovered element as usual).\n\t\n\t    var element = event.toElement || event.relatedTarget;\n\t    var innerDom;\n\t\n\t    do {\n\t      element = element && element.parentNode;\n\t    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\t\n\t    !innerDom && this.trigger('globalout', {\n\t      event: event\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Resize\n\t   */\n\t  resize: function (event) {\n\t    this._hovered = {};\n\t  },\n\t\n\t  /**\n\t   * Dispatch event\n\t   * @param {string} eventName\n\t   * @param {event=} eventArgs\n\t   */\n\t  dispatch: function (eventName, eventArgs) {\n\t    var handler = this[eventName];\n\t    handler && handler.call(this, eventArgs);\n\t  },\n\t\n\t  /**\n\t   * Dispose\n\t   */\n\t  dispose: function () {\n\t    this.proxy.dispose();\n\t    this.storage = this.proxy = this.painter = null;\n\t  },\n\t\n\t  /**\n\t   * cursor style\n\t   * @param {string} [cursorStyle='default']  crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * \n\t   *\n\t   * @private\n\t   * @param {Object} targetInfo {target, topTarget} \n\t   * @param {string} eventName \n\t   * @param {Object} event \n\t   */\n\t  dispatchToElement: function (targetInfo, eventName, event) {\n\t    targetInfo = targetInfo || {};\n\t    var el = targetInfo.target;\n\t\n\t    if (el && el.silent) {\n\t      return;\n\t    }\n\t\n\t    var eventHandler = 'on' + eventName;\n\t    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\t\n\t    while (el) {\n\t      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t      el.trigger(eventName, eventPacket);\n\t      el = el.parent;\n\t\n\t      if (eventPacket.cancelBubble) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!eventPacket.cancelBubble) {\n\t      //  zrender \n\t      this.trigger(eventName, eventPacket); // \n\t      //  click  dispose painter \n\t\n\t      this.painter && this.painter.eachOtherLayer(function (layer) {\n\t        if (typeof layer[eventHandler] == 'function') {\n\t          layer[eventHandler].call(layer, eventPacket);\n\t        }\n\t\n\t        if (layer.trigger) {\n\t          layer.trigger(eventName, eventPacket);\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @param {module:zrender/graphic/Displayable} exclude\n\t   * @return {model:zrender/Element}\n\t   * @method\n\t   */\n\t  findHover: function (x, y, exclude) {\n\t    var list = this.storage.getDisplayList();\n\t    var out = {\n\t      x: x,\n\t      y: y\n\t    };\n\t\n\t    for (var i = list.length - 1; i >= 0; i--) {\n\t      var hoverCheckResult;\n\t\n\t      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n\t      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n\t        !out.topTarget && (out.topTarget = list[i]);\n\t\n\t        if (hoverCheckResult !== SILENT) {\n\t          out.target = list[i];\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    return out;\n\t  }\n\t}; // Common handlers\n\t\n\tutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  Handler.prototype[name] = function (event) {\n\t    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t    var hovered = this.findHover(event.zrX, event.zrY);\n\t    var hoveredTarget = hovered.target;\n\t\n\t    if (name === 'mousedown') {\n\t      this._downEl = hoveredTarget;\n\t      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\t\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'mosueup') {\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'click') {\n\t      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n\t      // including the case that `mousedown` - `mousemove` - `mouseup`,\n\t      // which should be filtered, otherwise it will bring trouble to\n\t      // pan and zoom.\n\t      || !this._downPoint // Arbitrary value\n\t      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n\t        return;\n\t      }\n\t\n\t      this._downPoint = null;\n\t    }\n\t\n\t    this.dispatchToElement(hovered, name, event);\n\t  };\n\t});\n\t\n\tfunction isHover(displayable, x, y) {\n\t  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t    var el = displayable;\n\t    var isSilent;\n\t\n\t    while (el) {\n\t      // If clipped by ancestor.\n\t      // FIXME: If clipPath has neither stroke nor fill,\n\t      // el.clipPath.contain(x, y) will always return false.\n\t      if (el.clipPath && !el.clipPath.contain(x, y)) {\n\t        return false;\n\t      }\n\t\n\t      if (el.silent) {\n\t        isSilent = true;\n\t      }\n\t\n\t      el = el.parent;\n\t    }\n\t\n\t    return isSilent ? SILENT : true;\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\tutil.mixin(Handler, Eventful);\n\tutil.mixin(Handler, Draggable);\n\tvar _default = Handler;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * \n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @return {Vector2}\n\t */\n\t\n\tfunction create(x, y) {\n\t  var out = new ArrayCtor(2);\n\t\n\t  if (x == null) {\n\t    x = 0;\n\t  }\n\t\n\t  if (y == null) {\n\t    y = 0;\n\t  }\n\t\n\t  out[0] = x;\n\t  out[1] = y;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction copy(out, v) {\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction clone(v) {\n\t  var out = new ArrayCtor(2);\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {number} a\n\t * @param {number} b\n\t * @return {Vector2} \n\t */\n\t\n\t\n\tfunction set(out, a, b) {\n\t  out[0] = a;\n\t  out[1] = b;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction add(out, v1, v2) {\n\t  out[0] = v1[0] + v2[0];\n\t  out[1] = v1[1] + v2[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} a\n\t */\n\t\n\t\n\tfunction scaleAndAdd(out, v1, v2, a) {\n\t  out[0] = v1[0] + v2[0] * a;\n\t  out[1] = v1[1] + v2[1] * a;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction sub(out, v1, v2) {\n\t  out[0] = v1[0] - v2[0];\n\t  out[1] = v1[1] - v2[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction len(v) {\n\t  return Math.sqrt(lenSquare(v));\n\t}\n\t\n\tvar length = len; // jshint ignore:line\n\t\n\t/**\n\t * \n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\tfunction lenSquare(v) {\n\t  return v[0] * v[0] + v[1] * v[1];\n\t}\n\t\n\tvar lengthSquare = lenSquare;\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\tfunction mul(out, v1, v2) {\n\t  out[0] = v1[0] * v2[0];\n\t  out[1] = v1[1] * v2[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction div(out, v1, v2) {\n\t  out[0] = v1[0] / v2[0];\n\t  out[1] = v1[1] / v2[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction dot(v1, v2) {\n\t  return v1[0] * v2[0] + v1[1] * v2[1];\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {number} s\n\t */\n\t\n\t\n\tfunction scale(out, v, s) {\n\t  out[0] = v[0] * s;\n\t  out[1] = v[1] * s;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\t\n\tfunction normalize(out, v) {\n\t  var d = len(v);\n\t\n\t  if (d === 0) {\n\t    out[0] = 0;\n\t    out[1] = 0;\n\t  } else {\n\t    out[0] = v[0] / d;\n\t    out[1] = v[1] / d;\n\t  }\n\t\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction distance(v1, v2) {\n\t  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t}\n\t\n\tvar dist = distance;\n\t/**\n\t * \n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\tfunction distanceSquare(v1, v2) {\n\t  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t}\n\t\n\tvar distSquare = distanceSquare;\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\tfunction negate(out, v) {\n\t  out[0] = -v[0];\n\t  out[1] = -v[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} t\n\t */\n\t\n\t\n\tfunction lerp(out, v1, v2, t) {\n\t  out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t  out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {Vector2} m\n\t */\n\t\n\t\n\tfunction applyTransform(out, v, m) {\n\t  var x = v[0];\n\t  var y = v[1];\n\t  out[0] = m[0] * x + m[2] * y + m[4];\n\t  out[1] = m[1] * x + m[3] * y + m[5];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction min(out, v1, v2) {\n\t  out[0] = Math.min(v1[0], v2[0]);\n\t  out[1] = Math.min(v1[1], v2[1]);\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction max(out, v1, v2) {\n\t  out[0] = Math.max(v1[0], v2[0]);\n\t  out[1] = Math.max(v1[1], v2[1]);\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.copy = copy;\n\texports.clone = clone;\n\texports.set = set;\n\texports.add = add;\n\texports.scaleAndAdd = scaleAndAdd;\n\texports.sub = sub;\n\texports.len = len;\n\texports.length = length;\n\texports.lenSquare = lenSquare;\n\texports.lengthSquare = lengthSquare;\n\texports.mul = mul;\n\texports.div = div;\n\texports.dot = dot;\n\texports.scale = scale;\n\texports.normalize = normalize;\n\texports.distance = distance;\n\texports.dist = dist;\n\texports.distanceSquare = distanceSquare;\n\texports.distSquare = distSquare;\n\texports.negate = negate;\n\texports.lerp = lerp;\n\texports.applyTransform = applyTransform;\n\texports.min = min;\n\texports.max = max;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\tfunction Draggable() {\n\t  this.on('mousedown', this._dragStart, this);\n\t  this.on('mousemove', this._drag, this);\n\t  this.on('mouseup', this._dragEnd, this);\n\t  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n\t  // this._draggingTarget = null;\n\t  // this._x = 0;\n\t  // this._y = 0;\n\t}\n\t\n\tDraggable.prototype = {\n\t  constructor: Draggable,\n\t  _dragStart: function (e) {\n\t    var draggingTarget = e.target;\n\t\n\t    if (draggingTarget && draggingTarget.draggable) {\n\t      this._draggingTarget = draggingTarget;\n\t      draggingTarget.dragging = true;\n\t      this._x = e.offsetX;\n\t      this._y = e.offsetY;\n\t      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n\t    }\n\t  },\n\t  _drag: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      var x = e.offsetX;\n\t      var y = e.offsetY;\n\t      var dx = x - this._x;\n\t      var dy = y - this._y;\n\t      this._x = x;\n\t      this._y = y;\n\t      draggingTarget.drift(dx, dy, e);\n\t      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\t      var dropTarget = this.findHover(x, y, draggingTarget).target;\n\t      var lastDropTarget = this._dropTarget;\n\t      this._dropTarget = dropTarget;\n\t\n\t      if (draggingTarget !== dropTarget) {\n\t        if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n\t        }\n\t\n\t        if (dropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _dragEnd: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      draggingTarget.dragging = false;\n\t    }\n\t\n\t    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\t\n\t    if (this._dropTarget) {\n\t      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n\t    }\n\t\n\t    this._draggingTarget = null;\n\t    this._dropTarget = null;\n\t  }\n\t};\n\t\n\tfunction param(target, e) {\n\t  return {\n\t    target: target,\n\t    topTarget: e && e.topTarget\n\t  };\n\t}\n\t\n\tvar _default = Draggable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\tvar arrySlice = Array.prototype.slice;\n\t/**\n\t * \n\t * @alias module:zrender/mixin/Eventful\n\t * @constructor\n\t */\n\t\n\tvar Eventful = function () {\n\t  this._$handlers = {};\n\t};\n\t\n\tEventful.prototype = {\n\t  constructor: Eventful,\n\t\n\t  /**\n\t   * trigger\n\t   *\n\t   * @param {string} event \n\t   * @param {Function} handler \n\t   * @param {Object} context\n\t   */\n\t  one: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: true,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {string} event \n\t   * @param {Function} handler \n\t   * @param {Object} [context]\n\t   */\n\t  on: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: false,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {string}  event\n\t   * @return {boolean}\n\t   */\n\t  isSilent: function (event) {\n\t    var _h = this._$handlers;\n\t    return _h[event] && _h[event].length;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {string} event \n\t   * @param {Function} [handler] \n\t   */\n\t  off: function (event, handler) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!event) {\n\t      this._$handlers = {};\n\t      return this;\n\t    }\n\t\n\t    if (handler) {\n\t      if (_h[event]) {\n\t        var newList = [];\n\t\n\t        for (var i = 0, l = _h[event].length; i < l; i++) {\n\t          if (_h[event][i]['h'] != handler) {\n\t            newList.push(_h[event][i]);\n\t          }\n\t        }\n\t\n\t        _h[event] = newList;\n\t      }\n\t\n\t      if (_h[event] && _h[event].length === 0) {\n\t        delete _h[event];\n\t      }\n\t    } else {\n\t      delete _h[event];\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   *\n\t   * @param {string} type \n\t   */\n\t  trigger: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 3) {\n\t        args = arrySlice.call(args, 1);\n\t      }\n\t\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(_h[i]['ctx']);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * context, context\n\t   * @param {string} type \n\t   */\n\t  triggerWithContext: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 4) {\n\t        args = arrySlice.call(args, 1, args.length - 1);\n\t      }\n\t\n\t      var ctx = args[args.length - 1];\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(ctx);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(ctx, args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(ctx, args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(ctx, args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t}; //  onxxxx \n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onclick\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseout\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousemove\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousewheel\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousedown\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseup\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrag\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragstart\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragend\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragenter\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragleave\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrop\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\tvar _default = Eventful;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar Group = __webpack_require__(12);\n\t\n\tvar timsort = __webpack_require__(25);\n\t\n\t/**\n\t * Storage\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t// Use timsort because in most case elements are partially sorted\n\t// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\tfunction shapeCompareFunc(a, b) {\n\t  if (a.zlevel === b.zlevel) {\n\t    if (a.z === b.z) {\n\t      // if (a.z2 === b.z2) {\n\t      //     // FIXME Slow has renderidx compare\n\t      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t      //     return a.__renderidx - b.__renderidx;\n\t      // }\n\t      return a.z2 - b.z2;\n\t    }\n\t\n\t    return a.z - b.z;\n\t  }\n\t\n\t  return a.zlevel - b.zlevel;\n\t}\n\t/**\n\t *  (M)\n\t * @alias module:zrender/Storage\n\t * @constructor\n\t */\n\t\n\t\n\tvar Storage = function () {\n\t  // jshint ignore:line\n\t  this._roots = [];\n\t  this._displayList = [];\n\t  this._displayListLen = 0;\n\t};\n\t\n\tStorage.prototype = {\n\t  constructor: Storage,\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   *\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._roots.length; i++) {\n\t      this._roots[i].traverse(cb, context);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {boolean} [update=false] \n\t   * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t   *\n\t   * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t   * @return {Array.<module:zrender/graphic/Displayable>}\n\t   */\n\t  getDisplayList: function (update, includeIgnore) {\n\t    includeIgnore = includeIgnore || false;\n\t\n\t    if (update) {\n\t      this.updateDisplayList(includeIgnore);\n\t    }\n\t\n\t    return this._displayList;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * GroupShapeShape\n\t   * zlevel > z > \n\t   * @param {boolean} [includeIgnore=false]  ignore \n\t   */\n\t  updateDisplayList: function (includeIgnore) {\n\t    this._displayListLen = 0;\n\t    var roots = this._roots;\n\t    var displayList = this._displayList;\n\t\n\t    for (var i = 0, len = roots.length; i < len; i++) {\n\t      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t    }\n\t\n\t    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n\t    //     displayList[i].__renderidx = i;\n\t    // }\n\t    // displayList.sort(shapeCompareFunc);\n\t\n\t    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t  },\n\t  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t    if (el.ignore && !includeIgnore) {\n\t      return;\n\t    }\n\t\n\t    el.beforeUpdate();\n\t\n\t    if (el.__dirty) {\n\t      el.update();\n\t    }\n\t\n\t    el.afterUpdate();\n\t    var userSetClipPath = el.clipPath;\n\t\n\t    if (userSetClipPath) {\n\t      // FIXME \n\t      if (clipPaths) {\n\t        clipPaths = clipPaths.slice();\n\t      } else {\n\t        clipPaths = [];\n\t      }\n\t\n\t      var currentClipPath = userSetClipPath;\n\t      var parentClipPath = el; // Recursively add clip path\n\t\n\t      while (currentClipPath) {\n\t        // clipPath  clipPath \n\t        currentClipPath.parent = parentClipPath;\n\t        currentClipPath.updateTransform();\n\t        clipPaths.push(currentClipPath);\n\t        parentClipPath = currentClipPath;\n\t        currentClipPath = currentClipPath.clipPath;\n\t      }\n\t    }\n\t\n\t    if (el.isGroup) {\n\t      var children = el._children;\n\t\n\t      for (var i = 0; i < children.length; i++) {\n\t        var child = children[i]; // Force to mark as dirty if group is dirty\n\t        // FIXME __dirtyPath ?\n\t\n\t        if (el.__dirty) {\n\t          child.__dirty = true;\n\t        }\n\t\n\t        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t      } // Mark group clean here\n\t\n\t\n\t      el.__dirty = false;\n\t    } else {\n\t      el.__clipPaths = clipPaths;\n\t      this._displayList[this._displayListLen++] = el;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * (Shape)(Group)\n\t   * @param {module:zrender/Element} el\n\t   */\n\t  addRoot: function (el) {\n\t    if (el.__storage === this) {\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Group) {\n\t      el.addChildrenToStorage(this);\n\t    }\n\t\n\t    this.addToStorage(el);\n\t\n\t    this._roots.push(el);\n\t  },\n\t\n\t  /**\n\t   * (Shape)(Group)\n\t   * @param {string|Array.<string>} [el] Storage\n\t   */\n\t  delRoot: function (el) {\n\t    if (el == null) {\n\t      // el\n\t      for (var i = 0; i < this._roots.length; i++) {\n\t        var root = this._roots[i];\n\t\n\t        if (root instanceof Group) {\n\t          root.delChildrenFromStorage(this);\n\t        }\n\t      }\n\t\n\t      this._roots = [];\n\t      this._displayList = [];\n\t      this._displayListLen = 0;\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Array) {\n\t      for (var i = 0, l = el.length; i < l; i++) {\n\t        this.delRoot(el[i]);\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    var idx = util.indexOf(this._roots, el);\n\t\n\t    if (idx >= 0) {\n\t      this.delFromStorage(el);\n\t\n\t      this._roots.splice(idx, 1);\n\t\n\t      if (el instanceof Group) {\n\t        el.delChildrenFromStorage(this);\n\t      }\n\t    }\n\t  },\n\t  addToStorage: function (el) {\n\t    el.__storage = this;\n\t    el.dirty(false);\n\t    return this;\n\t  },\n\t  delFromStorage: function (el) {\n\t    if (el) {\n\t      el.__storage = null;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Storage\n\t   */\n\t  dispose: function () {\n\t    this._renderList = this._roots = null;\n\t  },\n\t  displayableSortFunc: shapeCompareFunc\n\t};\n\tvar _default = Storage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Element = __webpack_require__(13);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/container/Group');\n\t *     var Circle = require('zrender/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Group\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @extends module:zrender/mixin/Eventful\n\t */\n\tvar Group = function (opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts);\n\t\n\t  for (var key in opts) {\n\t    if (opts.hasOwnProperty(key)) {\n\t      this[key] = opts[key];\n\t    }\n\t  }\n\t\n\t  this._children = [];\n\t  this.__storage = null;\n\t  this.__dirty = true;\n\t};\n\t\n\tGroup.prototype = {\n\t  constructor: Group,\n\t  isGroup: true,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  type: 'group',\n\t\n\t  /**\n\t   * \n\t   * @name module:/zrender/container/Group#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/Element>}\n\t   */\n\t  children: function () {\n\t    return this._children.slice();\n\t  },\n\t\n\t  /**\n\t   *  index \n\t   * @param  {number} idx\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childAt: function (idx) {\n\t    return this._children[idx];\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {string} name\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childOfName: function (name) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      if (children[i].name === name) {\n\t        return children[i];\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {number}\n\t   */\n\t  childCount: function () {\n\t    return this._children.length;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {module:zrender/Element} child\n\t   */\n\t  add: function (child) {\n\t    if (child && child !== this && child.parent !== this) {\n\t      this._children.push(child);\n\t\n\t      this._doAdd(child);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   *  nextSibling \n\t   * @param {module:zrender/Element} child\n\t   * @param {module:zrender/Element} nextSibling\n\t   */\n\t  addBefore: function (child, nextSibling) {\n\t    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t      var children = this._children;\n\t      var idx = children.indexOf(nextSibling);\n\t\n\t      if (idx >= 0) {\n\t        children.splice(idx, 0, child);\n\t\n\t        this._doAdd(child);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  _doAdd: function (child) {\n\t    if (child.parent) {\n\t      child.parent.remove(child);\n\t    }\n\t\n\t    child.parent = this;\n\t    var storage = this.__storage;\n\t    var zr = this.__zr;\n\t\n\t    if (storage && storage !== child.__storage) {\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {module:zrender/Element} child\n\t   */\n\t  remove: function (child) {\n\t    var zr = this.__zr;\n\t    var storage = this.__storage;\n\t    var children = this._children;\n\t    var idx = zrUtil.indexOf(children, child);\n\t\n\t    if (idx < 0) {\n\t      return this;\n\t    }\n\t\n\t    children.splice(idx, 1);\n\t    child.parent = null;\n\t\n\t    if (storage) {\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  removeAll: function () {\n\t    var children = this._children;\n\t    var storage = this.__storage;\n\t    var child;\n\t    var i;\n\t\n\t    for (i = 0; i < children.length; i++) {\n\t      child = children[i];\n\t\n\t      if (storage) {\n\t        storage.delFromStorage(child);\n\t\n\t        if (child instanceof Group) {\n\t          child.delChildrenFromStorage(storage);\n\t        }\n\t      }\n\t\n\t      child.parent = null;\n\t    }\n\t\n\t    children.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  eachChild: function (cb, context) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t      cb.call(context, child, i);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      cb.call(context, child);\n\t\n\t      if (child.type === 'group') {\n\t        child.traverse(cb, context);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addChildrenToStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  delChildrenFromStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function (includeChildren) {\n\t    // TODO Caching\n\t    var rect = null;\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var children = includeChildren || this._children;\n\t    var tmpMat = [];\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t\n\t      if (child.ignore || child.invisible) {\n\t        continue;\n\t      }\n\t\n\t      var childRect = child.getBoundingRect();\n\t      var transform = child.getLocalTransform(tmpMat); // TODO\n\t      // The boundingRect cacluated by transforming original\n\t      // rect may be bigger than the actual bundingRect when rotation\n\t      // is used. (Consider a circle rotated aginst its center, where\n\t      // the actual boundingRect should be the same as that not be\n\t      // rotated.) But we can not find better approach to calculate\n\t      // actual boundingRect yet, considering performance.\n\t\n\t      if (transform) {\n\t        tmpRect.copy(childRect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = rect || tmpRect.clone();\n\t        rect.union(tmpRect);\n\t      } else {\n\t        rect = rect || childRect.clone();\n\t        rect.union(childRect);\n\t      }\n\t    }\n\t\n\t    return rect || tmpRect;\n\t  }\n\t};\n\tzrUtil.inherits(Group, Element);\n\tvar _default = Group;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(4);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\tvar Transformable = __webpack_require__(14);\n\t\n\tvar Animatable = __webpack_require__(16);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\t/**\n\t * @alias module:zrender/Element\n\t * @constructor\n\t * @extends {module:zrender/mixin/Animatable}\n\t * @extends {module:zrender/mixin/Transformable}\n\t * @extends {module:zrender/mixin/Eventful}\n\t */\n\tvar Element = function (opts) {\n\t  // jshint ignore:line\n\t  Transformable.call(this, opts);\n\t  Eventful.call(this, opts);\n\t  Animatable.call(this, opts);\n\t  /**\n\t   * ID\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = opts.id || guid();\n\t};\n\t\n\tElement.prototype = {\n\t  /**\n\t   * \n\t   * Element type\n\t   * @type {string}\n\t   */\n\t  type: 'element',\n\t\n\t  /**\n\t   * \n\t   * Element name\n\t   * @type {string}\n\t   */\n\t  name: '',\n\t\n\t  /**\n\t   * ZRender  element  zrender \n\t   * ZRender instance will be assigned when element is associated with zrender\n\t   * @name module:/zrender/Element#__zr\n\t   * @type {module:zrender/ZRender}\n\t   */\n\t  __zr: null,\n\t\n\t  /**\n\t   * true\n\t   * If ignore drawing and events of the element object\n\t   * @name module:/zrender/Element#ignore\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  ignore: false,\n\t\n\t  /**\n\t   * (shape) Group \n\t   * \n\t   * @type {module:zrender/graphic/Path}\n\t   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t   * @readOnly\n\t   */\n\t  clipPath: null,\n\t\n\t  /**\n\t   * Drift element\n\t   * @param  {number} dx dx on the global space\n\t   * @param  {number} dy dy on the global space\n\t   */\n\t  drift: function (dx, dy) {\n\t    switch (this.draggable) {\n\t      case 'horizontal':\n\t        dy = 0;\n\t        break;\n\t\n\t      case 'vertical':\n\t        dx = 0;\n\t        break;\n\t    }\n\t\n\t    var m = this.transform;\n\t\n\t    if (!m) {\n\t      m = this.transform = [1, 0, 0, 1, 0, 0];\n\t    }\n\t\n\t    m[4] += dx;\n\t    m[5] += dy;\n\t    this.decomposeTransform();\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   * Hook before update\n\t   */\n\t  beforeUpdate: function () {},\n\t\n\t  /**\n\t   * Hook after update\n\t   */\n\t  afterUpdate: function () {},\n\t\n\t  /**\n\t   * Update each frame\n\t   */\n\t  update: function () {\n\t    this.updateTransform();\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {},\n\t\n\t  /**\n\t   * @protected\n\t   */\n\t  attrKV: function (key, value) {\n\t    if (key === 'position' || key === 'scale' || key === 'origin') {\n\t      // Copy the array\n\t      if (value) {\n\t        var target = this[key];\n\t\n\t        if (!target) {\n\t          target = this[key] = [];\n\t        }\n\t\n\t        target[0] = value[0];\n\t        target[1] = value[1];\n\t      }\n\t    } else {\n\t      this[key] = value;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hide the element\n\t   */\n\t  hide: function () {\n\t    this.ignore = true;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * Show the element\n\t   */\n\t  show: function () {\n\t    this.ignore = false;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * @param {string|Object} key\n\t   * @param {*} value\n\t   */\n\t  attr: function (key, value) {\n\t    if (typeof key === 'string') {\n\t      this.attrKV(key, value);\n\t    } else if (zrUtil.isObject(key)) {\n\t      for (var name in key) {\n\t        if (key.hasOwnProperty(name)) {\n\t          this.attrKV(name, key[name]);\n\t        }\n\t      }\n\t    }\n\t\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param {module:zrender/graphic/Path} clipPath\n\t   */\n\t  setClipPath: function (clipPath) {\n\t    var zr = this.__zr;\n\t\n\t    if (zr) {\n\t      clipPath.addSelfToZr(zr);\n\t    } // Remove previous clip path\n\t\n\t\n\t    if (this.clipPath && this.clipPath !== clipPath) {\n\t      this.removeClipPath();\n\t    }\n\t\n\t    this.clipPath = clipPath;\n\t    clipPath.__zr = zr;\n\t    clipPath.__clipTarget = this;\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   */\n\t  removeClipPath: function () {\n\t    var clipPath = this.clipPath;\n\t\n\t    if (clipPath) {\n\t      if (clipPath.__zr) {\n\t        clipPath.removeSelfFromZr(clipPath.__zr);\n\t      }\n\t\n\t      clipPath.__zr = null;\n\t      clipPath.__clipTarget = null;\n\t      this.clipPath = null;\n\t      this.dirty(false);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  addSelfToZr: function (zr) {\n\t    this.__zr = zr; // \n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.addAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.addSelfToZr(zr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  removeSelfFromZr: function (zr) {\n\t    this.__zr = null; // \n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.removeAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.removeSelfFromZr(zr);\n\t    }\n\t  }\n\t};\n\tzrUtil.mixin(Element, Animatable);\n\tzrUtil.mixin(Element, Transformable);\n\tzrUtil.mixin(Element, Eventful);\n\tvar _default = Element;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar matrix = __webpack_require__(15);\n\t\n\tvar vector = __webpack_require__(8);\n\t\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\tvar mIdentity = matrix.identity;\n\tvar EPSILON = 5e-5;\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * @alias module:zrender/mixin/Transformable\n\t * @constructor\n\t */\n\t\n\t\n\tvar Transformable = function (opts) {\n\t  opts = opts || {}; // If there are no given position, rotation, scale\n\t\n\t  if (!opts.position) {\n\t    /**\n\t     * \n\t     * @type {Array.<number>}\n\t     * @default [0, 0]\n\t     */\n\t    this.position = [0, 0];\n\t  }\n\t\n\t  if (opts.rotation == null) {\n\t    /**\n\t     * \n\t     * @type {Array.<number>}\n\t     * @default 0\n\t     */\n\t    this.rotation = 0;\n\t  }\n\t\n\t  if (!opts.scale) {\n\t    /**\n\t     * \n\t     * @type {Array.<number>}\n\t     * @default [1, 1]\n\t     */\n\t    this.scale = [1, 1];\n\t  }\n\t  /**\n\t   * \n\t   * @type {Array.<number>}\n\t   * @default null\n\t   */\n\t\n\t\n\t  this.origin = this.origin || null;\n\t};\n\t\n\tvar transformableProto = Transformable.prototype;\n\ttransformableProto.transform = null;\n\t/**\n\t * \n\t * , position, rotation, scaletransformtransform\n\t */\n\t\n\ttransformableProto.needLocalTransform = function () {\n\t  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t};\n\t\n\ttransformableProto.updateTransform = function () {\n\t  var parent = this.parent;\n\t  var parentHasTransform = parent && parent.transform;\n\t  var needLocalTransform = this.needLocalTransform();\n\t  var m = this.transform;\n\t\n\t  if (!(needLocalTransform || parentHasTransform)) {\n\t    m && mIdentity(m);\n\t    return;\n\t  }\n\t\n\t  m = m || matrix.create();\n\t\n\t  if (needLocalTransform) {\n\t    this.getLocalTransform(m);\n\t  } else {\n\t    mIdentity(m);\n\t  } // \n\t\n\t\n\t  if (parentHasTransform) {\n\t    if (needLocalTransform) {\n\t      matrix.mul(m, parent.transform, m);\n\t    } else {\n\t      matrix.copy(m, parent.transform);\n\t    }\n\t  } // \n\t\n\t\n\t  this.transform = m;\n\t  this.invTransform = this.invTransform || matrix.create();\n\t  matrix.invert(this.invTransform, m);\n\t};\n\t\n\ttransformableProto.getLocalTransform = function (m) {\n\t  return Transformable.getLocalTransform(this, m);\n\t};\n\t/**\n\t * transformcontext\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t\n\t\n\ttransformableProto.setTransform = function (ctx) {\n\t  var m = this.transform;\n\t  var dpr = ctx.dpr || 1;\n\t\n\t  if (m) {\n\t    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t  } else {\n\t    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t  }\n\t};\n\t\n\ttransformableProto.restoreTransform = function (ctx) {\n\t  var dpr = ctx.dpr || 1;\n\t  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t};\n\t\n\tvar tmpTransform = [];\n\t/**\n\t * `transform``position`, `rotation`, `scale`\n\t */\n\t\n\ttransformableProto.decomposeTransform = function () {\n\t  if (!this.transform) {\n\t    return;\n\t  }\n\t\n\t  var parent = this.parent;\n\t  var m = this.transform;\n\t\n\t  if (parent && parent.transform) {\n\t    // Get local transform and decompose them to position, scale, rotation\n\t    matrix.mul(tmpTransform, parent.invTransform, m);\n\t    m = tmpTransform;\n\t  }\n\t\n\t  var sx = m[0] * m[0] + m[1] * m[1];\n\t  var sy = m[2] * m[2] + m[3] * m[3];\n\t  var position = this.position;\n\t  var scale = this.scale;\n\t\n\t  if (isNotAroundZero(sx - 1)) {\n\t    sx = Math.sqrt(sx);\n\t  }\n\t\n\t  if (isNotAroundZero(sy - 1)) {\n\t    sy = Math.sqrt(sy);\n\t  }\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  position[0] = m[4];\n\t  position[1] = m[5];\n\t  scale[0] = sx;\n\t  scale[1] = sy;\n\t  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t};\n\t/**\n\t * Get global scale\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.getGlobalScale = function () {\n\t  var m = this.transform;\n\t\n\t  if (!m) {\n\t    return [1, 1];\n\t  }\n\t\n\t  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  return [sx, sy];\n\t};\n\t/**\n\t *  shape \n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToLocal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var invTransform = this.invTransform;\n\t\n\t  if (invTransform) {\n\t    vector.applyTransform(v2, v2, invTransform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * \n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToGlobal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var transform = this.transform;\n\t\n\t  if (transform) {\n\t    vector.applyTransform(v2, v2, transform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * @static\n\t * @param {Object} target\n\t * @param {Array.<number>} target.origin\n\t * @param {number} target.rotation\n\t * @param {Array.<number>} target.position\n\t * @param {Array.<number>} [m]\n\t */\n\t\n\t\n\tTransformable.getLocalTransform = function (target, m) {\n\t  m = m || [];\n\t  mIdentity(m);\n\t  var origin = target.origin;\n\t  var scale = target.scale || [1, 1];\n\t  var rotation = target.rotation || 0;\n\t  var position = target.position || [0, 0];\n\t\n\t  if (origin) {\n\t    // Translate to origin\n\t    m[4] -= origin[0];\n\t    m[5] -= origin[1];\n\t  }\n\t\n\t  matrix.scale(m, m, scale);\n\t\n\t  if (rotation) {\n\t    matrix.rotate(m, m, rotation);\n\t  }\n\t\n\t  if (origin) {\n\t    // Translate back from origin\n\t    m[4] += origin[0];\n\t    m[5] += origin[1];\n\t  }\n\t\n\t  m[4] += position[0];\n\t  m[5] += position[1];\n\t  return m;\n\t};\n\t\n\tvar _default = Transformable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 3x2\n\t * @exports zrender/tool/matrix\n\t */\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * \n\t * @return {Float32Array|Array.<number>}\n\t */\n\t\n\tfunction create() {\n\t  var out = new ArrayCtor(6);\n\t  identity(out);\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t */\n\t\n\t\n\tfunction identity(out) {\n\t  out[0] = 1;\n\t  out[1] = 0;\n\t  out[2] = 0;\n\t  out[3] = 1;\n\t  out[4] = 0;\n\t  out[5] = 0;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m\n\t */\n\t\n\t\n\tfunction copy(out, m) {\n\t  out[0] = m[0];\n\t  out[1] = m[1];\n\t  out[2] = m[2];\n\t  out[3] = m[3];\n\t  out[4] = m[4];\n\t  out[5] = m[5];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m1\n\t * @param {Float32Array|Array.<number>} m2\n\t */\n\t\n\t\n\tfunction mul(out, m1, m2) {\n\t  // Consider matrix.mul(m, m2, m);\n\t  // where out is the same as m2.\n\t  // So use temp variable to escape error.\n\t  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t  out[0] = out0;\n\t  out[1] = out1;\n\t  out[2] = out2;\n\t  out[3] = out3;\n\t  out[4] = out4;\n\t  out[5] = out5;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction translate(out, a, v) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  out[4] = a[4] + v[0];\n\t  out[5] = a[5] + v[1];\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {number} rad\n\t */\n\t\n\t\n\tfunction rotate(out, a, rad) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var st = Math.sin(rad);\n\t  var ct = Math.cos(rad);\n\t  out[0] = aa * ct + ab * st;\n\t  out[1] = -aa * st + ab * ct;\n\t  out[2] = ac * ct + ad * st;\n\t  out[3] = -ac * st + ct * ad;\n\t  out[4] = ct * atx + st * aty;\n\t  out[5] = ct * aty - st * atx;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction scale(out, a, v) {\n\t  var vx = v[0];\n\t  var vy = v[1];\n\t  out[0] = a[0] * vx;\n\t  out[1] = a[1] * vy;\n\t  out[2] = a[2] * vx;\n\t  out[3] = a[3] * vy;\n\t  out[4] = a[4] * vx;\n\t  out[5] = a[5] * vy;\n\t  return out;\n\t}\n\t/**\n\t * \n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t */\n\t\n\t\n\tfunction invert(out, a) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var det = aa * ad - ab * ac;\n\t\n\t  if (!det) {\n\t    return null;\n\t  }\n\t\n\t  det = 1.0 / det;\n\t  out[0] = ad * det;\n\t  out[1] = -ab * det;\n\t  out[2] = -ac * det;\n\t  out[3] = aa * det;\n\t  out[4] = (ac * aty - ad * atx) * det;\n\t  out[5] = (ab * atx - aa * aty) * det;\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.identity = identity;\n\texports.copy = copy;\n\texports.mul = mul;\n\texports.translate = translate;\n\texports.rotate = rotate;\n\texports.scale = scale;\n\texports.invert = invert;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Animator = __webpack_require__(17);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar isString = _util.isString;\n\tvar isFunction = _util.isFunction;\n\tvar isObject = _util.isObject;\n\tvar isArrayLike = _util.isArrayLike;\n\tvar indexOf = _util.indexOf;\n\t\n\t/**\n\t * @alias modue:zrender/mixin/Animatable\n\t * @constructor\n\t */\n\tvar Animatable = function () {\n\t  /**\n\t   * @type {Array.<module:zrender/animation/Animator>}\n\t   * @readOnly\n\t   */\n\t  this.animators = [];\n\t};\n\t\n\tAnimatable.prototype = {\n\t  constructor: Animatable,\n\t\n\t  /**\n\t   * \n\t   *\n\t   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n\t   * @param {boolean} [loop] Whether to loop animation.\n\t   * @return {module:zrender/animation/Animator}\n\t   * @example:\n\t   *     el.animate('style', false)\n\t   *         .when(1000, {x: 10} )\n\t   *         .done(function(){ // Animation done })\n\t   *         .start()\n\t   */\n\t  animate: function (path, loop) {\n\t    var target;\n\t    var animatingShape = false;\n\t    var el = this;\n\t    var zr = this.__zr;\n\t\n\t    if (path) {\n\t      var pathSplitted = path.split('.');\n\t      var prop = el; // If animating shape\n\t\n\t      animatingShape = pathSplitted[0] === 'shape';\n\t\n\t      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t        if (!prop) {\n\t          continue;\n\t        }\n\t\n\t        prop = prop[pathSplitted[i]];\n\t      }\n\t\n\t      if (prop) {\n\t        target = prop;\n\t      }\n\t    } else {\n\t      target = el;\n\t    }\n\t\n\t    if (!target) {\n\t      log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t      return;\n\t    }\n\t\n\t    var animators = el.animators;\n\t    var animator = new Animator(target, loop);\n\t    animator.during(function (target) {\n\t      el.dirty(animatingShape);\n\t    }).done(function () {\n\t      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t      animators.splice(indexOf(animators, animator), 1);\n\t    });\n\t    animators.push(animator); // If animate after added to the zrender\n\t\n\t    if (zr) {\n\t      zr.animation.addAnimator(animator);\n\t    }\n\t\n\t    return animator;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stopAnimation: function (forwardToLast) {\n\t    var animators = this.animators;\n\t    var len = animators.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      animators[i].stop(forwardToLast);\n\t    }\n\t\n\t    animators.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Caution: this method will stop previous animation.\n\t   * So do not use this method to one element twice before\n\t   * animation starts, unless you know what you are doing.\n\t   * @param {Object} target\n\t   * @param {number} [time=500] Time in ms\n\t   * @param {string} [easing='linear']\n\t   * @param {number} [delay=0]\n\t   * @param {Function} [callback]\n\t   * @param {Function} [forceAnimate] Prevent stop animation and callback\n\t   *        immediently when target values are the same as current values.\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el.animateTo({\n\t   *      position: [10, 10]\n\t   *  }, function () { // done })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t   *  el.animateTo({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100, 'cubicOut', function () { // done })\n\t   */\n\t  // TODO Return animation key\n\t  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n\t    // animateTo(target, time, easing, callback);\n\t    if (isString(delay)) {\n\t      callback = easing;\n\t      easing = delay;\n\t      delay = 0;\n\t    } // animateTo(target, time, delay, callback);\n\t    else if (isFunction(easing)) {\n\t        callback = easing;\n\t        easing = 'linear';\n\t        delay = 0;\n\t      } // animateTo(target, time, callback);\n\t      else if (isFunction(delay)) {\n\t          callback = delay;\n\t          delay = 0;\n\t        } // animateTo(target, callback)\n\t        else if (isFunction(time)) {\n\t            callback = time;\n\t            time = 500;\n\t          } // animateTo(target)\n\t          else if (!time) {\n\t              time = 500;\n\t            } // Stop all previous animations\n\t\n\t\n\t    this.stopAnimation();\n\t\n\t    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n\t    // if there is nothing to animate\n\t\n\t\n\t    var animators = this.animators.slice();\n\t    var count = animators.length;\n\t\n\t    function done() {\n\t      count--;\n\t\n\t      if (!count) {\n\t        callback && callback();\n\t      }\n\t    } // No animators. This should be checked before animators[i].start(),\n\t    // because 'done' may be executed immediately if no need to animate.\n\t\n\t\n\t    if (!count) {\n\t      callback && callback();\n\t    } // Start after all animators created\n\t    // Incase any animator is done immediately when all animation properties are not changed\n\t\n\t\n\t    for (var i = 0; i < animators.length; i++) {\n\t      animators[i].done(done).start(easing, forceAnimate);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} path=''\n\t   * @param {Object} source=this\n\t   * @param {Object} target\n\t   * @param {number} [time=500]\n\t   * @param {number} [delay=0]\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el._animateToShallow({\n\t   *      position: [10, 10]\n\t   *  })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms\n\t   *  el._animateToShallow({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100)\n\t   */\n\t  _animateToShallow: function (path, source, target, time, delay) {\n\t    var objShallow = {};\n\t    var propertyCount = 0;\n\t\n\t    for (var name in target) {\n\t      if (!target.hasOwnProperty(name)) {\n\t        continue;\n\t      }\n\t\n\t      if (source[name] != null) {\n\t        if (isObject(target[name]) && !isArrayLike(target[name])) {\n\t          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t        } else {\n\t          objShallow[name] = target[name];\n\t          propertyCount++;\n\t        }\n\t      } else if (target[name] != null) {\n\t        // Attr directly if not has property\n\t        // FIXME, if some property not needed for element ?\n\t        if (!path) {\n\t          this.attr(name, target[name]);\n\t        } else {\n\t          // Shape or style\n\t          var props = {};\n\t          props[path] = {};\n\t          props[path][name] = target[name];\n\t          this.attr(props);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (propertyCount > 0) {\n\t      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t    }\n\t\n\t    return this;\n\t  }\n\t};\n\tvar _default = Animatable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Clip = __webpack_require__(18);\n\t\n\tvar color = __webpack_require__(20);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar isArrayLike = _util.isArrayLike;\n\t\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\tvar arraySlice = Array.prototype.slice;\n\t\n\tfunction defaultGetter(target, key) {\n\t  return target[key];\n\t}\n\t\n\tfunction defaultSetter(target, key, value) {\n\t  target[key] = value;\n\t}\n\t/**\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} percent\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction interpolateNumber(p0, p1, percent) {\n\t  return (p1 - p0) * percent + p0;\n\t}\n\t/**\n\t * @param  {string} p0\n\t * @param  {string} p1\n\t * @param  {number} percent\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction interpolateString(p0, p1, percent) {\n\t  return percent > 0.5 ? p1 : p0;\n\t}\n\t/**\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {number} percent\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction interpolateArray(p0, p1, percent, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t    }\n\t  } else {\n\t    var len2 = len && p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t      }\n\t    }\n\t  }\n\t} // arr0 is source array, arr1 is target array.\n\t// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t\n\t\n\tfunction fillArr(arr0, arr1, arrDim) {\n\t  var arr0Len = arr0.length;\n\t  var arr1Len = arr1.length;\n\t\n\t  if (arr0Len !== arr1Len) {\n\t    // FIXME Not work for TypedArray\n\t    var isPreviousLarger = arr0Len > arr1Len;\n\t\n\t    if (isPreviousLarger) {\n\t      // Cut the previous\n\t      arr0.length = arr1Len;\n\t    } else {\n\t      // Fill the previous\n\t      for (var i = arr0Len; i < arr1Len; i++) {\n\t        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t      }\n\t    }\n\t  } // Handling NaN value\n\t\n\t\n\t  var len2 = arr0[0] && arr0[0].length;\n\t\n\t  for (var i = 0; i < arr0.length; i++) {\n\t    if (arrDim === 1) {\n\t      if (isNaN(arr0[i])) {\n\t        arr0[i] = arr1[i];\n\t      }\n\t    } else {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (isNaN(arr0[i][j])) {\n\t          arr0[i][j] = arr1[i][j];\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param  {Array} arr0\n\t * @param  {Array} arr1\n\t * @param  {number} arrDim\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArraySame(arr0, arr1, arrDim) {\n\t  if (arr0 === arr1) {\n\t    return true;\n\t  }\n\t\n\t  var len = arr0.length;\n\t\n\t  if (len !== arr1.length) {\n\t    return false;\n\t  }\n\t\n\t  if (arrDim === 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      if (arr0[i] !== arr1[i]) {\n\t        return false;\n\t      }\n\t    }\n\t  } else {\n\t    var len2 = arr0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (arr0[i][j] !== arr1[i][j]) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t/**\n\t * Catmull Rom interpolate array\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t    }\n\t  } else {\n\t    var len2 = p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * Catmull Rom interpolate number\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t\n\tfunction cloneValue(value) {\n\t  if (isArrayLike(value)) {\n\t    var len = value.length;\n\t\n\t    if (isArrayLike(value[0])) {\n\t      var ret = [];\n\t\n\t      for (var i = 0; i < len; i++) {\n\t        ret.push(arraySlice.call(value[i]));\n\t      }\n\t\n\t      return ret;\n\t    }\n\t\n\t    return arraySlice.call(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction rgba2String(rgba) {\n\t  rgba[0] = Math.floor(rgba[0]);\n\t  rgba[1] = Math.floor(rgba[1]);\n\t  rgba[2] = Math.floor(rgba[2]);\n\t  return 'rgba(' + rgba.join(',') + ')';\n\t}\n\t\n\tfunction getArrayDim(keyframes) {\n\t  var lastValue = keyframes[keyframes.length - 1].value;\n\t  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n\t}\n\t\n\tfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n\t  var getter = animator._getter;\n\t  var setter = animator._setter;\n\t  var useSpline = easing === 'spline';\n\t  var trackLen = keyframes.length;\n\t\n\t  if (!trackLen) {\n\t    return;\n\t  } // Guess data type\n\t\n\t\n\t  var firstVal = keyframes[0].value;\n\t  var isValueArray = isArrayLike(firstVal);\n\t  var isValueColor = false;\n\t  var isValueString = false; // For vertices morphing\n\t\n\t  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\t  var trackMaxTime; // Sort keyframe as ascending\n\t\n\t  keyframes.sort(function (a, b) {\n\t    return a.time - b.time;\n\t  });\n\t  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\t\n\t  var kfPercents = []; // Value of each keyframe\n\t\n\t  var kfValues = [];\n\t  var prevValue = keyframes[0].value;\n\t  var isAllValueEqual = true;\n\t\n\t  for (var i = 0; i < trackLen; i++) {\n\t    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\t\n\t    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\t\n\t    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t      isAllValueEqual = false;\n\t    }\n\t\n\t    prevValue = value; // Try converting a string to a color array\n\t\n\t    if (typeof value == 'string') {\n\t      var colorArray = color.parse(value);\n\t\n\t      if (colorArray) {\n\t        value = colorArray;\n\t        isValueColor = true;\n\t      } else {\n\t        isValueString = true;\n\t      }\n\t    }\n\t\n\t    kfValues.push(value);\n\t  }\n\t\n\t  if (!forceAnimate && isAllValueEqual) {\n\t    return;\n\t  }\n\t\n\t  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\t\n\t  for (var i = 0; i < trackLen - 1; i++) {\n\t    if (isValueArray) {\n\t      fillArr(kfValues[i], lastValue, arrDim);\n\t    } else {\n\t      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t        kfValues[i] = lastValue;\n\t      }\n\t    }\n\t  }\n\t\n\t  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n\t  // animation playback is sequency\n\t\n\t  var lastFrame = 0;\n\t  var lastFramePercent = 0;\n\t  var start;\n\t  var w;\n\t  var p0;\n\t  var p1;\n\t  var p2;\n\t  var p3;\n\t\n\t  if (isValueColor) {\n\t    var rgba = [0, 0, 0, 0];\n\t  }\n\t\n\t  var onframe = function (target, percent) {\n\t    // Find the range keyframes\n\t    // kf1-----kf2---------current--------kf3\n\t    // find kf2 and kf3 and do interpolation\n\t    var frame; // In the easing function like elasticOut, percent may less than 0\n\t\n\t    if (percent < 0) {\n\t      frame = 0;\n\t    } else if (percent < lastFramePercent) {\n\t      // Start from next key\n\t      // PENDING start from lastFrame ?\n\t      start = Math.min(lastFrame + 1, trackLen - 1);\n\t\n\t      for (frame = start; frame >= 0; frame--) {\n\t        if (kfPercents[frame] <= percent) {\n\t          break;\n\t        }\n\t      } // PENDING really need to do this ?\n\t\n\t\n\t      frame = Math.min(frame, trackLen - 2);\n\t    } else {\n\t      for (frame = lastFrame; frame < trackLen; frame++) {\n\t        if (kfPercents[frame] > percent) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      frame = Math.min(frame - 1, trackLen - 2);\n\t    }\n\t\n\t    lastFrame = frame;\n\t    lastFramePercent = percent;\n\t    var range = kfPercents[frame + 1] - kfPercents[frame];\n\t\n\t    if (range === 0) {\n\t      return;\n\t    } else {\n\t      w = (percent - kfPercents[frame]) / range;\n\t    }\n\t\n\t    if (useSpline) {\n\t      p1 = kfValues[frame];\n\t      p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t\n\t      if (isValueArray) {\n\t        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(p1, p2, w);\n\t        } else {\n\t          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    } else {\n\t      if (isValueArray) {\n\t        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t        } else {\n\t          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    }\n\t  };\n\t\n\t  var clip = new Clip({\n\t    target: animator._target,\n\t    life: trackMaxTime,\n\t    loop: animator._loop,\n\t    delay: animator._delay,\n\t    onframe: onframe,\n\t    ondestroy: oneTrackDone\n\t  });\n\t\n\t  if (easing && easing !== 'spline') {\n\t    clip.easing = easing;\n\t  }\n\t\n\t  return clip;\n\t}\n\t/**\n\t * @alias module:zrender/animation/Animator\n\t * @constructor\n\t * @param {Object} target\n\t * @param {boolean} loop\n\t * @param {Function} getter\n\t * @param {Function} setter\n\t */\n\t\n\t\n\tvar Animator = function (target, loop, getter, setter) {\n\t  this._tracks = {};\n\t  this._target = target;\n\t  this._loop = loop || false;\n\t  this._getter = getter || defaultGetter;\n\t  this._setter = setter || defaultSetter;\n\t  this._clipCount = 0;\n\t  this._delay = 0;\n\t  this._doneList = [];\n\t  this._onframeList = [];\n\t  this._clipList = [];\n\t};\n\t\n\tAnimator.prototype = {\n\t  /**\n\t   * \n\t   * @param  {number} time ms\n\t   * @param  {Object} props key-value\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  when: function (time\n\t  /* ms */\n\t  , props) {\n\t    var tracks = this._tracks;\n\t\n\t    for (var propName in props) {\n\t      if (!props.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      if (!tracks[propName]) {\n\t        tracks[propName] = []; // Invalid value\n\t\n\t        var value = this._getter(this._target, propName);\n\t\n\t        if (value == null) {\n\t          // zrLog('Invalid property ' + propName);\n\t          continue;\n\t        } // If time is 0\n\t        //  Then props is given initialize value\n\t        // Else\n\t        //  Initialize value from current prop value\n\t\n\t\n\t        if (time !== 0) {\n\t          tracks[propName].push({\n\t            time: 0,\n\t            value: cloneValue(value)\n\t          });\n\t        }\n\t      }\n\t\n\t      tracks[propName].push({\n\t        time: time,\n\t        value: props[propName]\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {Function} callback\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  during: function (callback) {\n\t    this._onframeList.push(callback);\n\t\n\t    return this;\n\t  },\n\t  pause: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].pause();\n\t    }\n\t\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].resume();\n\t    }\n\t\n\t    this._paused = false;\n\t  },\n\t  isPaused: function () {\n\t    return !!this._paused;\n\t  },\n\t  _doneCallback: function () {\n\t    // Clear all tracks\n\t    this._tracks = {}; // Clear all clips\n\t\n\t    this._clipList.length = 0;\n\t    var doneList = this._doneList;\n\t    var len = doneList.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      doneList[i].call(this);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {string|Function} [easing]\n\t   *         {@link module:zrender/animation/easing}\n\t   * @param  {boolean} forceAnimate\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  start: function (easing, forceAnimate) {\n\t    var self = this;\n\t    var clipCount = 0;\n\t\n\t    var oneTrackDone = function () {\n\t      clipCount--;\n\t\n\t      if (!clipCount) {\n\t        self._doneCallback();\n\t      }\n\t    };\n\t\n\t    var lastClip;\n\t\n\t    for (var propName in this._tracks) {\n\t      if (!this._tracks.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\t\n\t      if (clip) {\n\t        this._clipList.push(clip);\n\t\n\t        clipCount++; // If start after added to animation\n\t\n\t        if (this.animation) {\n\t          this.animation.addClip(clip);\n\t        }\n\t\n\t        lastClip = clip;\n\t      }\n\t    } // Add during callback on the last clip\n\t\n\t\n\t    if (lastClip) {\n\t      var oldOnFrame = lastClip.onframe;\n\t\n\t      lastClip.onframe = function (target, percent) {\n\t        oldOnFrame(target, percent);\n\t\n\t        for (var i = 0; i < self._onframeList.length; i++) {\n\t          self._onframeList[i](target, percent);\n\t        }\n\t      };\n\t    } // This optimization will help the case that in the upper application\n\t    // the view may be refreshed frequently, where animation will be\n\t    // called repeatly but nothing changed.\n\t\n\t\n\t    if (!clipCount) {\n\t      this._doneCallback();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stop: function (forwardToLast) {\n\t    var clipList = this._clipList;\n\t    var animation = this.animation;\n\t\n\t    for (var i = 0; i < clipList.length; i++) {\n\t      var clip = clipList[i];\n\t\n\t      if (forwardToLast) {\n\t        // Move to last frame before stop\n\t        clip.onframe(this._target, 1);\n\t      }\n\t\n\t      animation && animation.removeClip(clip);\n\t    }\n\t\n\t    clipList.length = 0;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {number} time ms\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  delay: function (time) {\n\t    this._delay = time;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param  {Function} cb\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  done: function (cb) {\n\t    if (cb) {\n\t      this._doneList.push(cb);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/animation/Clip>}\n\t   */\n\t  getClips: function () {\n\t    return this._clipList;\n\t  }\n\t};\n\tvar _default = Animator;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar easingFuncs = __webpack_require__(19);\n\t\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\tfunction Clip(options) {\n\t  this._target = options.target; // \n\t\n\t  this._life = options.life || 1000; // \n\t\n\t  this._delay = options.delay || 0; // \n\t  // this._startTime = new Date().getTime() + this._delay;// \n\t\n\t  this._initialized = false; // \n\t\n\t  this.loop = options.loop == null ? false : options.loop;\n\t  this.gap = options.gap || 0;\n\t  this.easing = options.easing || 'Linear';\n\t  this.onframe = options.onframe;\n\t  this.ondestroy = options.ondestroy;\n\t  this.onrestart = options.onrestart;\n\t  this._pausedTime = 0;\n\t  this._paused = false;\n\t}\n\t\n\tClip.prototype = {\n\t  constructor: Clip,\n\t  step: function (globalTime, deltaTime) {\n\t    // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t    // PENDING\n\t    if (!this._initialized) {\n\t      this._startTime = globalTime + this._delay;\n\t      this._initialized = true;\n\t    }\n\t\n\t    if (this._paused) {\n\t      this._pausedTime += deltaTime;\n\t      return;\n\t    }\n\t\n\t    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // \n\t\n\t    if (percent < 0) {\n\t      return;\n\t    }\n\t\n\t    percent = Math.min(percent, 1);\n\t    var easing = this.easing;\n\t    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t    this.fire('frame', schedule); // \n\t\n\t    if (percent == 1) {\n\t      if (this.loop) {\n\t        this.restart(globalTime); // \n\t        //  stage.update \n\t\n\t        return 'restart';\n\t      } // \n\t      // Animation.update\n\t\n\t\n\t      this._needsRemove = true;\n\t      return 'destroy';\n\t    }\n\t\n\t    return null;\n\t  },\n\t  restart: function (globalTime) {\n\t    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t    this._startTime = globalTime - remainder + this.gap;\n\t    this._pausedTime = 0;\n\t    this._needsRemove = false;\n\t  },\n\t  fire: function (eventType, arg) {\n\t    eventType = 'on' + eventType;\n\t\n\t    if (this[eventType]) {\n\t      this[eventType](this._target, arg);\n\t    }\n\t  },\n\t  pause: function () {\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    this._paused = false;\n\t  }\n\t};\n\tvar _default = Clip;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\tvar easing = {\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  linear: function (k) {\n\t    return k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticIn: function (k) {\n\t    return k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticOut: function (k) {\n\t    return k * (2 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k;\n\t    }\n\t\n\t    return -0.5 * (--k * (k - 2) - 1);\n\t  },\n\t  // t^3\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicIn: function (k) {\n\t    return k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicOut: function (k) {\n\t    return --k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k + 2);\n\t  },\n\t  // t^4\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticIn: function (k) {\n\t    return k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticOut: function (k) {\n\t    return 1 - --k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k;\n\t    }\n\t\n\t    return -0.5 * ((k -= 2) * k * k * k - 2);\n\t  },\n\t  // t^5\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticIn: function (k) {\n\t    return k * k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticOut: function (k) {\n\t    return --k * k * k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t  },\n\t  // sin(t)\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalIn: function (k) {\n\t    return 1 - Math.cos(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalOut: function (k) {\n\t    return Math.sin(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalInOut: function (k) {\n\t    return 0.5 * (1 - Math.cos(Math.PI * k));\n\t  },\n\t  // 2^t\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialIn: function (k) {\n\t    return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialOut: function (k) {\n\t    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialInOut: function (k) {\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * Math.pow(1024, k - 1);\n\t    }\n\t\n\t    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t  },\n\t  // sqrt(1-t^2)\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularIn: function (k) {\n\t    return 1 - Math.sqrt(1 - k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularOut: function (k) {\n\t    return Math.sqrt(1 - --k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t    }\n\t\n\t    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t  },\n\t  // \n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticIn: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticInOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t  },\n\t  // \n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backIn: function (k) {\n\t    var s = 1.70158;\n\t    return k * k * ((s + 1) * k - s);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backOut: function (k) {\n\t    var s = 1.70158;\n\t    return --k * k * ((s + 1) * k + s) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backInOut: function (k) {\n\t    var s = 1.70158 * 1.525;\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * (k * k * ((s + 1) * k - s));\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t  },\n\t  // \n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceIn: function (k) {\n\t    return 1 - easing.bounceOut(1 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceOut: function (k) {\n\t    if (k < 1 / 2.75) {\n\t      return 7.5625 * k * k;\n\t    } else if (k < 2 / 2.75) {\n\t      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t    } else if (k < 2.5 / 2.75) {\n\t      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t    } else {\n\t      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceInOut: function (k) {\n\t    if (k < 0.5) {\n\t      return easing.bounceIn(k * 2) * 0.5;\n\t    }\n\t\n\t    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t  }\n\t};\n\tvar _default = easing;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar kCSSColorTable = {\n\t  'transparent': [0, 0, 0, 0],\n\t  'aliceblue': [240, 248, 255, 1],\n\t  'antiquewhite': [250, 235, 215, 1],\n\t  'aqua': [0, 255, 255, 1],\n\t  'aquamarine': [127, 255, 212, 1],\n\t  'azure': [240, 255, 255, 1],\n\t  'beige': [245, 245, 220, 1],\n\t  'bisque': [255, 228, 196, 1],\n\t  'black': [0, 0, 0, 1],\n\t  'blanchedalmond': [255, 235, 205, 1],\n\t  'blue': [0, 0, 255, 1],\n\t  'blueviolet': [138, 43, 226, 1],\n\t  'brown': [165, 42, 42, 1],\n\t  'burlywood': [222, 184, 135, 1],\n\t  'cadetblue': [95, 158, 160, 1],\n\t  'chartreuse': [127, 255, 0, 1],\n\t  'chocolate': [210, 105, 30, 1],\n\t  'coral': [255, 127, 80, 1],\n\t  'cornflowerblue': [100, 149, 237, 1],\n\t  'cornsilk': [255, 248, 220, 1],\n\t  'crimson': [220, 20, 60, 1],\n\t  'cyan': [0, 255, 255, 1],\n\t  'darkblue': [0, 0, 139, 1],\n\t  'darkcyan': [0, 139, 139, 1],\n\t  'darkgoldenrod': [184, 134, 11, 1],\n\t  'darkgray': [169, 169, 169, 1],\n\t  'darkgreen': [0, 100, 0, 1],\n\t  'darkgrey': [169, 169, 169, 1],\n\t  'darkkhaki': [189, 183, 107, 1],\n\t  'darkmagenta': [139, 0, 139, 1],\n\t  'darkolivegreen': [85, 107, 47, 1],\n\t  'darkorange': [255, 140, 0, 1],\n\t  'darkorchid': [153, 50, 204, 1],\n\t  'darkred': [139, 0, 0, 1],\n\t  'darksalmon': [233, 150, 122, 1],\n\t  'darkseagreen': [143, 188, 143, 1],\n\t  'darkslateblue': [72, 61, 139, 1],\n\t  'darkslategray': [47, 79, 79, 1],\n\t  'darkslategrey': [47, 79, 79, 1],\n\t  'darkturquoise': [0, 206, 209, 1],\n\t  'darkviolet': [148, 0, 211, 1],\n\t  'deeppink': [255, 20, 147, 1],\n\t  'deepskyblue': [0, 191, 255, 1],\n\t  'dimgray': [105, 105, 105, 1],\n\t  'dimgrey': [105, 105, 105, 1],\n\t  'dodgerblue': [30, 144, 255, 1],\n\t  'firebrick': [178, 34, 34, 1],\n\t  'floralwhite': [255, 250, 240, 1],\n\t  'forestgreen': [34, 139, 34, 1],\n\t  'fuchsia': [255, 0, 255, 1],\n\t  'gainsboro': [220, 220, 220, 1],\n\t  'ghostwhite': [248, 248, 255, 1],\n\t  'gold': [255, 215, 0, 1],\n\t  'goldenrod': [218, 165, 32, 1],\n\t  'gray': [128, 128, 128, 1],\n\t  'green': [0, 128, 0, 1],\n\t  'greenyellow': [173, 255, 47, 1],\n\t  'grey': [128, 128, 128, 1],\n\t  'honeydew': [240, 255, 240, 1],\n\t  'hotpink': [255, 105, 180, 1],\n\t  'indianred': [205, 92, 92, 1],\n\t  'indigo': [75, 0, 130, 1],\n\t  'ivory': [255, 255, 240, 1],\n\t  'khaki': [240, 230, 140, 1],\n\t  'lavender': [230, 230, 250, 1],\n\t  'lavenderblush': [255, 240, 245, 1],\n\t  'lawngreen': [124, 252, 0, 1],\n\t  'lemonchiffon': [255, 250, 205, 1],\n\t  'lightblue': [173, 216, 230, 1],\n\t  'lightcoral': [240, 128, 128, 1],\n\t  'lightcyan': [224, 255, 255, 1],\n\t  'lightgoldenrodyellow': [250, 250, 210, 1],\n\t  'lightgray': [211, 211, 211, 1],\n\t  'lightgreen': [144, 238, 144, 1],\n\t  'lightgrey': [211, 211, 211, 1],\n\t  'lightpink': [255, 182, 193, 1],\n\t  'lightsalmon': [255, 160, 122, 1],\n\t  'lightseagreen': [32, 178, 170, 1],\n\t  'lightskyblue': [135, 206, 250, 1],\n\t  'lightslategray': [119, 136, 153, 1],\n\t  'lightslategrey': [119, 136, 153, 1],\n\t  'lightsteelblue': [176, 196, 222, 1],\n\t  'lightyellow': [255, 255, 224, 1],\n\t  'lime': [0, 255, 0, 1],\n\t  'limegreen': [50, 205, 50, 1],\n\t  'linen': [250, 240, 230, 1],\n\t  'magenta': [255, 0, 255, 1],\n\t  'maroon': [128, 0, 0, 1],\n\t  'mediumaquamarine': [102, 205, 170, 1],\n\t  'mediumblue': [0, 0, 205, 1],\n\t  'mediumorchid': [186, 85, 211, 1],\n\t  'mediumpurple': [147, 112, 219, 1],\n\t  'mediumseagreen': [60, 179, 113, 1],\n\t  'mediumslateblue': [123, 104, 238, 1],\n\t  'mediumspringgreen': [0, 250, 154, 1],\n\t  'mediumturquoise': [72, 209, 204, 1],\n\t  'mediumvioletred': [199, 21, 133, 1],\n\t  'midnightblue': [25, 25, 112, 1],\n\t  'mintcream': [245, 255, 250, 1],\n\t  'mistyrose': [255, 228, 225, 1],\n\t  'moccasin': [255, 228, 181, 1],\n\t  'navajowhite': [255, 222, 173, 1],\n\t  'navy': [0, 0, 128, 1],\n\t  'oldlace': [253, 245, 230, 1],\n\t  'olive': [128, 128, 0, 1],\n\t  'olivedrab': [107, 142, 35, 1],\n\t  'orange': [255, 165, 0, 1],\n\t  'orangered': [255, 69, 0, 1],\n\t  'orchid': [218, 112, 214, 1],\n\t  'palegoldenrod': [238, 232, 170, 1],\n\t  'palegreen': [152, 251, 152, 1],\n\t  'paleturquoise': [175, 238, 238, 1],\n\t  'palevioletred': [219, 112, 147, 1],\n\t  'papayawhip': [255, 239, 213, 1],\n\t  'peachpuff': [255, 218, 185, 1],\n\t  'peru': [205, 133, 63, 1],\n\t  'pink': [255, 192, 203, 1],\n\t  'plum': [221, 160, 221, 1],\n\t  'powderblue': [176, 224, 230, 1],\n\t  'purple': [128, 0, 128, 1],\n\t  'red': [255, 0, 0, 1],\n\t  'rosybrown': [188, 143, 143, 1],\n\t  'royalblue': [65, 105, 225, 1],\n\t  'saddlebrown': [139, 69, 19, 1],\n\t  'salmon': [250, 128, 114, 1],\n\t  'sandybrown': [244, 164, 96, 1],\n\t  'seagreen': [46, 139, 87, 1],\n\t  'seashell': [255, 245, 238, 1],\n\t  'sienna': [160, 82, 45, 1],\n\t  'silver': [192, 192, 192, 1],\n\t  'skyblue': [135, 206, 235, 1],\n\t  'slateblue': [106, 90, 205, 1],\n\t  'slategray': [112, 128, 144, 1],\n\t  'slategrey': [112, 128, 144, 1],\n\t  'snow': [255, 250, 250, 1],\n\t  'springgreen': [0, 255, 127, 1],\n\t  'steelblue': [70, 130, 180, 1],\n\t  'tan': [210, 180, 140, 1],\n\t  'teal': [0, 128, 128, 1],\n\t  'thistle': [216, 191, 216, 1],\n\t  'tomato': [255, 99, 71, 1],\n\t  'turquoise': [64, 224, 208, 1],\n\t  'violet': [238, 130, 238, 1],\n\t  'wheat': [245, 222, 179, 1],\n\t  'white': [255, 255, 255, 1],\n\t  'whitesmoke': [245, 245, 245, 1],\n\t  'yellow': [255, 255, 0, 1],\n\t  'yellowgreen': [154, 205, 50, 1]\n\t};\n\t\n\tfunction clampCssByte(i) {\n\t  // Clamp to integer 0 .. 255.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 255 ? 255 : i;\n\t}\n\t\n\tfunction clampCssAngle(i) {\n\t  // Clamp to integer 0 .. 360.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 360 ? 360 : i;\n\t}\n\t\n\tfunction clampCssFloat(f) {\n\t  // Clamp to float 0.0 .. 1.0.\n\t  return f < 0 ? 0 : f > 1 ? 1 : f;\n\t}\n\t\n\tfunction parseCssInt(str) {\n\t  // int or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssByte(parseFloat(str) / 100 * 255);\n\t  }\n\t\n\t  return clampCssByte(parseInt(str, 10));\n\t}\n\t\n\tfunction parseCssFloat(str) {\n\t  // float or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssFloat(parseFloat(str) / 100);\n\t  }\n\t\n\t  return clampCssFloat(parseFloat(str));\n\t}\n\t\n\tfunction cssHueToRgb(m1, m2, h) {\n\t  if (h < 0) {\n\t    h += 1;\n\t  } else if (h > 1) {\n\t    h -= 1;\n\t  }\n\t\n\t  if (h * 6 < 1) {\n\t    return m1 + (m2 - m1) * h * 6;\n\t  }\n\t\n\t  if (h * 2 < 1) {\n\t    return m2;\n\t  }\n\t\n\t  if (h * 3 < 2) {\n\t    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t  }\n\t\n\t  return m1;\n\t}\n\t\n\tfunction lerpNumber(a, b, p) {\n\t  return a + (b - a) * p;\n\t}\n\t\n\tfunction setRgba(out, r, g, b, a) {\n\t  out[0] = r;\n\t  out[1] = g;\n\t  out[2] = b;\n\t  out[3] = a;\n\t  return out;\n\t}\n\t\n\tfunction copyRgba(out, a) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  return out;\n\t}\n\t\n\tvar colorCache = new LRU(20);\n\tvar lastRemovedArr = null;\n\t\n\tfunction putToCache(colorStr, rgbaArr) {\n\t  // Reuse removed array\n\t  if (lastRemovedArr) {\n\t    copyRgba(lastRemovedArr, rgbaArr);\n\t  }\n\t\n\t  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n\t}\n\t/**\n\t * @param {string} colorStr\n\t * @param {Array.<number>} out\n\t * @return {Array.<number>}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction parse(colorStr, rgbaArr) {\n\t  if (!colorStr) {\n\t    return;\n\t  }\n\t\n\t  rgbaArr = rgbaArr || [];\n\t  var cached = colorCache.get(colorStr);\n\t\n\t  if (cached) {\n\t    return copyRgba(rgbaArr, cached);\n\t  } // colorStr may be not string\n\t\n\t\n\t  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\t\n\t  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\t\n\t  if (str in kCSSColorTable) {\n\t    copyRgba(rgbaArr, kCSSColorTable[str]);\n\t    putToCache(colorStr, rgbaArr);\n\t    return rgbaArr;\n\t  } // #abc and #abc123 syntax.\n\t\n\t\n\t  if (str.charAt(0) === '#') {\n\t    if (str.length === 4) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xfff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    } else if (str.length === 7) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xffffff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  var op = str.indexOf('('),\n\t      ep = str.indexOf(')');\n\t\n\t  if (op !== -1 && ep + 1 === str.length) {\n\t    var fname = str.substr(0, op);\n\t    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t    var alpha = 1; // To allow case fallthrough.\n\t\n\t    switch (fname) {\n\t      case 'rgba':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        alpha = parseCssFloat(params.pop());\n\t      // jshint ignore:line\n\t      // Fall through.\n\t\n\t      case 'rgb':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsla':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        params[3] = parseCssFloat(params[3]);\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsl':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      default:\n\t        return;\n\t    }\n\t  }\n\t\n\t  setRgba(rgbaArr, 0, 0, 0, 1);\n\t  return;\n\t}\n\t/**\n\t * @param {Array.<number>} hsla\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} rgba\n\t */\n\t\n\t\n\tfunction hsla2rgba(hsla, rgba) {\n\t  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n\t  // NOTE(deanm): According to the CSS spec s/l should only be\n\t  // percentages, but we don't bother and let float or percentage.\n\t\n\t  var s = parseCssFloat(hsla[1]);\n\t  var l = parseCssFloat(hsla[2]);\n\t  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t  var m1 = l * 2 - m2;\n\t  rgba = rgba || [];\n\t  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\t\n\t  if (hsla.length === 4) {\n\t    rgba[3] = hsla[3];\n\t  }\n\t\n\t  return rgba;\n\t}\n\t/**\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} hsla\n\t */\n\t\n\t\n\tfunction rgba2hsla(rgba) {\n\t  if (!rgba) {\n\t    return;\n\t  } // RGB from 0 to 255\n\t\n\t\n\t  var R = rgba[0] / 255;\n\t  var G = rgba[1] / 255;\n\t  var B = rgba[2] / 255;\n\t  var vMin = Math.min(R, G, B); // Min. value of RGB\n\t\n\t  var vMax = Math.max(R, G, B); // Max. value of RGB\n\t\n\t  var delta = vMax - vMin; // Delta RGB value\n\t\n\t  var L = (vMax + vMin) / 2;\n\t  var H;\n\t  var S; // HSL results from 0 to 1\n\t\n\t  if (delta === 0) {\n\t    H = 0;\n\t    S = 0;\n\t  } else {\n\t    if (L < 0.5) {\n\t      S = delta / (vMax + vMin);\n\t    } else {\n\t      S = delta / (2 - vMax - vMin);\n\t    }\n\t\n\t    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t\n\t    if (R === vMax) {\n\t      H = deltaB - deltaG;\n\t    } else if (G === vMax) {\n\t      H = 1 / 3 + deltaR - deltaB;\n\t    } else if (B === vMax) {\n\t      H = 2 / 3 + deltaG - deltaR;\n\t    }\n\t\n\t    if (H < 0) {\n\t      H += 1;\n\t    }\n\t\n\t    if (H > 1) {\n\t      H -= 1;\n\t    }\n\t  }\n\t\n\t  var hsla = [H * 360, S, L];\n\t\n\t  if (rgba[3] != null) {\n\t    hsla.push(rgba[3]);\n\t  }\n\t\n\t  return hsla;\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number} level\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction lift(color, level) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    for (var i = 0; i < 3; i++) {\n\t      if (level < 0) {\n\t        colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t      } else {\n\t        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t      }\n\t    }\n\t\n\t    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction toHex(color) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t  }\n\t}\n\t/**\n\t * Map value to color. Faster than lerp methods because color is represented by rgba array.\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<Array.<number>>} colors List of rgba color array\n\t * @param {Array.<number>} [out] Mapped gba color array\n\t * @return {Array.<number>} will be null/undefined if input illegal.\n\t */\n\t\n\t\n\tfunction fastLerp(normalizedValue, colors, out) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  out = out || [];\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = colors[leftIndex];\n\t  var rightColor = colors[rightIndex];\n\t  var dv = value - leftIndex;\n\t  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n\t  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n\t  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n\t  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\t  return out;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar fastMapToColor = fastLerp;\n\t/**\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<string>} colors Color list.\n\t * @param {boolean=} fullOutput Default false.\n\t * @return {(string|Object)} Result color. If fullOutput,\n\t *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction lerp(normalizedValue, colors, fullOutput) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = parse(colors[leftIndex]);\n\t  var rightColor = parse(colors[rightIndex]);\n\t  var dv = value - leftIndex;\n\t  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n\t  return fullOutput ? {\n\t    color: color,\n\t    leftIndex: leftIndex,\n\t    rightIndex: rightIndex,\n\t    value: value\n\t  } : color;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar mapToColor = lerp;\n\t/**\n\t * @param {string} color\n\t * @param {number=} h 0 ~ 360, ignore when null.\n\t * @param {number=} s 0 ~ 1, ignore when null.\n\t * @param {number=} l 0 ~ 1, ignore when null.\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction modifyHSL(color, h, s, l) {\n\t  color = parse(color);\n\t\n\t  if (color) {\n\t    color = rgba2hsla(color);\n\t    h != null && (color[0] = clampCssAngle(h));\n\t    s != null && (color[1] = parseCssFloat(s));\n\t    l != null && (color[2] = parseCssFloat(l));\n\t    return stringify(hsla2rgba(color), 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number=} alpha 0 ~ 1\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction modifyAlpha(color, alpha) {\n\t  color = parse(color);\n\t\n\t  if (color && alpha != null) {\n\t    color[3] = clampCssFloat(alpha);\n\t    return stringify(color, 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {Array.<number>} arrColor like [12,33,44,0.4]\n\t * @param {string} type 'rgba', 'hsva', ...\n\t * @return {string} Result color. (If input illegal, return undefined).\n\t */\n\t\n\t\n\tfunction stringify(arrColor, type) {\n\t  if (!arrColor || !arrColor.length) {\n\t    return;\n\t  }\n\t\n\t  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t\n\t  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t    colorStr += ',' + arrColor[3];\n\t  }\n\t\n\t  return type + '(' + colorStr + ')';\n\t}\n\t\n\texports.parse = parse;\n\texports.lift = lift;\n\texports.toHex = toHex;\n\texports.fastLerp = fastLerp;\n\texports.fastMapToColor = fastMapToColor;\n\texports.lerp = lerp;\n\texports.mapToColor = mapToColor;\n\texports.modifyHSL = modifyHSL;\n\texports.modifyAlpha = modifyAlpha;\n\texports.stringify = stringify;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t/**\n\t * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t * @constructor\n\t */\n\tvar LinkedList = function () {\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t  this.head = null;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.tail = null;\n\t  this._len = 0;\n\t};\n\t\n\tvar linkedListProto = LinkedList.prototype;\n\t/**\n\t * Insert a new value at the tail\n\t * @param  {} val\n\t * @return {module:zrender/core/LRU~Entry}\n\t */\n\t\n\tlinkedListProto.insert = function (val) {\n\t  var entry = new Entry(val);\n\t  this.insertEntry(entry);\n\t  return entry;\n\t};\n\t/**\n\t * Insert an entry at the tail\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.insertEntry = function (entry) {\n\t  if (!this.head) {\n\t    this.head = this.tail = entry;\n\t  } else {\n\t    this.tail.next = entry;\n\t    entry.prev = this.tail;\n\t    entry.next = null;\n\t    this.tail = entry;\n\t  }\n\t\n\t  this._len++;\n\t};\n\t/**\n\t * Remove entry.\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.remove = function (entry) {\n\t  var prev = entry.prev;\n\t  var next = entry.next;\n\t\n\t  if (prev) {\n\t    prev.next = next;\n\t  } else {\n\t    // Is head\n\t    this.head = next;\n\t  }\n\t\n\t  if (next) {\n\t    next.prev = prev;\n\t  } else {\n\t    // Is tail\n\t    this.tail = prev;\n\t  }\n\t\n\t  entry.next = entry.prev = null;\n\t  this._len--;\n\t};\n\t/**\n\t * @return {number}\n\t */\n\t\n\t\n\tlinkedListProto.len = function () {\n\t  return this._len;\n\t};\n\t/**\n\t * Clear list\n\t */\n\t\n\t\n\tlinkedListProto.clear = function () {\n\t  this.head = this.tail = null;\n\t  this._len = 0;\n\t};\n\t/**\n\t * @constructor\n\t * @param {} val\n\t */\n\t\n\t\n\tvar Entry = function (val) {\n\t  /**\n\t   * @type {}\n\t   */\n\t  this.value = val;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.next;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.prev;\n\t};\n\t/**\n\t * LRU Cache\n\t * @constructor\n\t * @alias module:zrender/core/LRU\n\t */\n\t\n\t\n\tvar LRU = function (maxSize) {\n\t  this._list = new LinkedList();\n\t  this._map = {};\n\t  this._maxSize = maxSize || 10;\n\t  this._lastRemovedEntry = null;\n\t};\n\t\n\tvar LRUProto = LRU.prototype;\n\t/**\n\t * @param  {string} key\n\t * @param  {} value\n\t * @return {} Removed value\n\t */\n\t\n\tLRUProto.put = function (key, value) {\n\t  var list = this._list;\n\t  var map = this._map;\n\t  var removed = null;\n\t\n\t  if (map[key] == null) {\n\t    var len = list.len(); // Reuse last removed entry\n\t\n\t    var entry = this._lastRemovedEntry;\n\t\n\t    if (len >= this._maxSize && len > 0) {\n\t      // Remove the least recently used\n\t      var leastUsedEntry = list.head;\n\t      list.remove(leastUsedEntry);\n\t      delete map[leastUsedEntry.key];\n\t      removed = leastUsedEntry.value;\n\t      this._lastRemovedEntry = leastUsedEntry;\n\t    }\n\t\n\t    if (entry) {\n\t      entry.value = value;\n\t    } else {\n\t      entry = new Entry(value);\n\t    }\n\t\n\t    entry.key = key;\n\t    list.insertEntry(entry);\n\t    map[key] = entry;\n\t  }\n\t\n\t  return removed;\n\t};\n\t/**\n\t * @param  {string} key\n\t * @return {}\n\t */\n\t\n\t\n\tLRUProto.get = function (key) {\n\t  var entry = this._map[key];\n\t  var list = this._list;\n\t\n\t  if (entry != null) {\n\t    // Put the latest used entry in the tail\n\t    if (entry !== list.tail) {\n\t      list.remove(entry);\n\t      list.insertEntry(entry);\n\t    }\n\t\n\t    return entry.value;\n\t  }\n\t};\n\t/**\n\t * Clear the cache\n\t */\n\t\n\t\n\tLRUProto.clear = function () {\n\t  this._list.clear();\n\t\n\t  this._map = {};\n\t};\n\t\n\tvar _default = LRU;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar debugMode = _config.debugMode;\n\t\n\tvar log = function () {};\n\t\n\tif (debugMode === 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      throw new Error(arguments[k]);\n\t    }\n\t  };\n\t} else if (debugMode > 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      console.log(arguments[k]);\n\t    }\n\t  };\n\t}\n\t\n\tvar _default = log;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\tvar dpr = 1; // If in browser environment\n\t\n\tif (typeof window !== 'undefined') {\n\t  dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t}\n\t/**\n\t * config\n\t * @exports zrender/config\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t/**\n\t * debugcatchBrushExceptiontrue\n\t * 0 : debug\n\t * 1 : \n\t * 2 : \n\t */\n\t\n\t\n\tvar debugMode = 0; // retina \n\t\n\tvar devicePixelRatio = dpr;\n\texports.debugMode = debugMode;\n\texports.devicePixelRatio = devicePixelRatio;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar matrix = __webpack_require__(15);\n\t\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\tvar v2ApplyTransform = vec2.applyTransform;\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\t/**\n\t * @alias module:echarts/core/BoundingRect\n\t */\n\t\n\tfunction BoundingRect(x, y, width, height) {\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t\n\t  this.x = x;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.y = y;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.width = width;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.height = height;\n\t}\n\t\n\tBoundingRect.prototype = {\n\t  constructor: BoundingRect,\n\t\n\t  /**\n\t   * @param {module:echarts/core/BoundingRect} other\n\t   */\n\t  union: function (other) {\n\t    var x = mathMin(other.x, this.x);\n\t    var y = mathMin(other.y, this.y);\n\t    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t    this.x = x;\n\t    this.y = y;\n\t  },\n\t\n\t  /**\n\t   * @param {Array.<number>} m\n\t   * @methods\n\t   */\n\t  applyTransform: function () {\n\t    var lt = [];\n\t    var rb = [];\n\t    var lb = [];\n\t    var rt = [];\n\t    return function (m) {\n\t      // In case usage like this\n\t      // el.getBoundingRect().applyTransform(el.transform)\n\t      // And element has no transform\n\t      if (!m) {\n\t        return;\n\t      }\n\t\n\t      lt[0] = lb[0] = this.x;\n\t      lt[1] = rt[1] = this.y;\n\t      rb[0] = rt[0] = this.x + this.width;\n\t      rb[1] = lb[1] = this.y + this.height;\n\t      v2ApplyTransform(lt, lt, m);\n\t      v2ApplyTransform(rb, rb, m);\n\t      v2ApplyTransform(lb, lb, m);\n\t      v2ApplyTransform(rt, rt, m);\n\t      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t      this.width = maxX - this.x;\n\t      this.height = maxY - this.y;\n\t    };\n\t  }(),\n\t\n\t  /**\n\t   * Calculate matrix of transforming from self to target rect\n\t   * @param  {module:zrender/core/BoundingRect} b\n\t   * @return {Array.<number>}\n\t   */\n\t  calculateTransform: function (b) {\n\t    var a = this;\n\t    var sx = b.width / a.width;\n\t    var sy = b.height / a.height;\n\t    var m = matrix.create(); // \n\t\n\t    matrix.translate(m, m, [-a.x, -a.y]);\n\t    matrix.scale(m, m, [sx, sy]);\n\t    matrix.translate(m, m, [b.x, b.y]);\n\t    return m;\n\t  },\n\t\n\t  /**\n\t   * @param {(module:echarts/core/BoundingRect|Object)} b\n\t   * @return {boolean}\n\t   */\n\t  intersect: function (b) {\n\t    if (!b) {\n\t      return false;\n\t    }\n\t\n\t    if (!(b instanceof BoundingRect)) {\n\t      // Normalize negative width/height.\n\t      b = BoundingRect.create(b);\n\t    }\n\t\n\t    var a = this;\n\t    var ax0 = a.x;\n\t    var ax1 = a.x + a.width;\n\t    var ay0 = a.y;\n\t    var ay1 = a.y + a.height;\n\t    var bx0 = b.x;\n\t    var bx1 = b.x + b.width;\n\t    var by0 = b.y;\n\t    var by1 = b.y + b.height;\n\t    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t  },\n\t  contain: function (x, y) {\n\t    var rect = this;\n\t    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t  },\n\t\n\t  /**\n\t   * @return {module:echarts/core/BoundingRect}\n\t   */\n\t  clone: function () {\n\t    return new BoundingRect(this.x, this.y, this.width, this.height);\n\t  },\n\t\n\t  /**\n\t   * Copy from another rect\n\t   */\n\t  copy: function (other) {\n\t    this.x = other.x;\n\t    this.y = other.y;\n\t    this.width = other.width;\n\t    this.height = other.height;\n\t  },\n\t  plain: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  }\n\t};\n\t/**\n\t * @param {Object|module:zrender/core/BoundingRect} rect\n\t * @param {number} rect.x\n\t * @param {number} rect.y\n\t * @param {number} rect.width\n\t * @param {number} rect.height\n\t * @return {module:zrender/core/BoundingRect}\n\t */\n\t\n\tBoundingRect.create = function (rect) {\n\t  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\tvar _default = BoundingRect;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\tvar DEFAULT_MIN_MERGE = 32;\n\tvar DEFAULT_MIN_GALLOPING = 7;\n\tvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\tfunction minRunLength(n) {\n\t  var r = 0;\n\t\n\t  while (n >= DEFAULT_MIN_MERGE) {\n\t    r |= n & 1;\n\t    n >>= 1;\n\t  }\n\t\n\t  return n + r;\n\t}\n\t\n\tfunction makeAscendingRun(array, lo, hi, compare) {\n\t  var runHi = lo + 1;\n\t\n\t  if (runHi === hi) {\n\t    return 1;\n\t  }\n\t\n\t  if (compare(array[runHi++], array[lo]) < 0) {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t      runHi++;\n\t    }\n\t\n\t    reverseRun(array, lo, runHi);\n\t  } else {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t      runHi++;\n\t    }\n\t  }\n\t\n\t  return runHi - lo;\n\t}\n\t\n\tfunction reverseRun(array, lo, hi) {\n\t  hi--;\n\t\n\t  while (lo < hi) {\n\t    var t = array[lo];\n\t    array[lo++] = array[hi];\n\t    array[hi--] = t;\n\t  }\n\t}\n\t\n\tfunction binaryInsertionSort(array, lo, hi, start, compare) {\n\t  if (start === lo) {\n\t    start++;\n\t  }\n\t\n\t  for (; start < hi; start++) {\n\t    var pivot = array[start];\n\t    var left = lo;\n\t    var right = start;\n\t    var mid;\n\t\n\t    while (left < right) {\n\t      mid = left + right >>> 1;\n\t\n\t      if (compare(pivot, array[mid]) < 0) {\n\t        right = mid;\n\t      } else {\n\t        left = mid + 1;\n\t      }\n\t    }\n\t\n\t    var n = start - left;\n\t\n\t    switch (n) {\n\t      case 3:\n\t        array[left + 3] = array[left + 2];\n\t\n\t      case 2:\n\t        array[left + 2] = array[left + 1];\n\t\n\t      case 1:\n\t        array[left + 1] = array[left];\n\t        break;\n\t\n\t      default:\n\t        while (n > 0) {\n\t          array[left + n] = array[left + n - 1];\n\t          n--;\n\t        }\n\t\n\t    }\n\t\n\t    array[left] = pivot;\n\t  }\n\t}\n\t\n\tfunction gallopLeft(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) > 0) {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  } else {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) > 0) {\n\t      lastOffset = m + 1;\n\t    } else {\n\t      offset = m;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction gallopRight(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) < 0) {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  } else {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) < 0) {\n\t      offset = m;\n\t    } else {\n\t      lastOffset = m + 1;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction TimSort(array, compare) {\n\t  var minGallop = DEFAULT_MIN_GALLOPING;\n\t  var length = 0;\n\t  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t  var stackLength = 0;\n\t  var runStart;\n\t  var runLength;\n\t  var stackSize = 0;\n\t  length = array.length;\n\t\n\t  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t    tmpStorageLength = length >>> 1;\n\t  }\n\t\n\t  var tmp = [];\n\t  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t  runStart = [];\n\t  runLength = [];\n\t\n\t  function pushRun(_runStart, _runLength) {\n\t    runStart[stackSize] = _runStart;\n\t    runLength[stackSize] = _runLength;\n\t    stackSize += 1;\n\t  }\n\t\n\t  function mergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t        if (runLength[n - 1] < runLength[n + 1]) {\n\t          n--;\n\t        }\n\t      } else if (runLength[n] > runLength[n + 1]) {\n\t        break;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function forceMergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t        n--;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function mergeAt(i) {\n\t    var start1 = runStart[i];\n\t    var length1 = runLength[i];\n\t    var start2 = runStart[i + 1];\n\t    var length2 = runLength[i + 1];\n\t    runLength[i] = length1 + length2;\n\t\n\t    if (i === stackSize - 3) {\n\t      runStart[i + 1] = runStart[i + 2];\n\t      runLength[i + 1] = runLength[i + 2];\n\t    }\n\t\n\t    stackSize--;\n\t    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t    start1 += k;\n\t    length1 -= k;\n\t\n\t    if (length1 === 0) {\n\t      return;\n\t    }\n\t\n\t    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t    if (length2 === 0) {\n\t      return;\n\t    }\n\t\n\t    if (length1 <= length2) {\n\t      mergeLow(start1, length1, start2, length2);\n\t    } else {\n\t      mergeHigh(start1, length1, start2, length2);\n\t    }\n\t  }\n\t\n\t  function mergeLow(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length1; i++) {\n\t      tmp[i] = array[start1 + i];\n\t    }\n\t\n\t    var cursor1 = 0;\n\t    var cursor2 = start2;\n\t    var dest = start1;\n\t    array[dest++] = array[cursor2++];\n\t\n\t    if (--length2 === 0) {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t    var count1, count2, exit;\n\t\n\t    while (1) {\n\t      count1 = 0;\n\t      count2 = 0;\n\t      exit = false;\n\t\n\t      do {\n\t        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t          array[dest++] = array[cursor2++];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest++] = tmp[cursor1++];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t        if (count1 !== 0) {\n\t          for (i = 0; i < count1; i++) {\n\t            array[dest + i] = tmp[cursor1 + i];\n\t          }\n\t\n\t          dest += count1;\n\t          cursor1 += count1;\n\t          length1 -= count1;\n\t\n\t          if (length1 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = array[cursor2++];\n\t\n\t        if (--length2 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t        if (count2 !== 0) {\n\t          for (i = 0; i < count2; i++) {\n\t            array[dest + i] = array[cursor2 + i];\n\t          }\n\t\n\t          dest += count2;\n\t          cursor2 += count2;\n\t          length2 -= count2;\n\t\n\t          if (length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = tmp[cursor1++];\n\t\n\t        if (--length1 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t    minGallop < 1 && (minGallop = 1);\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t    } else if (length1 === 0) {\n\t      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n\t    } else {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function mergeHigh(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length2; i++) {\n\t      tmp[i] = array[start2 + i];\n\t    }\n\t\n\t    var cursor1 = start1 + length1 - 1;\n\t    var cursor2 = length2 - 1;\n\t    var dest = start2 + length2 - 1;\n\t    var customCursor = 0;\n\t    var customDest = 0;\n\t    array[dest--] = array[cursor1--];\n\t\n\t    if (--length1 === 0) {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t\n\t    while (true) {\n\t      var count1 = 0;\n\t      var count2 = 0;\n\t      var exit = false;\n\t\n\t      do {\n\t        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t          array[dest--] = array[cursor1--];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest--] = tmp[cursor2--];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t        if (count1 !== 0) {\n\t          dest -= count1;\n\t          cursor1 -= count1;\n\t          length1 -= count1;\n\t          customDest = dest + 1;\n\t          customCursor = cursor1 + 1;\n\t\n\t          for (i = count1 - 1; i >= 0; i--) {\n\t            array[customDest + i] = array[customCursor + i];\n\t          }\n\t\n\t          if (length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = tmp[cursor2--];\n\t\n\t        if (--length2 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t        if (count2 !== 0) {\n\t          dest -= count2;\n\t          cursor2 -= count2;\n\t          length2 -= count2;\n\t          customDest = dest + 1;\n\t          customCursor = cursor2 + 1;\n\t\n\t          for (i = 0; i < count2; i++) {\n\t            array[customDest + i] = tmp[customCursor + i];\n\t          }\n\t\n\t          if (length2 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = array[cursor1--];\n\t\n\t        if (--length1 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t\n\t    if (minGallop < 1) {\n\t      minGallop = 1;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t    } else if (length2 === 0) {\n\t      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n\t    } else {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  this.mergeRuns = mergeRuns;\n\t  this.forceMergeRuns = forceMergeRuns;\n\t  this.pushRun = pushRun;\n\t}\n\t\n\tfunction sort(array, compare, lo, hi) {\n\t  if (!lo) {\n\t    lo = 0;\n\t  }\n\t\n\t  if (!hi) {\n\t    hi = array.length;\n\t  }\n\t\n\t  var remaining = hi - lo;\n\t\n\t  if (remaining < 2) {\n\t    return;\n\t  }\n\t\n\t  var runLength = 0;\n\t\n\t  if (remaining < DEFAULT_MIN_MERGE) {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t    return;\n\t  }\n\t\n\t  var ts = new TimSort(array, compare);\n\t  var minRun = minRunLength(remaining);\n\t\n\t  do {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t\n\t    if (runLength < minRun) {\n\t      var force = remaining;\n\t\n\t      if (force > minRun) {\n\t        force = minRun;\n\t      }\n\t\n\t      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t      runLength = force;\n\t    }\n\t\n\t    ts.pushRun(lo, runLength);\n\t    ts.mergeRuns();\n\t    remaining -= runLength;\n\t    lo += runLength;\n\t  } while (remaining !== 0);\n\t\n\t  ts.forceMergeRuns();\n\t}\n\t\n\tmodule.exports = sort;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar util = __webpack_require__(6);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar timsort = __webpack_require__(25);\n\t\n\tvar Layer = __webpack_require__(27);\n\t\n\tvar requestAnimationFrame = __webpack_require__(30);\n\t\n\tvar Image = __webpack_require__(31);\n\t\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t// PENDIGN\n\t// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t//\n\t// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\tvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t\n\tfunction isLayerValid(layer) {\n\t  if (!layer) {\n\t    return false;\n\t  }\n\t\n\t  if (layer.__builtin__) {\n\t    return true;\n\t  }\n\t\n\t  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\tfunction preProcessLayer(layer) {\n\t  layer.__unusedCount++;\n\t}\n\t\n\tfunction postProcessLayer(layer) {\n\t  if (layer.__unusedCount == 1) {\n\t    layer.clear();\n\t  }\n\t}\n\t\n\tvar tmpRect = new BoundingRect(0, 0, 0, 0);\n\tvar viewRect = new BoundingRect(0, 0, 0, 0);\n\t\n\tfunction isDisplayableCulled(el, width, height) {\n\t  tmpRect.copy(el.getBoundingRect());\n\t\n\t  if (el.transform) {\n\t    tmpRect.applyTransform(el.transform);\n\t  }\n\t\n\t  viewRect.width = width;\n\t  viewRect.height = height;\n\t  return !tmpRect.intersect(viewRect);\n\t}\n\t\n\tfunction isClipPathChanged(clipPaths, prevClipPaths) {\n\t  if (clipPaths == prevClipPaths) {\n\t    // Can both be null or undefined\n\t    return false;\n\t  }\n\t\n\t  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t    return true;\n\t  }\n\t\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    if (clipPaths[i] !== prevClipPaths[i]) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tfunction doClip(clipPaths, ctx) {\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    var clipPath = clipPaths[i];\n\t    clipPath.setTransform(ctx);\n\t    ctx.beginPath();\n\t    clipPath.buildPath(ctx, clipPath.shape);\n\t    ctx.clip(); // Transform back\n\t\n\t    clipPath.restoreTransform(ctx);\n\t  }\n\t}\n\t\n\tfunction createRoot(width, height) {\n\t  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // \n\t\n\t  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n\t  return domRoot;\n\t}\n\t/**\n\t * @alias module:zrender/Painter\n\t * @constructor\n\t * @param {HTMLElement} root \n\t * @param {module:zrender/Storage} storage\n\t * @param {Object} opts\n\t */\n\t\n\t\n\tvar Painter = function (root, storage, opts) {\n\t  this.type = 'canvas'; // In node environment using node-canvas\n\t\n\t  var singleCanvas = !root.nodeName // In node ?\n\t  || root.nodeName.toUpperCase() === 'CANVAS';\n\t  this._opts = opts = util.extend({}, opts || {});\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._singleCanvas = singleCanvas;\n\t  /**\n\t   * \n\t   * @type {HTMLElement}\n\t   */\n\t\n\t  this.root = root;\n\t  var rootStyle = root.style;\n\t\n\t  if (rootStyle) {\n\t    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t    root.innerHTML = '';\n\t  }\n\t  /**\n\t   * @type {module:zrender/Storage}\n\t   */\n\t\n\t\n\t  this.storage = storage;\n\t  /**\n\t   * @type {Array.<number>}\n\t   * @private\n\t   */\n\t\n\t  var zlevelList = this._zlevelList = [];\n\t  /**\n\t   * @type {Object.<string, module:zrender/Layer>}\n\t   * @private\n\t   */\n\t\n\t  var layers = this._layers = {};\n\t  /**\n\t   * @type {Object.<string, Object>}\n\t   * @type {private}\n\t   */\n\t\n\t  this._layerConfig = {};\n\t\n\t  if (!singleCanvas) {\n\t    this._width = this._getSize(0);\n\t    this._height = this._getSize(1);\n\t    var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t    root.appendChild(domRoot);\n\t  } else {\n\t    if (opts.width != null) {\n\t      root.width = opts.width;\n\t    }\n\t\n\t    if (opts.height != null) {\n\t      root.height = opts.height;\n\t    } // Use canvas width and height directly\n\t\n\t\n\t    var width = root.width;\n\t    var height = root.height;\n\t    this._width = width;\n\t    this._height = height; // Create layer if only one given canvas\n\t    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t\n\t    var mainLayer = new Layer(root, this, 1);\n\t    mainLayer.initContext(); // FIXME Use canvas width and height\n\t    // mainLayer.resize(width, height);\n\t\n\t    layers[0] = mainLayer;\n\t    zlevelList.push(0);\n\t    this._domRoot = root;\n\t  } // Layers for progressive rendering\n\t\n\t\n\t  this._progressiveLayers = [];\n\t  /**\n\t   * @type {module:zrender/Layer}\n\t   * @private\n\t   */\n\t\n\t  this._hoverlayer;\n\t  this._hoverElements = [];\n\t};\n\t\n\tPainter.prototype = {\n\t  constructor: Painter,\n\t  getType: function () {\n\t    return 'canvas';\n\t  },\n\t\n\t  /**\n\t   * If painter use a single canvas\n\t   * @return {boolean}\n\t   */\n\t  isSingleCanvas: function () {\n\t    return this._singleCanvas;\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._domRoot;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {boolean} [paintAll=false] displayable\n\t   */\n\t  refresh: function (paintAll) {\n\t    var list = this.storage.getDisplayList(true);\n\t    var zlevelList = this._zlevelList;\n\t\n\t    this._paintList(list, paintAll); // Paint custum layers\n\t\n\t\n\t    for (var i = 0; i < zlevelList.length; i++) {\n\t      var z = zlevelList[i];\n\t      var layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__ && layer.refresh) {\n\t        layer.refresh();\n\t      }\n\t    }\n\t\n\t    this.refreshHover();\n\t\n\t    if (this._progressiveLayers.length) {\n\t      this._startProgessive();\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addHover: function (el, hoverStyle) {\n\t    if (el.__hoverMir) {\n\t      return;\n\t    }\n\t\n\t    var elMirror = new el.constructor({\n\t      style: el.style,\n\t      shape: el.shape\n\t    });\n\t    elMirror.__from = el;\n\t    el.__hoverMir = elMirror;\n\t    elMirror.setStyle(hoverStyle);\n\t\n\t    this._hoverElements.push(elMirror);\n\t  },\n\t  removeHover: function (el) {\n\t    var elMirror = el.__hoverMir;\n\t    var hoverElements = this._hoverElements;\n\t    var idx = util.indexOf(hoverElements, elMirror);\n\t\n\t    if (idx >= 0) {\n\t      hoverElements.splice(idx, 1);\n\t    }\n\t\n\t    el.__hoverMir = null;\n\t  },\n\t  clearHover: function (el) {\n\t    var hoverElements = this._hoverElements;\n\t\n\t    for (var i = 0; i < hoverElements.length; i++) {\n\t      var from = hoverElements[i].__from;\n\t\n\t      if (from) {\n\t        from.__hoverMir = null;\n\t      }\n\t    }\n\t\n\t    hoverElements.length = 0;\n\t  },\n\t  refreshHover: function () {\n\t    var hoverElements = this._hoverElements;\n\t    var len = hoverElements.length;\n\t    var hoverLayer = this._hoverlayer;\n\t    hoverLayer && hoverLayer.clear();\n\t\n\t    if (!len) {\n\t      return;\n\t    }\n\t\n\t    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n\t    // FIXME?\n\t\n\t    if (!hoverLayer) {\n\t      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t    }\n\t\n\t    var scope = {};\n\t    hoverLayer.ctx.save();\n\t\n\t    for (var i = 0; i < len;) {\n\t      var el = hoverElements[i];\n\t      var originalEl = el.__from; // Original el is removed\n\t      // PENDING\n\t\n\t      if (!(originalEl && originalEl.__zr)) {\n\t        hoverElements.splice(i, 1);\n\t        originalEl.__hoverMir = null;\n\t        len--;\n\t        continue;\n\t      }\n\t\n\t      i++; // Use transform\n\t      // FIXME style and shape ?\n\t\n\t      if (!originalEl.invisible) {\n\t        el.transform = originalEl.transform;\n\t        el.invTransform = originalEl.invTransform;\n\t        el.__clipPaths = originalEl.__clipPaths; // el.\n\t\n\t        this._doPaintEl(el, hoverLayer, true, scope);\n\t      }\n\t    }\n\t\n\t    hoverLayer.ctx.restore();\n\t  },\n\t  _startProgessive: function () {\n\t    var self = this;\n\t\n\t    if (!self._furtherProgressive) {\n\t      return;\n\t    } // Use a token to stop progress steps triggered by\n\t    // previous zr.refresh calling.\n\t\n\t\n\t    var token = self._progressiveToken = +new Date();\n\t    self._progress++;\n\t    requestAnimationFrame(step);\n\t\n\t    function step() {\n\t      // In case refreshed or disposed\n\t      if (token === self._progressiveToken && self.storage) {\n\t        self._doPaintList(self.storage.getDisplayList());\n\t\n\t        if (self._furtherProgressive) {\n\t          self._progress++;\n\t          requestAnimationFrame(step);\n\t        } else {\n\t          self._progressiveToken = -1;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clearProgressive: function () {\n\t    this._progressiveToken = -1;\n\t    this._progress = 0;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      layer.__dirty && layer.clear();\n\t    });\n\t  },\n\t  _paintList: function (list, paintAll) {\n\t    if (paintAll == null) {\n\t      paintAll = false;\n\t    }\n\t\n\t    this._updateLayerStatus(list);\n\t\n\t    this._clearProgressive();\n\t\n\t    this.eachBuiltinLayer(preProcessLayer);\n\t\n\t    this._doPaintList(list, paintAll);\n\t\n\t    this.eachBuiltinLayer(postProcessLayer);\n\t  },\n\t  _doPaintList: function (list, paintAll) {\n\t    var currentLayer;\n\t    var currentZLevel;\n\t    var ctx; // var invTransform = [];\n\t\n\t    var scope;\n\t    var progressiveLayerIdx = 0;\n\t    var currentProgressiveLayer;\n\t    var width = this._width;\n\t    var height = this._height;\n\t    var layerProgress;\n\t    var frame = this._progress;\n\t\n\t    function flushProgressiveLayer(layer) {\n\t      var dpr = ctx.dpr || 1;\n\t      ctx.save();\n\t      ctx.globalAlpha = 1;\n\t      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\t\n\t      currentLayer.__dirty = true;\n\t      ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t      ctx.restore();\n\t    }\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var elFrame = el.__frame; // Flush at current context\n\t      // PENDING\n\t\n\t      if (elFrame < 0 && currentProgressiveLayer) {\n\t        flushProgressiveLayer(currentProgressiveLayer);\n\t        currentProgressiveLayer = null;\n\t      } // Change draw layer\n\t\n\t\n\t      if (currentZLevel !== elZLevel) {\n\t        if (ctx) {\n\t          ctx.restore();\n\t        } // Reset scope\n\t\n\t\n\t        scope = {}; // Only 0 zlevel if only has one canvas\n\t\n\t        currentZLevel = elZLevel;\n\t        currentLayer = this.getLayer(currentZLevel);\n\t\n\t        if (!currentLayer.__builtin__) {\n\t          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t        }\n\t\n\t        ctx = currentLayer.ctx;\n\t        ctx.save(); // Reset the count\n\t\n\t        currentLayer.__unusedCount = 0;\n\t\n\t        if (currentLayer.__dirty || paintAll) {\n\t          currentLayer.clear();\n\t        }\n\t      }\n\t\n\t      if (!(currentLayer.__dirty || paintAll)) {\n\t        continue;\n\t      }\n\t\n\t      if (elFrame >= 0) {\n\t        // Progressive layer changed\n\t        if (!currentProgressiveLayer) {\n\t          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t          currentProgressiveLayer.ctx.save();\n\t          currentProgressiveLayer.renderScope = {};\n\t\n\t          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t            // flushProgressiveLayer(currentProgressiveLayer);\n\t            // Quick jump all progressive elements\n\t            // All progressive element are not dirty, jump over and flush directly\n\t            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\t\n\t            continue;\n\t          }\n\t\n\t          layerProgress = currentProgressiveLayer.__progress;\n\t\n\t          if (!currentProgressiveLayer.__dirty) {\n\t            // Keep rendering\n\t            frame = layerProgress;\n\t          }\n\t\n\t          currentProgressiveLayer.__progress = frame + 1;\n\t        }\n\t\n\t        if (elFrame === frame) {\n\t          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t        }\n\t      } else {\n\t        this._doPaintEl(el, currentLayer, paintAll, scope);\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      flushProgressiveLayer(currentProgressiveLayer);\n\t    } // Restore the lastLayer ctx\n\t\n\t\n\t    ctx && ctx.restore(); // If still has clipping state\n\t    // if (scope.prevElClipPaths) {\n\t    //     ctx.restore();\n\t    // }\n\t\n\t    this._furtherProgressive = false;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      if (layer.__maxProgress >= layer.__progress) {\n\t        this._furtherProgressive = true;\n\t      }\n\t    }, this);\n\t  },\n\t  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t    var ctx = currentLayer.ctx;\n\t    var m = el.transform;\n\t\n\t    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n\t    !el.invisible // Ignore transparent element\n\t    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n\t    // Draw a scale 0 element can cause all following draw wrong\n\t    // And setTransform with scale 0 will cause set back transform failed.\n\t    && !(m && !m[0] && !m[3]) // Ignore culled element\n\t    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\t\n\t      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t        // If has previous clipping state, restore from it\n\t        if (scope.prevElClipPaths) {\n\t          scope.prevClipLayer.ctx.restore();\n\t          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\t\n\t          scope.prevEl = null;\n\t        } // New clipping state\n\t\n\t\n\t        if (clipPaths) {\n\t          ctx.save();\n\t          doClip(clipPaths, ctx);\n\t          scope.prevClipLayer = currentLayer;\n\t          scope.prevElClipPaths = clipPaths;\n\t        }\n\t      }\n\t\n\t      el.beforeBrush && el.beforeBrush(ctx);\n\t      el.brush(ctx, scope.prevEl || null);\n\t      scope.prevEl = el;\n\t      el.afterBrush && el.afterBrush(ctx);\n\t    }\n\t  },\n\t\n\t  /**\n\t   *  zlevel \n\t   * @param {number} zlevel\n\t   * @return {module:zrender/Layer}\n\t   */\n\t  getLayer: function (zlevel) {\n\t    if (this._singleCanvas) {\n\t      return this._layers[0];\n\t    }\n\t\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (!layer) {\n\t      // Create a new layer\n\t      layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t      layer.__builtin__ = true;\n\t\n\t      if (this._layerConfig[zlevel]) {\n\t        util.merge(layer, this._layerConfig[zlevel], true);\n\t      }\n\t\n\t      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n\t      // Or excanvas will get 0px clientWidth and clientHeight\n\t\n\t      layer.initContext();\n\t    }\n\t\n\t    return layer;\n\t  },\n\t  insertLayer: function (zlevel, layer) {\n\t    var layersMap = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var len = zlevelList.length;\n\t    var prevLayer = null;\n\t    var i = -1;\n\t    var domRoot = this._domRoot;\n\t\n\t    if (layersMap[zlevel]) {\n\t      log('ZLevel ' + zlevel + ' has been used already');\n\t      return;\n\t    } // Check if is a valid layer\n\t\n\t\n\t    if (!isLayerValid(layer)) {\n\t      log('Layer of zlevel ' + zlevel + ' is not valid');\n\t      return;\n\t    }\n\t\n\t    if (len > 0 && zlevel > zlevelList[0]) {\n\t      for (i = 0; i < len - 1; i++) {\n\t        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      prevLayer = layersMap[zlevelList[i]];\n\t    }\n\t\n\t    zlevelList.splice(i + 1, 0, zlevel);\n\t    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n\t    // (It can be a WebGL layer and assigned to a ZImage element)\n\t    // But it still under management of zrender.\n\t\n\t    if (!layer.virtual) {\n\t      if (prevLayer) {\n\t        var prevDom = prevLayer.dom;\n\t\n\t        if (prevDom.nextSibling) {\n\t          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      } else {\n\t        if (domRoot.firstChild) {\n\t          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  // Iterate each layer\n\t  eachLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      cb.call(context, this._layers[z], z);\n\t    }\n\t  },\n\t  // Iterate each buildin layer\n\t  eachBuiltinLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t  // Iterate each other layer except buildin layer\n\t  eachOtherLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t   */\n\t  getLayers: function () {\n\t    return this._layers;\n\t  },\n\t  _updateLayerStatus: function (list) {\n\t    var layers = this._layers;\n\t    var progressiveLayers = this._progressiveLayers;\n\t    var elCountsLastFrame = {};\n\t    var progressiveElCountsLastFrame = {};\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      elCountsLastFrame[z] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      progressiveElCountsLastFrame[idx] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    var progressiveLayerCount = 0;\n\t    var currentProgressiveLayer;\n\t    var lastProgressiveKey;\n\t    var frameCount = 0;\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var layer = layers[zlevel];\n\t      var elProgress = el.progressive;\n\t\n\t      if (layer) {\n\t        layer.elCount++;\n\t        layer.__dirty = layer.__dirty || el.__dirty;\n\t      } /////// Update progressive\n\t\n\t\n\t      if (elProgress >= 0) {\n\t        // Fix wrong progressive sequence problem.\n\t        if (lastProgressiveKey !== elProgress) {\n\t          lastProgressiveKey = elProgress;\n\t          frameCount++;\n\t        }\n\t\n\t        var elFrame = el.__frame = frameCount - 1;\n\t\n\t        if (!currentProgressiveLayer) {\n\t          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t          currentProgressiveLayer = progressiveLayers[idx];\n\t\n\t          if (!currentProgressiveLayer) {\n\t            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t            currentProgressiveLayer.initContext();\n\t          }\n\t\n\t          currentProgressiveLayer.__maxProgress = 0;\n\t        }\n\t\n\t        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t        currentProgressiveLayer.elCount++;\n\t        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t\n\t        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t          // Should keep rendering this  layer because progressive rendering is not finished yet\n\t          layer.__dirty = true;\n\t        }\n\t      } else {\n\t        el.__frame = -1;\n\t\n\t        if (currentProgressiveLayer) {\n\t          currentProgressiveLayer.__nextIdxNotProg = i;\n\t          progressiveLayerCount++;\n\t          currentProgressiveLayer = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      progressiveLayerCount++;\n\t      currentProgressiveLayer.__nextIdxNotProg = i;\n\t    } // \n\t\n\t\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      if (elCountsLastFrame[z] !== layer.elCount) {\n\t        layer.__dirty = true;\n\t      }\n\t    });\n\t    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t        el.__dirty = true;\n\t      }\n\t\n\t      if (layer.__dirty) {\n\t        layer.__progress = 0;\n\t      }\n\t    });\n\t  },\n\t\n\t  /**\n\t   * hover\n\t   */\n\t  clear: function () {\n\t    this.eachBuiltinLayer(this._clearLayer);\n\t    return this;\n\t  },\n\t  _clearLayer: function (layer) {\n\t    layer.clear();\n\t  },\n\t\n\t  /**\n\t   * zlevel\n\t   *\n\t   * @param {string} zlevel\n\t   * @param {Object} config \n\t   * @param {string} [config.clearColor=0] \n\t   * @param {string} [config.motionBlur=false] \n\t   * @param {number} [config.lastFrameAlpha=0.7]\n\t   *                 alpha\n\t   */\n\t  configLayer: function (zlevel, config) {\n\t    if (config) {\n\t      var layerConfig = this._layerConfig;\n\t\n\t      if (!layerConfig[zlevel]) {\n\t        layerConfig[zlevel] = config;\n\t      } else {\n\t        util.merge(layerConfig[zlevel], config, true);\n\t      }\n\t\n\t      var layer = this._layers[zlevel];\n\t\n\t      if (layer) {\n\t        util.merge(layer, layerConfig[zlevel], true);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {number} zlevel zlevel\n\t   */\n\t  delLayer: function (zlevel) {\n\t    var layers = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var layer = layers[zlevel];\n\t\n\t    if (!layer) {\n\t      return;\n\t    }\n\t\n\t    layer.dom.parentNode.removeChild(layer.dom);\n\t    delete layers[zlevel];\n\t    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  resize: function (width, height) {\n\t    var domRoot = this._domRoot; // FIXME Why ?\n\t\n\t    domRoot.style.display = 'none'; // Save input w/h\n\t\n\t    var opts = this._opts;\n\t    width != null && (opts.width = width);\n\t    height != null && (opts.height = height);\n\t    width = this._getSize(0);\n\t    height = this._getSize(1);\n\t    domRoot.style.display = ''; // resize\n\t\n\t    if (this._width != width || height != this._height) {\n\t      domRoot.style.width = width + 'px';\n\t      domRoot.style.height = height + 'px';\n\t\n\t      for (var id in this._layers) {\n\t        if (this._layers.hasOwnProperty(id)) {\n\t          this._layers[id].resize(width, height);\n\t        }\n\t      }\n\t\n\t      util.each(this._progressiveLayers, function (layer) {\n\t        layer.resize(width, height);\n\t      });\n\t      this.refresh(true);\n\t    }\n\t\n\t    this._width = width;\n\t    this._height = height;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {number} zlevel\n\t   */\n\t  clearLayer: function (zlevel) {\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (layer) {\n\t      layer.clear();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this.root = this.storage = this._domRoot = this._layers = null;\n\t  },\n\t\n\t  /**\n\t   * Get canvas which has all thing rendered\n\t   * @param {Object} opts\n\t   * @param {string} [opts.backgroundColor]\n\t   * @param {number} [opts.pixelRatio]\n\t   */\n\t  getRenderedCanvas: function (opts) {\n\t    opts = opts || {};\n\t\n\t    if (this._singleCanvas) {\n\t      return this._layers[0].dom;\n\t    }\n\t\n\t    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t    imageLayer.initContext();\n\t    imageLayer.clearColor = opts.backgroundColor;\n\t    imageLayer.clear();\n\t    var displayList = this.storage.getDisplayList(true);\n\t    var scope = {};\n\t    var zlevel;\n\t    var self = this;\n\t\n\t    function findAndDrawOtherLayer(smaller, larger) {\n\t      var zlevelList = self._zlevelList;\n\t\n\t      if (smaller == null) {\n\t        smaller = -Infinity;\n\t      }\n\t\n\t      var intermediateLayer;\n\t\n\t      for (var i = 0; i < zlevelList.length; i++) {\n\t        var z = zlevelList[i];\n\t        var layer = self._layers[z];\n\t\n\t        if (!layer.__builtin__ && z > smaller && z < larger) {\n\t          intermediateLayer = layer;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n\t        imageLayer.ctx.save();\n\t        intermediateLayer.renderToCanvas(imageLayer.ctx);\n\t        imageLayer.ctx.restore();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < displayList.length; i++) {\n\t      var el = displayList[i];\n\t\n\t      if (el.zlevel !== zlevel) {\n\t        findAndDrawOtherLayer(zlevel, el.zlevel);\n\t        zlevel = el.zlevel;\n\t      }\n\t\n\t      this._doPaintEl(el, imageLayer, true, scope);\n\t    }\n\t\n\t    findAndDrawOtherLayer(zlevel, Infinity);\n\t    return imageLayer.dom;\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  _getSize: function (whIdx) {\n\t    var opts = this._opts;\n\t    var wh = ['width', 'height'][whIdx];\n\t    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t    if (opts[wh] != null && opts[wh] !== 'auto') {\n\t      return parseFloat(opts[wh]);\n\t    }\n\t\n\t    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\t\n\t    var stl = document.defaultView.getComputedStyle(root);\n\t    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n\t  },\n\t  pathToImage: function (path, dpr) {\n\t    dpr = dpr || this.dpr;\n\t    var canvas = document.createElement('canvas');\n\t    var ctx = canvas.getContext('2d');\n\t    var rect = path.getBoundingRect();\n\t    var style = path.style;\n\t    var shadowBlurSize = style.shadowBlur;\n\t    var shadowOffsetX = style.shadowOffsetX;\n\t    var shadowOffsetY = style.shadowOffsetY;\n\t    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t    var width = rect.width + leftMargin + rightMargin;\n\t    var height = rect.height + topMargin + bottomMargin;\n\t    canvas.width = width * dpr;\n\t    canvas.height = height * dpr;\n\t    ctx.scale(dpr, dpr);\n\t    ctx.clearRect(0, 0, width, height);\n\t    ctx.dpr = dpr;\n\t    var pathTransform = {\n\t      position: path.position,\n\t      rotation: path.rotation,\n\t      scale: path.scale\n\t    };\n\t    path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t    path.rotation = 0;\n\t    path.scale = [1, 1];\n\t    path.updateTransform();\n\t\n\t    if (path) {\n\t      path.brush(ctx);\n\t    }\n\t\n\t    var ImageShape = Image;\n\t    var imgShape = new ImageShape({\n\t      style: {\n\t        x: 0,\n\t        y: 0,\n\t        image: canvas\n\t      }\n\t    });\n\t\n\t    if (pathTransform.position != null) {\n\t      imgShape.position = path.position = pathTransform.position;\n\t    }\n\t\n\t    if (pathTransform.rotation != null) {\n\t      imgShape.rotation = path.rotation = pathTransform.rotation;\n\t    }\n\t\n\t    if (pathTransform.scale != null) {\n\t      imgShape.scale = path.scale = pathTransform.scale;\n\t    }\n\t\n\t    return imgShape;\n\t  }\n\t};\n\tvar _default = Painter;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar Pattern = __webpack_require__(29);\n\t\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\t/**\n\t * dom\n\t *\n\t * @inner\n\t * @param {string} id dom id \n\t * @param {Painter} painter painter instance\n\t * @param {number} number\n\t */\n\t\n\t\n\tfunction createDom(id, painter, dpr) {\n\t  var newDom = util.createCanvas();\n\t  var width = painter.getWidth();\n\t  var height = painter.getHeight();\n\t  var newDomStyle = newDom.style; // append~\n\t\n\t  newDomStyle.position = 'absolute';\n\t  newDomStyle.left = 0;\n\t  newDomStyle.top = 0;\n\t  newDomStyle.width = width + 'px';\n\t  newDomStyle.height = height + 'px';\n\t  newDom.width = width * dpr;\n\t  newDom.height = height * dpr; // id\n\t\n\t  newDom.setAttribute('data-zr-dom-id', id);\n\t  return newDom;\n\t}\n\t/**\n\t * @alias module:zrender/Layer\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @param {string} id\n\t * @param {module:zrender/Painter} painter\n\t * @param {number} [dpr]\n\t */\n\t\n\t\n\tvar Layer = function (id, painter, dpr) {\n\t  var dom;\n\t  dpr = dpr || devicePixelRatio;\n\t\n\t  if (typeof id === 'string') {\n\t    dom = createDom(id, painter, dpr);\n\t  } // Not using isDom because in node it will return false\n\t  else if (util.isObject(id)) {\n\t      dom = id;\n\t      id = dom.id;\n\t    }\n\t\n\t  this.id = id;\n\t  this.dom = dom;\n\t  var domStyle = dom.style;\n\t\n\t  if (domStyle) {\n\t    // Not in node\n\t    dom.onselectstart = returnFalse; // \n\t\n\t    domStyle['-webkit-user-select'] = 'none';\n\t    domStyle['user-select'] = 'none';\n\t    domStyle['-webkit-touch-callout'] = 'none';\n\t    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t    domStyle['padding'] = 0;\n\t    domStyle['margin'] = 0;\n\t    domStyle['border-width'] = 0;\n\t  }\n\t\n\t  this.domBack = null;\n\t  this.ctxBack = null;\n\t  this.painter = painter;\n\t  this.config = null; // Configs\n\t\n\t  /**\n\t   * \n\t   * @type {string}\n\t   * @default 0\n\t   */\n\t\n\t  this.clearColor = 0;\n\t  /**\n\t   * \n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t\n\t  this.motionBlur = false;\n\t  /**\n\t   * alpha\n\t   * @type {number}\n\t   * @default 0.7\n\t   */\n\t\n\t  this.lastFrameAlpha = 0.7;\n\t  /**\n\t   * Layer dpr\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = dpr;\n\t};\n\t\n\tLayer.prototype = {\n\t  constructor: Layer,\n\t  elCount: 0,\n\t  __dirty: true,\n\t  initContext: function () {\n\t    this.ctx = this.dom.getContext('2d');\n\t    this.ctx.__currentValues = {};\n\t    this.ctx.dpr = this.dpr;\n\t  },\n\t  createBackBuffer: function () {\n\t    var dpr = this.dpr;\n\t    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n\t    this.ctxBack = this.domBack.getContext('2d');\n\t    this.ctxBack.__currentValues = {};\n\t\n\t    if (dpr != 1) {\n\t      this.ctxBack.scale(dpr, dpr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param  {number} width\n\t   * @param  {number} height\n\t   */\n\t  resize: function (width, height) {\n\t    var dpr = this.dpr;\n\t    var dom = this.dom;\n\t    var domStyle = dom.style;\n\t    var domBack = this.domBack;\n\t    domStyle.width = width + 'px';\n\t    domStyle.height = height + 'px';\n\t    dom.width = width * dpr;\n\t    dom.height = height * dpr;\n\t\n\t    if (domBack) {\n\t      domBack.width = width * dpr;\n\t      domBack.height = height * dpr;\n\t\n\t      if (dpr != 1) {\n\t        this.ctxBack.scale(dpr, dpr);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {boolean} clearAll Clear all with out motion blur\n\t   */\n\t  clear: function (clearAll) {\n\t    var dom = this.dom;\n\t    var ctx = this.ctx;\n\t    var width = dom.width;\n\t    var height = dom.height;\n\t    var clearColor = this.clearColor;\n\t    var haveMotionBLur = this.motionBlur && !clearAll;\n\t    var lastFrameAlpha = this.lastFrameAlpha;\n\t    var dpr = this.dpr;\n\t\n\t    if (haveMotionBLur) {\n\t      if (!this.domBack) {\n\t        this.createBackBuffer();\n\t      }\n\t\n\t      this.ctxBack.globalCompositeOperation = 'copy';\n\t      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t    }\n\t\n\t    ctx.clearRect(0, 0, width, height);\n\t\n\t    if (clearColor) {\n\t      var clearColorGradientOrPattern; // Gradient\n\t\n\t      if (clearColor.colorStops) {\n\t        // Cache canvas gradient\n\t        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t          x: 0,\n\t          y: 0,\n\t          width: width,\n\t          height: height\n\t        });\n\t        clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t      } // Pattern\n\t      else if (clearColor.image) {\n\t          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t        }\n\t\n\t      ctx.save();\n\t      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t      ctx.fillRect(0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t\n\t    if (haveMotionBLur) {\n\t      var domBack = this.domBack;\n\t      ctx.save();\n\t      ctx.globalAlpha = lastFrameAlpha;\n\t      ctx.drawImage(domBack, 0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t  }\n\t};\n\tvar _default = Layer;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\tvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\tvar Style = function (opts, host) {\n\t  this.extendFrom(opts, false);\n\t  this.host = host;\n\t};\n\t\n\tfunction createLinearGradient(ctx, obj, rect) {\n\t  var x = obj.x == null ? 0 : obj.x;\n\t  var x2 = obj.x2 == null ? 1 : obj.x2;\n\t  var y = obj.y == null ? 0 : obj.y;\n\t  var y2 = obj.y2 == null ? 0 : obj.y2;\n\t\n\t  if (!obj.global) {\n\t    x = x * rect.width + rect.x;\n\t    x2 = x2 * rect.width + rect.x;\n\t    y = y * rect.height + rect.y;\n\t    y2 = y2 * rect.height + rect.y;\n\t  }\n\t\n\t  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t  return canvasGradient;\n\t}\n\t\n\tfunction createRadialGradient(ctx, obj, rect) {\n\t  var width = rect.width;\n\t  var height = rect.height;\n\t  var min = Math.min(width, height);\n\t  var x = obj.x == null ? 0.5 : obj.x;\n\t  var y = obj.y == null ? 0.5 : obj.y;\n\t  var r = obj.r == null ? 0.5 : obj.r;\n\t\n\t  if (!obj.global) {\n\t    x = x * width + rect.x;\n\t    y = y * height + rect.y;\n\t    r = r * min;\n\t  }\n\t\n\t  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t  return canvasGradient;\n\t}\n\t\n\tStyle.prototype = {\n\t  constructor: Style,\n\t\n\t  /**\n\t   * @type {module:zrender/graphic/Displayable}\n\t   */\n\t  host: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  fill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  stroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  opacity: 1,\n\t\n\t  /**\n\t   * @type {Array.<number>}\n\t   */\n\t  lineDash: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineDashOffset: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineWidth: 1,\n\t\n\t  /**\n\t   * If stroke ignore scale\n\t   * @type {Boolean}\n\t   */\n\t  strokeNoScale: false,\n\t  // Bounding rect text configuration\n\t  // Not affected by element transform\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  text: null,\n\t\n\t  /**\n\t   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n\t   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n\t   * So do not visit it directly in upper application (like echarts),\n\t   * but use `contain/text#makeFont` instead.\n\t   * @type {string}\n\t   */\n\t  font: null,\n\t\n\t  /**\n\t   * The same as font. Use font please.\n\t   * @deprecated\n\t   * @type {string}\n\t   */\n\t  textFont: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontStyle: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontWeight: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * Should be 12 but not '12px'.\n\t   * @type {number}\n\t   */\n\t  fontSize: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontFamily: null,\n\t\n\t  /**\n\t   * Reserved for special functinality, like 'hr'.\n\t   * @type {string}\n\t   */\n\t  textTag: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textFill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textStroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textWidth: null,\n\t\n\t  /**\n\t   * Only for textBackground.\n\t   * @type {number}\n\t   */\n\t  textHeight: null,\n\t\n\t  /**\n\t   * textStroke may be set as some color as a default\n\t   * value in upper applicaion, where the default value\n\t   * of textStrokeWidth should be 0 to make sure that\n\t   * user can choose to do not use text stroke.\n\t   * @type {number}\n\t   */\n\t  textStrokeWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textLineHeight: null,\n\t\n\t  /**\n\t   * 'inside', 'left', 'right', 'top', 'bottom'\n\t   * [x, y]\n\t   * Based on x, y of rect.\n\t   * @type {string|Array.<number>}\n\t   * @default 'inside'\n\t   */\n\t  textPosition: 'inside',\n\t\n\t  /**\n\t   * If not specified, use the boundingRect of a `displayable`.\n\t   * @type {Object}\n\t   */\n\t  textRect: null,\n\t\n\t  /**\n\t   * [x, y]\n\t   * @type {Array.<number>}\n\t   */\n\t  textOffset: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textAlign: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textVerticalAlign: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textDistance: 5,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBoxShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetY: 0,\n\t\n\t  /**\n\t   * Whether transform text.\n\t   * Only useful in Path and Image element\n\t   * @type {boolean}\n\t   */\n\t  transformText: false,\n\t\n\t  /**\n\t   * Text rotate around position of Path or Image\n\t   * Only useful in Path and Image element and transformText is false.\n\t   */\n\t  textRotation: 0,\n\t\n\t  /**\n\t   * Text origin of text rotation, like [10, 40].\n\t   * Based on x, y of rect.\n\t   * Useful in label rotation of circular symbol.\n\t   * By default, this origin is textPosition.\n\t   * Can be 'center'.\n\t   * @type {string|Array.<number>}\n\t   */\n\t  textOrigin: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBackgroundColor: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBorderColor: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderRadius: 0,\n\t\n\t  /**\n\t   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n\t   * @type {number|Array.<number>}\n\t   */\n\t  textPadding: null,\n\t\n\t  /**\n\t   * Text styles for rich text.\n\t   * @type {Object}\n\t   */\n\t  rich: null,\n\t\n\t  /**\n\t   * {outerWidth, outerHeight, ellipsis, placeholder}\n\t   * @type {Object}\n\t   */\n\t  truncate: null,\n\t\n\t  /**\n\t   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t   * @type {string}\n\t   */\n\t  blend: null,\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  bind: function (ctx, el, prevEl) {\n\t    var style = this;\n\t    var prevStyle = prevEl && prevEl.style;\n\t    var firstDraw = !prevStyle;\n\t\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t      var prop = STYLE_COMMON_PROPS[i];\n\t      var styleName = prop[0];\n\t\n\t      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t        // FIXME Invalid property value will cause style leak from previous element.\n\t        ctx[styleName] = style[styleName] || prop[1];\n\t      }\n\t    }\n\t\n\t    if (firstDraw || style.fill !== prevStyle.fill) {\n\t      ctx.fillStyle = style.fill;\n\t    }\n\t\n\t    if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t      ctx.strokeStyle = style.stroke;\n\t    }\n\t\n\t    if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t    }\n\t\n\t    if (firstDraw || style.blend !== prevStyle.blend) {\n\t      ctx.globalCompositeOperation = style.blend || 'source-over';\n\t    }\n\t\n\t    if (this.hasStroke()) {\n\t      var lineWidth = style.lineWidth;\n\t      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t    }\n\t  },\n\t  hasFill: function () {\n\t    var fill = this.fill;\n\t    return fill != null && fill !== 'none';\n\t  },\n\t  hasStroke: function () {\n\t    var stroke = this.stroke;\n\t    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t  },\n\t\n\t  /**\n\t   * Extend from other style\n\t   * @param {zrender/graphic/Style} otherStyle\n\t   * @param {boolean} overwrite true: overwrirte any way.\n\t   *                            false: overwrite only when !target.hasOwnProperty\n\t   *                            others: overwrite when property is not null/undefined.\n\t   */\n\t  extendFrom: function (otherStyle, overwrite) {\n\t    if (otherStyle) {\n\t      for (var name in otherStyle) {\n\t        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n\t          this[name] = otherStyle[name];\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Batch setting style with a given object\n\t   * @param {Object|string} obj\n\t   * @param {*} [obj]\n\t   */\n\t  set: function (obj, value) {\n\t    if (typeof obj === 'string') {\n\t      this[obj] = value;\n\t    } else {\n\t      this.extendFrom(obj, true);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clone\n\t   * @return {zrender/graphic/Style} [description]\n\t   */\n\t  clone: function () {\n\t    var newStyle = new this.constructor();\n\t    newStyle.extendFrom(this, true);\n\t    return newStyle;\n\t  },\n\t  getGradient: function (ctx, obj, rect) {\n\t    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t    var canvasGradient = method(ctx, obj, rect);\n\t    var colorStops = obj.colorStops;\n\t\n\t    for (var i = 0; i < colorStops.length; i++) {\n\t      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t    }\n\t\n\t    return canvasGradient;\n\t  }\n\t};\n\tvar styleProto = Style.prototype;\n\t\n\tfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t  var prop = STYLE_COMMON_PROPS[i];\n\t\n\t  if (!(prop[0] in styleProto)) {\n\t    styleProto[prop[0]] = prop[1];\n\t  }\n\t} // Provide for others\n\t\n\t\n\tStyle.getGradient = styleProto.getGradient;\n\tvar _default = Style;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tvar Pattern = function (image, repeat) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {image: ...}`, where this constructor will not be called.\n\t  this.image = image;\n\t  this.repeat = repeat; // Can be cloned\n\t\n\t  this.type = 'pattern';\n\t};\n\t\n\tPattern.prototype.getCanvasPattern = function (ctx) {\n\t  return ctx.createPattern(this.image, this.repeat || 'repeat');\n\t};\n\t\n\tvar _default = Pattern;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n\tvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n\twindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t  setTimeout(func, 16);\n\t};\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\t/**\n\t * @alias zrender/graphic/Image\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tfunction ZImage(opts) {\n\t  Displayable.call(this, opts);\n\t}\n\t\n\tZImage.prototype = {\n\t  constructor: ZImage,\n\t  type: 'image',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var src = style.image; // Must bind each time\n\t\n\t    style.bind(ctx, this, prevEl);\n\t    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\t\n\t    if (!image || !imageHelper.isImageReady(image)) {\n\t      return;\n\t    } // \n\t    // if (image.nodeName.toUpperCase() == 'IMG') {\n\t    //     if (!image.complete) {\n\t    //         return;\n\t    //     }\n\t    // }\n\t    // Else is canvas\n\t\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var width = style.width;\n\t    var height = style.height;\n\t    var aspect = image.width / image.height;\n\t\n\t    if (width == null && height != null) {\n\t      // Keep image/height ratio\n\t      width = height * aspect;\n\t    } else if (height == null && width != null) {\n\t      height = width / aspect;\n\t    } else if (width == null && height == null) {\n\t      width = image.width;\n\t      height = image.height;\n\t    } // transform\n\t\n\t\n\t    this.setTransform(ctx);\n\t\n\t    if (style.sWidth && style.sHeight) {\n\t      var sx = style.sx || 0;\n\t      var sy = style.sy || 0;\n\t      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t    } else if (style.sx && style.sy) {\n\t      var sx = style.sx;\n\t      var sy = style.sy;\n\t      var sWidth = width - sx;\n\t      var sHeight = height - sy;\n\t      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t    } else {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style;\n\t\n\t    if (!this._rect) {\n\t      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(ZImage, Displayable);\n\tvar _default = ZImage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar Element = __webpack_require__(13);\n\t\n\tvar RectText = __webpack_require__(33);\n\t\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Displayable\n\t * @extends module:zrender/Element\n\t * @extends module:zrender/graphic/mixin/RectText\n\t */\n\tfunction Displayable(opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts); // Extend properties\n\t\n\t  for (var name in opts) {\n\t    if (opts.hasOwnProperty(name) && name !== 'style') {\n\t      this[name] = opts[name];\n\t    }\n\t  }\n\t  /**\n\t   * @type {module:zrender/graphic/Style}\n\t   */\n\t\n\t\n\t  this.style = new Style(opts.style, this);\n\t  this._rect = null; // Shapes for cascade clipping.\n\t\n\t  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n\t  // Stateful.call(this, opts);\n\t}\n\t\n\tDisplayable.prototype = {\n\t  constructor: Displayable,\n\t  type: 'displayable',\n\t\n\t  /**\n\t   * Displayable Painter \n\t   * Dirty flag. From which painter will determine if this displayable object needs brush\n\t   * @name module:zrender/graphic/Displayable#__dirty\n\t   * @type {boolean}\n\t   */\n\t  __dirty: true,\n\t\n\t  /**\n\t   * true\n\t   * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t   * @name module:/zrender/graphic/Displayable#invisible\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  invisible: false,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z: 0,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z2: 0,\n\t\n\t  /**\n\t   * zlevelcanvas\n\t   * @name module:/zrender/graphic/Displayable#zlevel\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  zlevel: 0,\n\t\n\t  /**\n\t   * \n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  draggable: false,\n\t\n\t  /**\n\t   * \n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  dragging: false,\n\t\n\t  /**\n\t   * \n\t   * @name module:/zrender/graphic/Displayable#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * If enable culling\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  culling: false,\n\t\n\t  /**\n\t   * Mouse cursor when hovered\n\t   * @name module:/zrender/graphic/Displayable#cursor\n\t   * @type {string}\n\t   */\n\t  cursor: 'pointer',\n\t\n\t  /**\n\t   * If hover area is bounding rect\n\t   * @name module:/zrender/graphic/Displayable#rectHover\n\t   * @type {string}\n\t   */\n\t  rectHover: false,\n\t\n\t  /**\n\t   * Render the element progressively when the value >= 0,\n\t   * usefull for large data.\n\t   * @type {number}\n\t   */\n\t  progressive: -1,\n\t  beforeBrush: function (ctx) {},\n\t  afterBrush: function (ctx) {},\n\t\n\t  /**\n\t   * \n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  // Interface\n\t  brush: function (ctx, prevEl) {},\n\t\n\t  /**\n\t   * \n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  // Interface\n\t  getBoundingRect: function () {},\n\t\n\t  /**\n\t   *  x, y \n\t   * If displayable element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  contain: function (x, y) {\n\t    return this.rectContain(x, y);\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    cb.call(context, this);\n\t  },\n\t\n\t  /**\n\t   *  x, y \n\t   * If bounding rect of element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  rectContain: function (x, y) {\n\t    var coord = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    return rect.contain(coord[0], coord[1]);\n\t  },\n\t\n\t  /**\n\t   * \n\t   * Mark displayable element dirty and refresh next frame\n\t   */\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this._rect = null;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * \n\t   * If displayable object binded any event\n\t   * @return {boolean}\n\t   */\n\t  // TODO,  bind \n\t  // isSilent: function () {\n\t  //     return !(\n\t  //         this.hoverable || this.draggable\n\t  //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t  //         || this.onmousedown || this.onmouseup || this.onclick\n\t  //         || this.ondragenter || this.ondragover || this.ondragleave\n\t  //         || this.ondrop\n\t  //     );\n\t  // },\n\t\n\t  /**\n\t   * Alias for animate('style')\n\t   * @param {boolean} loop\n\t   */\n\t  animateStyle: function (loop) {\n\t    return this.animate('style', loop);\n\t  },\n\t  attrKV: function (key, value) {\n\t    if (key !== 'style') {\n\t      Element.prototype.attrKV.call(this, key, value);\n\t    } else {\n\t      this.style.set(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setStyle: function (key, value) {\n\t    this.style.set(key, value);\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Use given style object\n\t   * @param  {Object} obj\n\t   */\n\t  useStyle: function (obj) {\n\t    this.style = new Style(obj, this);\n\t    this.dirty(false);\n\t    return this;\n\t  }\n\t};\n\tzrUtil.inherits(Displayable, Element);\n\tzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\t\n\tvar _default = Displayable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar textHelper = __webpack_require__(34);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\tvar tmpRect = new BoundingRect();\n\t\n\tvar RectText = function () {};\n\t\n\tRectText.prototype = {\n\t  constructor: RectText,\n\t\n\t  /**\n\t   * Draw text in a rect with specified position.\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @param  {Object} rect Displayable rect\n\t   */\n\t  drawRectText: function (ctx, rect) {\n\t    var style = this.style;\n\t    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    } // FIXME\n\t\n\t\n\t    ctx.save(); // Transform rect to view space\n\t\n\t    var transform = this.transform;\n\t\n\t    if (!style.transformText) {\n\t      if (transform) {\n\t        tmpRect.copy(rect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = tmpRect;\n\t      }\n\t    } else {\n\t      this.setTransform(ctx);\n\t    } // transformText and textRotation can not be used at the same time.\n\t\n\t\n\t    textHelper.renderText(this, ctx, text, style, rect);\n\t    ctx.restore();\n\t  }\n\t};\n\tvar _default = RectText;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(6);\n\t\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar each = _util.each;\n\tvar normalizeCssArray = _util.normalizeCssArray;\n\tvar isString = _util.isString;\n\tvar isObject = _util.isObject;\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar roundRectHelper = __webpack_require__(37);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\t// TODO: Have not support 'start', 'end' yet.\n\tvar VALID_TEXT_ALIGN = {\n\t  left: 1,\n\t  right: 1,\n\t  center: 1\n\t};\n\tvar VALID_TEXT_VERTICAL_ALIGN = {\n\t  top: 1,\n\t  bottom: 1,\n\t  middle: 1\n\t};\n\t/**\n\t * @param {module:zrender/graphic/Style} style\n\t * @return {module:zrender/graphic/Style} The input style.\n\t */\n\t\n\tfunction normalizeTextStyle(style) {\n\t  normalizeStyle(style);\n\t  each(style.rich, normalizeStyle);\n\t  return style;\n\t}\n\t\n\tfunction normalizeStyle(style) {\n\t  if (style) {\n\t    style.font = textContain.makeFont(style);\n\t    var textAlign = style.textAlign;\n\t    textAlign === 'middle' && (textAlign = 'center');\n\t    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\t\n\t    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n\t    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n\t    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n\t    var textPadding = style.textPadding;\n\t\n\t    if (textPadding) {\n\t      style.textPadding = normalizeCssArray(style.textPadding);\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {string} text\n\t * @param {module:zrender/graphic/Style} style\n\t * @param {Object|boolean} [rect] {x, y, width, height}\n\t *                  If set false, rect text is not used.\n\t */\n\t\n\t\n\tfunction renderText(hostEl, ctx, text, style, rect) {\n\t  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n\t}\n\t\n\tfunction renderPlainText(hostEl, ctx, text, style, rect) {\n\t  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\t  var textPadding = style.textPadding;\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textLines = contentBlock.lines;\n\t  var lineHeight = contentBlock.lineHeight;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var textX = baseX;\n\t  var textY = boxY;\n\t  var needDrawBg = needDrawBackground(style);\n\t\n\t  if (needDrawBg || textPadding) {\n\t    // Consider performance, do not call getTextWidth util necessary.\n\t    var textWidth = textContain.getWidth(text, font);\n\t    var outerWidth = textWidth;\n\t    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n\t    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t    if (textPadding) {\n\t      textX = getTextXForPadding(baseX, textAlign, textPadding);\n\t      textY += textPadding[0];\n\t    }\n\t  }\n\t\n\t  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\t\n\t  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\t\n\t  textY += lineHeight / 2;\n\t  var textStrokeWidth = style.textStrokeWidth;\n\t  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(style.textFill);\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t  }\n\t\n\t  for (var i = 0; i < textLines.length; i++) {\n\t    // Fill after stroke so the outline will not cover the main part.\n\t    textStroke && ctx.strokeText(textLines[i], textX, textY);\n\t    textFill && ctx.fillText(textLines[i], textX, textY);\n\t    textY += lineHeight;\n\t  }\n\t}\n\t\n\tfunction renderRichText(hostEl, ctx, text, style, rect) {\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n\t  }\n\t\n\t  drawRichText(hostEl, ctx, contentBlock, style, rect);\n\t}\n\t\n\tfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n\t  var contentWidth = contentBlock.width;\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textPadding = style.textPadding;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var xLeft = boxX;\n\t  var lineTop = boxY;\n\t\n\t  if (textPadding) {\n\t    xLeft += textPadding[3];\n\t    lineTop += textPadding[0];\n\t  }\n\t\n\t  var xRight = xLeft + contentWidth;\n\t  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t  for (var i = 0; i < contentBlock.lines.length; i++) {\n\t    var line = contentBlock.lines[i];\n\t    var tokens = line.tokens;\n\t    var tokenCount = tokens.length;\n\t    var lineHeight = line.lineHeight;\n\t    var usedWidth = line.width;\n\t    var leftIndex = 0;\n\t    var lineXLeft = xLeft;\n\t    var lineXRight = xRight;\n\t    var rightIndex = tokenCount - 1;\n\t    var token;\n\t\n\t    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n\t      usedWidth -= token.width;\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n\t      usedWidth -= token.width;\n\t      lineXRight -= token.width;\n\t      rightIndex--;\n\t    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\t\n\t\n\t    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\t\n\t    while (leftIndex <= rightIndex) {\n\t      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\t\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    lineTop += lineHeight;\n\t  }\n\t}\n\t\n\tfunction applyTextRotation(ctx, style, rect, x, y) {\n\t  // textRotation only apply in RectText.\n\t  if (rect && style.textRotation) {\n\t    var origin = style.textOrigin;\n\t\n\t    if (origin === 'center') {\n\t      x = rect.width / 2 + rect.x;\n\t      y = rect.height / 2 + rect.y;\n\t    } else if (origin) {\n\t      x = origin[0] + rect.x;\n\t      y = origin[1] + rect.y;\n\t    }\n\t\n\t    ctx.translate(x, y); // Positive: anticlockwise\n\t\n\t    ctx.rotate(-style.textRotation);\n\t    ctx.translate(-x, -y);\n\t  }\n\t}\n\t\n\tfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n\t  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n\t  // the bias of \"Microsoft YaHei\".\n\t\n\t  var textVerticalAlign = token.textVerticalAlign;\n\t  var y = lineTop + lineHeight / 2;\n\t\n\t  if (textVerticalAlign === 'top') {\n\t    y = lineTop + token.height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y = lineTop + lineHeight - token.height / 2;\n\t  }\n\t\n\t  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n\t  var textPadding = token.textPadding;\n\t\n\t  if (textPadding) {\n\t    x = getTextXForPadding(x, textAlign, textPadding);\n\t    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n\t  }\n\t\n\t  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n\t  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n\t  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\t  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle');\n\t  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\t  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(tokenStyle.textFill || style.textFill);\n\t  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t    ctx.strokeText(token.text, x, y);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t    ctx.fillText(token.text, x, y);\n\t  }\n\t}\n\t\n\tfunction needDrawBackground(style) {\n\t  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n\t} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n\t// shape: {x, y, width, height}\n\t\n\t\n\tfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n\t  var textBackgroundColor = style.textBackgroundColor;\n\t  var textBorderWidth = style.textBorderWidth;\n\t  var textBorderColor = style.textBorderColor;\n\t  var isPlainBg = isString(textBackgroundColor);\n\t  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\t\n\t  if (isPlainBg || textBorderWidth && textBorderColor) {\n\t    ctx.beginPath();\n\t    var textBorderRadius = style.textBorderRadius;\n\t\n\t    if (!textBorderRadius) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, {\n\t        x: x,\n\t        y: y,\n\t        width: width,\n\t        height: height,\n\t        r: textBorderRadius\n\t      });\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t\n\t  if (isPlainBg) {\n\t    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\t    ctx.fill();\n\t  } else if (isObject(textBackgroundColor)) {\n\t    var image = textBackgroundColor.image;\n\t    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\t\n\t    if (image && imageHelper.isImageReady(image)) {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t  }\n\t\n\t  if (textBorderWidth && textBorderColor) {\n\t    setCtx(ctx, 'lineWidth', textBorderWidth);\n\t    setCtx(ctx, 'strokeStyle', textBorderColor);\n\t    ctx.stroke();\n\t  }\n\t}\n\t\n\tfunction onBgImageLoaded(image, textBackgroundColor) {\n\t  // Replace image, so that `contain/text.js#parseRichText`\n\t  // will get correct result in next tick.\n\t  textBackgroundColor.image = image;\n\t}\n\t\n\tfunction getBoxPosition(blockHeiht, style, rect) {\n\t  var baseX = style.x || 0;\n\t  var baseY = style.y || 0;\n\t  var textAlign = style.textAlign;\n\t  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\t\n\t  if (rect) {\n\t    var textPosition = style.textPosition;\n\t\n\t    if (textPosition instanceof Array) {\n\t      // Percent\n\t      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n\t      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n\t    } else {\n\t      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n\t      baseX = res.x;\n\t      baseY = res.y; // Default align and baseline when has textPosition\n\t\n\t      textAlign = textAlign || res.textAlign;\n\t      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n\t    } // textOffset is only support in RectText, otherwise\n\t    // we have to adjust boundingRect for textOffset.\n\t\n\t\n\t    var textOffset = style.textOffset;\n\t\n\t    if (textOffset) {\n\t      baseX += textOffset[0];\n\t      baseY += textOffset[1];\n\t    }\n\t  }\n\t\n\t  return {\n\t    baseX: baseX,\n\t    baseY: baseY,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t\n\tfunction setCtx(ctx, prop, value) {\n\t  // FIXME ??? performance try\n\t  // if (ctx.__currentValues[prop] !== value) {\n\t  // ctx[prop] = ctx.__currentValues[prop] = value;\n\t  ctx[prop] = value; // }\n\t\n\t  return ctx[prop];\n\t}\n\t/**\n\t * @param {string} [stroke] If specified, do not check style.textStroke.\n\t * @param {string} [lineWidth] If specified, do not check style.textStroke.\n\t * @param {number} style\n\t */\n\t\n\t\n\tfunction getStroke(stroke, lineWidth) {\n\t  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n\t  : stroke.image || stroke.colorStops ? '#000' : stroke;\n\t}\n\t\n\tfunction getFill(fill) {\n\t  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n\t  : fill.image || fill.colorStops ? '#000' : fill;\n\t}\n\t\n\tfunction parsePercent(value, maxValue) {\n\t  if (typeof value === 'string') {\n\t    if (value.lastIndexOf('%') >= 0) {\n\t      return parseFloat(value) / 100 * maxValue;\n\t    }\n\t\n\t    return parseFloat(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction getTextXForPadding(x, textAlign, textPadding) {\n\t  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n\t}\n\t/**\n\t * @param {string} text\n\t * @param {module:zrender/Style} style\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction needDrawText(text, style) {\n\t  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n\t}\n\t\n\texports.normalizeTextStyle = normalizeTextStyle;\n\texports.renderText = renderText;\n\texports.getStroke = getStroke;\n\texports.getFill = getFill;\n\texports.needDrawText = needDrawText;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar getContext = _util.getContext;\n\tvar extend = _util.extend;\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar textWidthCache = {};\n\tvar textWidthCacheCounter = 0;\n\tvar TEXT_CACHE_MAX = 5000;\n\tvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\tvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {number} width\n\t */\n\t\n\t\n\tfunction getWidth(text, font) {\n\t  font = font || DEFAULT_FONT;\n\t  var key = text + ':' + font;\n\t\n\t  if (textWidthCache[key]) {\n\t    return textWidthCache[key];\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  var width = 0;\n\t\n\t  for (var i = 0, l = textLines.length; i < l; i++) {\n\t    // textContain.measureText may be overrided in SVG or VML\n\t    width = Math.max(measureText(textLines[i], font).width, width);\n\t  }\n\t\n\t  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t    textWidthCacheCounter = 0;\n\t    textWidthCache = {};\n\t  }\n\t\n\t  textWidthCacheCounter++;\n\t  textWidthCache[key] = width;\n\t  return width;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {string} [textAlign='left']\n\t * @param {string} [textVerticalAlign='top']\n\t * @param {Array.<number>} [textPadding]\n\t * @param {Object} [rich]\n\t * @param {Object} [truncate]\n\t * @return {Object} {x, y, width, height, lineHeight}\n\t */\n\t\n\t\n\tfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n\t}\n\t\n\tfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n\t  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n\t  var outerWidth = getWidth(text, font);\n\t\n\t  if (textPadding) {\n\t    outerWidth += textPadding[1] + textPadding[3];\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n\t  rect.lineHeight = contentBlock.lineHeight;\n\t  return rect;\n\t}\n\t\n\tfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  var contentBlock = parseRichText(text, {\n\t    rich: rich,\n\t    truncate: truncate,\n\t    font: font,\n\t    textAlign: textAlign,\n\t    textPadding: textPadding\n\t  });\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  return new BoundingRect(x, y, outerWidth, outerHeight);\n\t}\n\t/**\n\t * @public\n\t * @param {number} x\n\t * @param {number} width\n\t * @param {string} [textAlign='left']\n\t * @return {number} Adjusted x.\n\t */\n\t\n\t\n\tfunction adjustTextX(x, width, textAlign) {\n\t  // FIXME Right to left language\n\t  if (textAlign === 'right') {\n\t    x -= width;\n\t  } else if (textAlign === 'center') {\n\t    x -= width / 2;\n\t  }\n\t\n\t  return x;\n\t}\n\t/**\n\t * @public\n\t * @param {number} y\n\t * @param {number} height\n\t * @param {string} [textVerticalAlign='top']\n\t * @return {number} Adjusted y.\n\t */\n\t\n\t\n\tfunction adjustTextY(y, height, textVerticalAlign) {\n\t  if (textVerticalAlign === 'middle') {\n\t    y -= height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y -= height;\n\t  }\n\t\n\t  return y;\n\t}\n\t/**\n\t * @public\n\t * @param {stirng} textPosition\n\t * @param {Object} rect {x, y, width, height}\n\t * @param {number} distance\n\t * @return {Object} {x, y, textAlign, textVerticalAlign}\n\t */\n\t\n\t\n\tfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n\t  var x = rect.x;\n\t  var y = rect.y;\n\t  var height = rect.height;\n\t  var width = rect.width;\n\t  var halfHeight = height / 2;\n\t  var textAlign = 'left';\n\t  var textVerticalAlign = 'top';\n\t\n\t  switch (textPosition) {\n\t    case 'left':\n\t      x -= distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'right':\n\t      x += distance + width;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'top':\n\t      x += width / 2;\n\t      y -= distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'bottom':\n\t      x += width / 2;\n\t      y += height + distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'inside':\n\t      x += width / 2;\n\t      y += halfHeight;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideLeft':\n\t      x += distance;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideRight':\n\t      x += width - distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideTop':\n\t      x += width / 2;\n\t      y += distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'insideBottom':\n\t      x += width / 2;\n\t      y += height - distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideTopLeft':\n\t      x += distance;\n\t      y += distance;\n\t      break;\n\t\n\t    case 'insideTopRight':\n\t      x += width - distance;\n\t      y += distance;\n\t      textAlign = 'right';\n\t      break;\n\t\n\t    case 'insideBottomLeft':\n\t      x += distance;\n\t      y += height - distance;\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideBottomRight':\n\t      x += width - distance;\n\t      y += height - distance;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t  }\n\t\n\t  return {\n\t    x: x,\n\t    y: y,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t/**\n\t * Show ellipsis if overflow.\n\t *\n\t * @public\n\t * @param  {string} text\n\t * @param  {string} containerWidth\n\t * @param  {string} font\n\t * @param  {number} [ellipsis='...']\n\t * @param  {Object} [options]\n\t * @param  {number} [options.maxIterations=3]\n\t * @param  {number} [options.minChar=0] If truncate result are less\n\t *                  then minChar, ellipsis will not show, which is\n\t *                  better for user hint in some cases.\n\t * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction truncateText(text, containerWidth, font, ellipsis, options) {\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n\t  // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t  for (var i = 0, len = textLines.length; i < len; i++) {\n\t    textLines[i] = truncateSingleLine(textLines[i], options);\n\t  }\n\t\n\t  return textLines.join('\\n');\n\t}\n\t\n\tfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n\t  options = extend({}, options);\n\t  options.font = font;\n\t  var ellipsis = retrieve2(ellipsis, '...');\n\t  options.maxIterations = retrieve2(options.maxIterations, 2);\n\t  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n\t  // Other languages?\n\t\n\t  options.cnCharWidth = getWidth('', font); // FIXME\n\t  // Consider proportional font?\n\t\n\t  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n\t  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t  // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t\n\t  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t\n\t  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t    contentWidth -= ascCharWidth;\n\t  }\n\t\n\t  var ellipsisWidth = getWidth(ellipsis);\n\t\n\t  if (ellipsisWidth > contentWidth) {\n\t    ellipsis = '';\n\t    ellipsisWidth = 0;\n\t  }\n\t\n\t  contentWidth = containerWidth - ellipsisWidth;\n\t  options.ellipsis = ellipsis;\n\t  options.ellipsisWidth = ellipsisWidth;\n\t  options.contentWidth = contentWidth;\n\t  options.containerWidth = containerWidth;\n\t  return options;\n\t}\n\t\n\tfunction truncateSingleLine(textLine, options) {\n\t  var containerWidth = options.containerWidth;\n\t  var font = options.font;\n\t  var contentWidth = options.contentWidth;\n\t\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var lineWidth = getWidth(textLine, font);\n\t\n\t  if (lineWidth <= containerWidth) {\n\t    return textLine;\n\t  }\n\t\n\t  for (var j = 0;; j++) {\n\t    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n\t      textLine += options.ellipsis;\n\t      break;\n\t    }\n\t\n\t    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t    textLine = textLine.substr(0, subLength);\n\t    lineWidth = getWidth(textLine, font);\n\t  }\n\t\n\t  if (textLine === '') {\n\t    textLine = options.placeholder;\n\t  }\n\t\n\t  return textLine;\n\t}\n\t\n\tfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t  var width = 0;\n\t  var i = 0;\n\t\n\t  for (var len = text.length; i < len && width < contentWidth; i++) {\n\t    var charCode = text.charCodeAt(i);\n\t    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t  }\n\t\n\t  return i;\n\t}\n\t/**\n\t * @public\n\t * @param {string} font\n\t * @return {number} line height\n\t */\n\t\n\t\n\tfunction getLineHeight(font) {\n\t  // FIXME A rough approach.\n\t  return getWidth('', font);\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {Object} width\n\t */\n\t\n\t\n\tfunction measureText(text, font) {\n\t  return methods.measureText(text, font);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tmethods.measureText = function (text, font) {\n\t  var ctx = getContext();\n\t  ctx.font = font || DEFAULT_FONT;\n\t  return ctx.measureText(text);\n\t};\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {Object} [truncate]\n\t * @return {Object} block: {lineHeight, lines, height, outerHeight}\n\t *  Notice: for performance, do not calculate outerWidth util needed.\n\t */\n\t\n\t\n\tfunction parsePlainText(text, font, padding, truncate) {\n\t  text != null && (text += '');\n\t  var lineHeight = getLineHeight(font);\n\t  var lines = text ? text.split('\\n') : [];\n\t  var height = lines.length * lineHeight;\n\t  var outerHeight = height;\n\t\n\t  if (padding) {\n\t    outerHeight += padding[0] + padding[2];\n\t  }\n\t\n\t  if (text && truncate) {\n\t    var truncOuterHeight = truncate.outerHeight;\n\t    var truncOuterWidth = truncate.outerWidth;\n\t\n\t    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n\t      text = '';\n\t      lines = [];\n\t    } else if (truncOuterWidth != null) {\n\t      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n\t        minChar: truncate.minChar,\n\t        placeholder: truncate.placeholder\n\t      }); // FIXME\n\t      // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t      for (var i = 0, len = lines.length; i < len; i++) {\n\t        lines[i] = truncateSingleLine(lines[i], options);\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    lines: lines,\n\t    height: height,\n\t    outerHeight: outerHeight,\n\t    lineHeight: lineHeight\n\t  };\n\t}\n\t/**\n\t * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n\t * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n\t *\n\t * @public\n\t * @param {string} text\n\t * @param {Object} style\n\t * @return {Object} block\n\t * {\n\t *      width,\n\t *      height,\n\t *      lines: [{\n\t *          lineHeight,\n\t *          width,\n\t *          tokens: [[{\n\t *              styleName,\n\t *              text,\n\t *              width,      // include textPadding\n\t *              height,     // include textPadding\n\t *              textWidth, // pure text width\n\t *              textHeight, // pure text height\n\t *              lineHeihgt,\n\t *              font,\n\t *              textAlign,\n\t *              textVerticalAlign\n\t *          }], [...], ...]\n\t *      }, ...]\n\t * }\n\t * If styleName is undefined, it is plain text.\n\t */\n\t\n\t\n\tfunction parseRichText(text, style) {\n\t  var contentBlock = {\n\t    lines: [],\n\t    width: 0,\n\t    height: 0\n\t  };\n\t  text != null && (text += '');\n\t\n\t  if (!text) {\n\t    return contentBlock;\n\t  }\n\t\n\t  var lastIndex = STYLE_REG.lastIndex = 0;\n\t  var result;\n\t\n\t  while ((result = STYLE_REG.exec(text)) != null) {\n\t    var matchedIndex = result.index;\n\t\n\t    if (matchedIndex > lastIndex) {\n\t      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n\t    }\n\t\n\t    pushTokens(contentBlock, result[2], result[1]);\n\t    lastIndex = STYLE_REG.lastIndex;\n\t  }\n\t\n\t  if (lastIndex < text.length) {\n\t    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n\t  }\n\t\n\t  var lines = contentBlock.lines;\n\t  var contentHeight = 0;\n\t  var contentWidth = 0; // For `textWidth: 100%`\n\t\n\t  var pendingList = [];\n\t  var stlPadding = style.textPadding;\n\t  var truncate = style.truncate;\n\t  var truncateWidth = truncate && truncate.outerWidth;\n\t  var truncateHeight = truncate && truncate.outerHeight;\n\t\n\t  if (stlPadding) {\n\t    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n\t    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n\t  } // Calculate layout info of tokens.\n\t\n\t\n\t  for (var i = 0; i < lines.length; i++) {\n\t    var line = lines[i];\n\t    var lineHeight = 0;\n\t    var lineWidth = 0;\n\t\n\t    for (var j = 0; j < line.tokens.length; j++) {\n\t      var token = line.tokens[j];\n\t      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\t\n\t      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\t\n\t      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\t\n\t      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n\t      // as box height of the block.\n\t      tokenStyle.textHeight, getLineHeight(font));\n\t      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n\t      token.height = tokenHeight;\n\t      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n\t      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n\t      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\t\n\t      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n\t        return {\n\t          lines: [],\n\t          width: 0,\n\t          height: 0\n\t        };\n\t      }\n\t\n\t      token.textWidth = getWidth(token.text, font);\n\t      var tokenWidth = tokenStyle.textWidth;\n\t      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n\t      // line when box width is needed to be auto.\n\t\n\t      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n\t        token.percentWidth = tokenWidth;\n\t        pendingList.push(token);\n\t        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n\t        // and it is too complicated.\n\t      } else {\n\t        if (tokenWidthNotSpecified) {\n\t          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n\t          // `getBoundingRect()` will not get correct result.\n\t\n\t          var textBackgroundColor = tokenStyle.textBackgroundColor;\n\t          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n\t          // (1) If image is not loaded, it will be loaded at render phase and call\n\t          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n\t          // image, and then the right size will be calculated here at the next tick.\n\t          // See `graphic/helper/text.js`.\n\t          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n\t          // use `imageHelper.findExistImage` to find cached image.\n\t          // `imageHelper.findExistImage` will always be called here before\n\t          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n\t          // which ensures that image will not be rendered before correct size calcualted.\n\t\n\t          if (bgImg) {\n\t            bgImg = imageHelper.findExistImage(bgImg);\n\t\n\t            if (imageHelper.isImageReady(bgImg)) {\n\t              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n\t            }\n\t          }\n\t        }\n\t\n\t        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n\t        tokenWidth += paddingW;\n\t        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\t\n\t        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n\t          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n\t            token.text = '';\n\t            token.textWidth = tokenWidth = 0;\n\t          } else {\n\t            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n\t              minChar: truncate.minChar\n\t            });\n\t            token.textWidth = getWidth(token.text, font);\n\t            tokenWidth = token.textWidth + paddingW;\n\t          }\n\t        }\n\t      }\n\t\n\t      lineWidth += token.width = tokenWidth;\n\t      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n\t    }\n\t\n\t    line.width = lineWidth;\n\t    line.lineHeight = lineHeight;\n\t    contentHeight += lineHeight;\n\t    contentWidth = Math.max(contentWidth, lineWidth);\n\t  }\n\t\n\t  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n\t  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\t\n\t  if (stlPadding) {\n\t    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n\t    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n\t  }\n\t\n\t  for (var i = 0; i < pendingList.length; i++) {\n\t    var token = pendingList[i];\n\t    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\t\n\t    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n\t  }\n\t\n\t  return contentBlock;\n\t}\n\t\n\tfunction pushTokens(block, str, styleName) {\n\t  var isEmptyStr = str === '';\n\t  var strs = str.split('\\n');\n\t  var lines = block.lines;\n\t\n\t  for (var i = 0; i < strs.length; i++) {\n\t    var text = strs[i];\n\t    var token = {\n\t      styleName: styleName,\n\t      text: text,\n\t      isLineHolder: !text && !isEmptyStr\n\t    }; // The first token should be appended to the last line.\n\t\n\t    if (!i) {\n\t      var tokens = (lines[lines.length - 1] || (lines[0] = {\n\t        tokens: []\n\t      })).tokens; // Consider cases:\n\t      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n\t      // (which is a placeholder) should be replaced by new token.\n\t      // (2) A image backage, where token likes {a|}.\n\t      // (3) A redundant '' will affect textAlign in line.\n\t      // (4) tokens with the same tplName should not be merged, because\n\t      // they should be displayed in different box (with border and padding).\n\t\n\t      var tokensLen = tokens.length;\n\t      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n\t      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n\t      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n\t    } // Other tokens always start a new line.\n\t    else {\n\t        // If there is '', insert it as a placeholder.\n\t        lines.push({\n\t          tokens: [token]\n\t        });\n\t      }\n\t  }\n\t}\n\t\n\tfunction makeFont(style) {\n\t  // FIXME in node-canvas fontWeight is before fontStyle\n\t  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n\t  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n\t  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n\t}\n\t\n\texports.DEFAULT_FONT = DEFAULT_FONT;\n\texports.$override = $override;\n\texports.getWidth = getWidth;\n\texports.getBoundingRect = getBoundingRect;\n\texports.adjustTextX = adjustTextX;\n\texports.adjustTextY = adjustTextY;\n\texports.adjustTextPositionOnRect = adjustTextPositionOnRect;\n\texports.truncateText = truncateText;\n\texports.getLineHeight = getLineHeight;\n\texports.measureText = measureText;\n\texports.parsePlainText = parsePlainText;\n\texports.parseRichText = parseRichText;\n\texports.makeFont = makeFont;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar globalImageCache = new LRU(50);\n\t/**\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\tfunction findExistImage(newImageOrSrc) {\n\t  if (typeof newImageOrSrc === 'string') {\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    return cachedImgObj && cachedImgObj.image;\n\t  } else {\n\t    return newImageOrSrc;\n\t  }\n\t}\n\t/**\n\t * Caution: User should cache loaded images, but not just count on LRU.\n\t * Consider if required images more than LRU size, will dead loop occur?\n\t *\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n\t * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n\t * @param {Function} [cb] params: (image, cbPayload)\n\t * @param {Object} [cbPayload] Payload on cb calling.\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\t\n\tfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n\t  if (!newImageOrSrc) {\n\t    return image;\n\t  } else if (typeof newImageOrSrc === 'string') {\n\t    // Image should not be loaded repeatly.\n\t    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n\t      return image;\n\t    } // Only when there is no existent image or existent image src\n\t    // is different, this method is responsible for load.\n\t\n\t\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    var pendingWrap = {\n\t      hostEl: hostEl,\n\t      cb: cb,\n\t      cbPayload: cbPayload\n\t    };\n\t\n\t    if (cachedImgObj) {\n\t      image = cachedImgObj.image;\n\t      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n\t    } else {\n\t      !image && (image = new Image());\n\t      image.onload = imageOnLoad;\n\t      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n\t        image: image,\n\t        pending: [pendingWrap]\n\t      });\n\t      image.src = image.__zrImageSrc = newImageOrSrc;\n\t    }\n\t\n\t    return image;\n\t  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t  else {\n\t      return newImageOrSrc;\n\t    }\n\t}\n\t\n\tfunction imageOnLoad() {\n\t  var cachedImgObj = this.__cachedImgObj;\n\t  this.onload = this.__cachedImgObj = null;\n\t\n\t  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t    var pendingWrap = cachedImgObj.pending[i];\n\t    var cb = pendingWrap.cb;\n\t    cb && cb(this, pendingWrap.cbPayload);\n\t    pendingWrap.hostEl.dirty();\n\t  }\n\t\n\t  cachedImgObj.pending.length = 0;\n\t}\n\t\n\tfunction isImageReady(image) {\n\t  return image && image.width && image.height;\n\t}\n\t\n\texports.findExistImage = findExistImage;\n\texports.createOrUpdateImage = createOrUpdateImage;\n\texports.isImageReady = isImageReady;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\n\tfunction buildPath(ctx, shape) {\n\t  var x = shape.x;\n\t  var y = shape.y;\n\t  var width = shape.width;\n\t  var height = shape.height;\n\t  var r = shape.r;\n\t  var r1;\n\t  var r2;\n\t  var r3;\n\t  var r4; // Convert width and height to positive for better borderRadius\n\t\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t\n\t  if (typeof r === 'number') {\n\t    r1 = r2 = r3 = r4 = r;\n\t  } else if (r instanceof Array) {\n\t    if (r.length === 1) {\n\t      r1 = r2 = r3 = r4 = r[0];\n\t    } else if (r.length === 2) {\n\t      r1 = r3 = r[0];\n\t      r2 = r4 = r[1];\n\t    } else if (r.length === 3) {\n\t      r1 = r[0];\n\t      r2 = r4 = r[1];\n\t      r3 = r[2];\n\t    } else {\n\t      r1 = r[0];\n\t      r2 = r[1];\n\t      r3 = r[2];\n\t      r4 = r[3];\n\t    }\n\t  } else {\n\t    r1 = r2 = r3 = r4 = 0;\n\t  }\n\t\n\t  var total;\n\t\n\t  if (r1 + r2 > width) {\n\t    total = r1 + r2;\n\t    r1 *= width / total;\n\t    r2 *= width / total;\n\t  }\n\t\n\t  if (r3 + r4 > width) {\n\t    total = r3 + r4;\n\t    r3 *= width / total;\n\t    r4 *= width / total;\n\t  }\n\t\n\t  if (r2 + r3 > height) {\n\t    total = r2 + r3;\n\t    r2 *= height / total;\n\t    r3 *= height / total;\n\t  }\n\t\n\t  if (r1 + r4 > height) {\n\t    total = r1 + r4;\n\t    r1 *= height / total;\n\t    r4 *= height / total;\n\t  }\n\t\n\t  ctx.moveTo(x + r1, y);\n\t  ctx.lineTo(x + width - r2, y);\n\t  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t  ctx.lineTo(x + width, y + height - r3);\n\t  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t  ctx.lineTo(x + r4, y + height);\n\t  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t  ctx.lineTo(x, y + r1);\n\t  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar _event = __webpack_require__(39);\n\t\n\tvar Dispatcher = _event.Dispatcher;\n\t\n\tvar requestAnimationFrame = __webpack_require__(30);\n\t\n\tvar Animator = __webpack_require__(17);\n\t\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t/**\n\t * @typedef {Object} IZRenderStage\n\t * @property {Function} update\n\t */\n\t\n\t/**\n\t * @alias module:zrender/animation/Animation\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Function} [options.onframe]\n\t * @param {IZRenderStage} [options.stage]\n\t * @example\n\t *     var animation = new Animation();\n\t *     var obj = {\n\t *         x: 100,\n\t *         y: 100\n\t *     };\n\t *     animation.animate(node.position)\n\t *         .when(1000, {\n\t *             x: 500,\n\t *             y: 500\n\t *         })\n\t *         .when(2000, {\n\t *             x: 100,\n\t *             y: 100\n\t *         })\n\t *         .start('spline');\n\t */\n\tvar Animation = function (options) {\n\t  options = options || {};\n\t  this.stage = options.stage || {};\n\t\n\t  this.onframe = options.onframe || function () {}; // private properties\n\t\n\t\n\t  this._clips = [];\n\t  this._running = false;\n\t  this._time;\n\t  this._pausedTime;\n\t  this._pauseStart;\n\t  this._paused = false;\n\t  Dispatcher.call(this);\n\t};\n\t\n\tAnimation.prototype = {\n\t  constructor: Animation,\n\t\n\t  /**\n\t   *  clip\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  addClip: function (clip) {\n\t    this._clips.push(clip);\n\t  },\n\t\n\t  /**\n\t   *  animator\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  addAnimator: function (animator) {\n\t    animator.animation = this;\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.addClip(clips[i]);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  removeClip: function (clip) {\n\t    var idx = util.indexOf(this._clips, clip);\n\t\n\t    if (idx >= 0) {\n\t      this._clips.splice(idx, 1);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  removeAnimator: function (animator) {\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.removeClip(clips[i]);\n\t    }\n\t\n\t    animator.animation = null;\n\t  },\n\t  _update: function () {\n\t    var time = new Date().getTime() - this._pausedTime;\n\t\n\t    var delta = time - this._time;\n\t    var clips = this._clips;\n\t    var len = clips.length;\n\t    var deferredEvents = [];\n\t    var deferredClips = [];\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var clip = clips[i];\n\t      var e = clip.step(time, delta); // Throw out the events need to be called after\n\t      // stage.update, like destroy\n\t\n\t      if (e) {\n\t        deferredEvents.push(e);\n\t        deferredClips.push(clip);\n\t      }\n\t    } // Remove the finished clip\n\t\n\t\n\t    for (var i = 0; i < len;) {\n\t      if (clips[i]._needsRemove) {\n\t        clips[i] = clips[len - 1];\n\t        clips.pop();\n\t        len--;\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t\n\t    len = deferredEvents.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      deferredClips[i].fire(deferredEvents[i]);\n\t    }\n\t\n\t    this._time = time;\n\t    this.onframe(delta);\n\t    this.trigger('frame', delta);\n\t\n\t    if (this.stage.update) {\n\t      this.stage.update();\n\t    }\n\t  },\n\t  _startLoop: function () {\n\t    var self = this;\n\t    this._running = true;\n\t\n\t    function step() {\n\t      if (self._running) {\n\t        requestAnimationFrame(step);\n\t        !self._paused && self._update();\n\t      }\n\t    }\n\t\n\t    requestAnimationFrame(step);\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  start: function () {\n\t    this._time = new Date().getTime();\n\t    this._pausedTime = 0;\n\t\n\t    this._startLoop();\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  stop: function () {\n\t    this._running = false;\n\t  },\n\t\n\t  /**\n\t   * Pause\n\t   */\n\t  pause: function () {\n\t    if (!this._paused) {\n\t      this._pauseStart = new Date().getTime();\n\t      this._paused = true;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resume\n\t   */\n\t  resume: function () {\n\t    if (this._paused) {\n\t      this._pausedTime += new Date().getTime() - this._pauseStart;\n\t      this._paused = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  clear: function () {\n\t    this._clips = [];\n\t  },\n\t\n\t  /**\n\t   * animator\n\t   * @param  {Object} target\n\t   * @param  {Object} options\n\t   * @param  {boolean} [options.loop=false] \n\t   * @param  {Function} [options.getter=null]\n\t   *         gettergetter\n\t   * @param  {Function} [options.setter=null]\n\t   *         settersetter\n\t   * @return {module:zrender/animation/Animation~Animator}\n\t   */\n\t  // TODO Gap\n\t  animate: function (target, options) {\n\t    options = options || {};\n\t    var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t    this.addAnimator(animator);\n\t    return animator;\n\t  }\n\t};\n\tutil.mixin(Animation, Dispatcher);\n\tvar _default = Animation;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Eventful = __webpack_require__(10);\n\t\n\texports.Dispatcher = Eventful;\n\t\n\tvar env = __webpack_require__(5);\n\t\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\tvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\tvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\t\n\tfunction getBoundingClientRect(el) {\n\t  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t    left: 0,\n\t    top: 0\n\t  };\n\t} // `calculate` is optional, default false\n\t\n\t\n\tfunction clientToLocal(el, e, out, calculate) {\n\t  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t  // to the padding edge of the target element. The only browser using this convention\n\t  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t  // not support the properties.\n\t  // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t  // In zr painter.dom, padding edge equals to border edge.\n\t  // FIXME\n\t  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t  // is too complex. So css-transfrom dont support in this case temporarily.\n\t\n\t  if (calculate || !env.canvasSupported) {\n\t    defaultGetZrXY(el, e, out);\n\t  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t  // zoom-factor, overflow / opacity layers, transforms ...)\n\t  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t  // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t  // BTW3, In ff, offsetX/offsetY is always 0.\n\t  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t      out.zrX = e.layerX;\n\t      out.zrY = e.layerY;\n\t    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t    else if (e.offsetX != null) {\n\t        out.zrX = e.offsetX;\n\t        out.zrY = e.offsetY;\n\t      } // For some other device, e.g., IOS safari.\n\t      else {\n\t          defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t  return out;\n\t}\n\t\n\tfunction defaultGetZrXY(el, e, out) {\n\t  // This well-known method below does not support css transform.\n\t  var box = getBoundingClientRect(el);\n\t  out.zrX = e.clientX - box.left;\n\t  out.zrY = e.clientY - box.top;\n\t}\n\t/**\n\t * domtouch.\n\t * `calculate` is optional, default false.\n\t */\n\t\n\t\n\tfunction normalizeEvent(el, e, calculate) {\n\t  e = e || window.event;\n\t\n\t  if (e.zrX != null) {\n\t    return e;\n\t  }\n\t\n\t  var eventType = e.type;\n\t  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t  if (!isTouch) {\n\t    clientToLocal(el, e, e, calculate);\n\t    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t  } else {\n\t    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t    touch && clientToLocal(el, touch, e, calculate);\n\t  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n\t  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n\t  // If e.which has been defined, if may be readonly,\n\t  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\t\n\t\n\t  var button = e.button;\n\t\n\t  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n\t    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t  }\n\t\n\t  return e;\n\t}\n\t\n\tfunction addEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.addEventListener(name, handler);\n\t  } else {\n\t    el.attachEvent('on' + name, handler);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.removeEventListener(name, handler);\n\t  } else {\n\t    el.detachEvent('on' + name, handler);\n\t  }\n\t}\n\t/**\n\t * preventDefault and stopPropagation.\n\t * Notice: do not do that in zrender. Upper application\n\t * do that if necessary.\n\t *\n\t * @memberOf module:zrender/core/event\n\t * @method\n\t * @param {Event} e : event\n\t */\n\t\n\t\n\tvar stop = isDomLevel2 ? function (e) {\n\t  e.preventDefault();\n\t  e.stopPropagation();\n\t  e.cancelBubble = true;\n\t} : function (e) {\n\t  e.returnValue = false;\n\t  e.cancelBubble = true;\n\t};\n\t\n\tfunction notLeftMouse(e) {\n\t  // If e.which is undefined, considered as left mouse event.\n\t  return e.which > 1;\n\t} // \n\t\n\t\n\texports.clientToLocal = clientToLocal;\n\texports.normalizeEvent = normalizeEvent;\n\texports.addEventListener = addEventListener;\n\texports.removeEventListener = removeEventListener;\n\texports.stop = stop;\n\texports.notLeftMouse = notLeftMouse;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _event = __webpack_require__(39);\n\t\n\tvar addEventListener = _event.addEventListener;\n\tvar removeEventListener = _event.removeEventListener;\n\tvar normalizeEvent = _event.normalizeEvent;\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar GestureMgr = __webpack_require__(41);\n\t\n\tvar TOUCH_CLICK_DELAY = 300;\n\tvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\tvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n\tvar pointerEventNames = {\n\t  pointerdown: 1,\n\t  pointerup: 1,\n\t  pointermove: 1,\n\t  pointerout: 1\n\t};\n\tvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t  var nm = name.replace('mouse', 'pointer');\n\t  return pointerEventNames[nm] ? nm : name;\n\t});\n\t\n\tfunction eventNameFix(name) {\n\t  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t}\n\t\n\tfunction processGesture(proxy, event, stage) {\n\t  var gestureMgr = proxy._gestureMgr;\n\t  stage === 'start' && gestureMgr.clear();\n\t  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n\t  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\t\n\t  if (gestureInfo) {\n\t    var type = gestureInfo.type;\n\t    event.gestureEvent = type;\n\t    proxy.handler.dispatchToElement({\n\t      target: gestureInfo.target\n\t    }, type, gestureInfo.event);\n\t  }\n\t} // function onMSGestureChange(proxy, event) {\n\t//     if (event.translationX || event.translationY) {\n\t//         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t//     }\n\t//     if (event.scale !== 1) {\n\t//         event.pinchX = event.offsetX;\n\t//         event.pinchY = event.offsetY;\n\t//         event.pinchScale = event.scale;\n\t//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t//     }\n\t// }\n\t\n\t/**\n\t * Prevent mouse event from being dispatched after Touch Events action\n\t * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t * Result: Blocking Mouse Events for 700ms.\n\t */\n\t\n\t\n\tfunction setTouchTimer(instance) {\n\t  instance._touching = true;\n\t  clearTimeout(instance._touchTimer);\n\t  instance._touchTimer = setTimeout(function () {\n\t    instance._touching = false;\n\t  }, 700);\n\t}\n\t\n\tvar domHandlers = {\n\t  /**\n\t   * Mouse move handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mousemove: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger('mousemove', event);\n\t  },\n\t\n\t  /**\n\t   * Mouse out handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mouseout: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    var element = event.toElement || event.relatedTarget;\n\t\n\t    if (element != this.dom) {\n\t      while (element && element.nodeType != 9) {\n\t        // rootdommouseOut\n\t        if (element === this.dom) {\n\t          return;\n\t        }\n\t\n\t        element = element.parentNode;\n\t      }\n\t    }\n\t\n\t    this.trigger('mouseout', event);\n\t  },\n\t\n\t  /**\n\t   * Touch\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchstart: function (event) {\n\t    // Default mouse behaviour should not be disabled here.\n\t    // For example, page may needs to be slided.\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    this._lastTouchMoment = new Date();\n\t    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n\t    // be triggered, and must before `mousedown` triggered.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    domHandlers.mousedown.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchmove: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n\t    // there is gestrue event, because mouse move and pinch may\n\t    // be used at the same time.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchend: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'end');\n\t    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t    // we can conveniently implement \"hover style\" in both PC and touch device just\n\t    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t    // to remove \"hover style\" on an element, without any additional code for\n\t    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t    // style\" will remain for user view)\n\t    // click event should always be triggered no matter whether\n\t    // there is gestrue event. System click can not be prevented.\n\t\n\t    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t      domHandlers.click.call(this, event);\n\t    }\n\t\n\t    setTouchTimer(this);\n\t  },\n\t  pointerdown: function (event) {\n\t    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n\t    //     this._msGesture.addPointer(event.pointerId);\n\t    // }\n\t  },\n\t  pointermove: function (event) {\n\t    // FIXME\n\t    // pointermove is so sensitive that it always triggered when\n\t    // tap(click) on touch screen, which affect some judgement in\n\t    // upper application. So, we dont support mousemove on MS touch\n\t    // device yet.\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mousemove.call(this, event);\n\t    }\n\t  },\n\t  pointerup: function (event) {\n\t    domHandlers.mouseup.call(this, event);\n\t  },\n\t  pointerout: function (event) {\n\t    // pointerout will be triggered when tap on touch screen\n\t    // (IE11+/Edge on MS Surface) after click event triggered,\n\t    // which is inconsistent with the mousout behavior we defined\n\t    // in touchend. So we unify them.\n\t    // (check domHandlers.touchend for detailed explanation)\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mouseout.call(this, event);\n\t    }\n\t  }\n\t};\n\t\n\tfunction isPointerFromTouch(event) {\n\t  var pointerType = event.pointerType;\n\t  return pointerType === 'pen' || pointerType === 'touch';\n\t} // function useMSGuesture(handlerProxy, event) {\n\t//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t// }\n\t// Common handlers\n\t\n\t\n\tzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  domHandlers[name] = function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger(name, event);\n\t  };\n\t});\n\t/**\n\t * dom \n\t *\n\t * @inner\n\t * @param {module:zrender/Handler} instance \n\t */\n\t\n\tfunction initDomHandler(instance) {\n\t  zrUtil.each(touchHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(pointerHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(mouseHandlerNames, function (name) {\n\t    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t  });\n\t\n\t  function makeMouseHandler(fn, instance) {\n\t    return function () {\n\t      if (instance._touching) {\n\t        return;\n\t      }\n\t\n\t      return fn.apply(instance, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction HandlerDomProxy(dom) {\n\t  Eventful.call(this);\n\t  this.dom = dom;\n\t  /**\n\t   * @private\n\t   * @type {boolean}\n\t   */\n\t\n\t  this._touching = false;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._touchTimer;\n\t  /**\n\t   * @private\n\t   * @type {module:zrender/core/GestureMgr}\n\t   */\n\t\n\t  this._gestureMgr = new GestureMgr();\n\t  this._handlers = {};\n\t  initDomHandler(this);\n\t\n\t  if (env.pointerEventsSupported) {\n\t    // Only IE11+/Edge\n\t    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t    // at the same time.\n\t    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t    // screen, which do not occurs in pointer event.\n\t    // So we use pointer event to both detect touch gesture and mouse behavior.\n\t    mountHandlers(pointerHandlerNames, this); // FIXME\n\t    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t    // which does not prevent defuault behavior occasionally (which may cause view port\n\t    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t    // touch screen. And we only support click behavior on MS touch screen now.\n\t    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t    // We dont support touch on IE on win7.\n\t    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t    // if (typeof MSGesture === 'function') {\n\t    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t    // }\n\t  } else {\n\t    if (env.touchEventsSupported) {\n\t      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t    // mouse event can not be handle in those devices.\n\t    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t    // mouseevent after touch event triggered, see `setTouchTimer`.\n\t\n\t\n\t    mountHandlers(mouseHandlerNames, this);\n\t  }\n\t\n\t  function mountHandlers(handlerNames, instance) {\n\t    zrUtil.each(handlerNames, function (name) {\n\t      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t    }, instance);\n\t  }\n\t}\n\t\n\tvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\t\n\thandlerDomProxyProto.dispose = function () {\n\t  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t  for (var i = 0; i < handlerNames.length; i++) {\n\t    var name = handlerNames[i];\n\t    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t  }\n\t};\n\t\n\thandlerDomProxyProto.setCursor = function (cursorStyle) {\n\t  this.dom.style.cursor = cursorStyle || 'default';\n\t};\n\t\n\tzrUtil.mixin(HandlerDomProxy, Eventful);\n\tvar _default = HandlerDomProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar eventUtil = __webpack_require__(39);\n\t\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\tvar GestureMgr = function () {\n\t  /**\n\t   * @private\n\t   * @type {Array.<Object>}\n\t   */\n\t  this._track = [];\n\t};\n\t\n\tGestureMgr.prototype = {\n\t  constructor: GestureMgr,\n\t  recognize: function (event, target, root) {\n\t    this._doTrack(event, target, root);\n\t\n\t    return this._recognize(event);\n\t  },\n\t  clear: function () {\n\t    this._track.length = 0;\n\t    return this;\n\t  },\n\t  _doTrack: function (event, target, root) {\n\t    var touches = event.touches;\n\t\n\t    if (!touches) {\n\t      return;\n\t    }\n\t\n\t    var trackItem = {\n\t      points: [],\n\t      touches: [],\n\t      target: target,\n\t      event: event\n\t    };\n\t\n\t    for (var i = 0, len = touches.length; i < len; i++) {\n\t      var touch = touches[i];\n\t      var pos = eventUtil.clientToLocal(root, touch, {});\n\t      trackItem.points.push([pos.zrX, pos.zrY]);\n\t      trackItem.touches.push(touch);\n\t    }\n\t\n\t    this._track.push(trackItem);\n\t  },\n\t  _recognize: function (event) {\n\t    for (var eventName in recognizers) {\n\t      if (recognizers.hasOwnProperty(eventName)) {\n\t        var gestureInfo = recognizers[eventName](this._track, event);\n\t\n\t        if (gestureInfo) {\n\t          return gestureInfo;\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction dist(pointPair) {\n\t  var dx = pointPair[1][0] - pointPair[0][0];\n\t  var dy = pointPair[1][1] - pointPair[0][1];\n\t  return Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tfunction center(pointPair) {\n\t  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n\t}\n\t\n\tvar recognizers = {\n\t  pinch: function (track, event) {\n\t    var trackLen = track.length;\n\t\n\t    if (!trackLen) {\n\t      return;\n\t    }\n\t\n\t    var pinchEnd = (track[trackLen - 1] || {}).points;\n\t    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t      !isFinite(pinchScale) && (pinchScale = 1);\n\t      event.pinchScale = pinchScale;\n\t      var pinchCenter = center(pinchEnd);\n\t      event.pinchX = pinchCenter[0];\n\t      event.pinchY = pinchCenter[1];\n\t      return {\n\t        type: 'pinch',\n\t        target: track[0].target,\n\t        event: event\n\t      };\n\t    }\n\t  } // Only pinch currently.\n\t\n\t};\n\tvar _default = GestureMgr;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * 1.BO\r\n\t * 2.BO\r\n\t * 3.BO[]\r\n\t * 4.BO[]\r\n\t * 5.BOBO\r\n\t * 6.BO\r\n\t * 7.BOBO\r\n\t * @module fish-topo-bo/node/BoNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var BoName = __webpack_require__(44);\r\n\t    var EventDecision = __webpack_require__(77);\r\n\t    var Line = __webpack_require__(78);\r\n\t    var BoAttr = __webpack_require__(79);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String BO,\r\n\t     *          name: String BO,\r\n\t     *          boEventArr: [] BO,\r\n\t     *          boAttrArr: [] BO\r\n\t     *          }} boData, bo\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} ,\r\n\t     *          displayAttrDataType: boolean ,\r\n\t     *          displayAttrEvent: boolean ,\r\n\t     *          boClickable: boolean BO,  false\r\n\t     *          boPopupOpts: Object BOurl,width,height\r\n\t     *          boEventClickable: boolean BO,  false\r\n\t     *          boEventPopupOpts: Object BOurl,width,height\r\n\t     *          bindBoClickEvent: function(options) BOoptionsDATA\r\n\t     *          attrEventClickable: boolean BO,  false\r\n\t     *          attrEventPopupOpts: Object BOurl,width,height\r\n\t     *          isCurrent: boolean BO\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BO(boData, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boData;\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._oriStartPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._nextStartPos = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\t\r\n\t        //TODO\r\n\t        if (this._displayAttrEvent) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n\t        } else if (this._displayAttrDataType) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._boClickable = opts.boClickable || false;\r\n\t        this._boPopupOpts = opts.boPopupOpts;\r\n\t        this._boEventClickable = opts.boEventClickable || false;\r\n\t        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n\t        this._attrEventClickable = opts.attrEventClickable || false;\r\n\t        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * BOBO\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._isCurrent = opts.isCurrent || false;\r\n\t\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {number}\r\n\t         * @private\r\n\t         */\r\n\t        this._boShapeHeight = 0;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t        this._group.setCurrent = function (style) {\r\n\t            //GroupBO\r\n\t            var _boShape = this.childAt(this.childCount() - 1);\r\n\t\r\n\t            if (style) {\r\n\t                Object.assign(_boShape.style, style);\r\n\t            } else {\r\n\t                //\r\n\t                _boShape.style.fill = '#66CC99';\r\n\t            }\r\n\t\r\n\t        };\r\n\t\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t\r\n\t    var boProto = BO.prototype;\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {Object}\r\n\t     */\r\n\t    boProto.getData = function () {\r\n\t        return this._data;\r\n\t    };\r\n\t\r\n\t    boProto.getLayout = function () {\r\n\t        return this._data.layout;\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     */\r\n\t    boProto.setCurrent = function () {\r\n\t        //BO\r\n\t        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._render = function () {\r\n\t        //BO\r\n\t        this._createBoName();\r\n\t\r\n\t        //BO\r\n\t        this._createEventDecision();\r\n\t\r\n\t        //BO\r\n\t        this._createBoAttr();\r\n\t\r\n\t        //BO\r\n\t        this._createBoShape();\r\n\t\r\n\t        //TODO\r\n\t        Const.BO_NODE_WIDTH = 180;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoName = function () {\r\n\t        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            _boNameShape.clickable = this._boClickable;\r\n\t            _boNameShape._data = this._data;\r\n\t            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n\t            _boNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(_boNameShape);\r\n\t        this._calNextShapeStartPos(_boNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createEventDecision = function () {\r\n\t\r\n\t        //BO\r\n\t        if (!this._data.boEventArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boEventArr = this._data.boEventArr,\r\n\t            _boEventLen = _boEventArr.length,\r\n\t            _eventShape,\r\n\t            _eventOpts = {\r\n\t                startPos: this._nextStartPos,\r\n\t                clickable: this._boEventClickable,\r\n\t                popupOpts: this._boEventPopupOpts,\r\n\t                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t            };\r\n\t\r\n\t        for (var i = 0; i < _boEventLen; i++) {\r\n\t            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n\t            this._group.add(_eventShape.getShape());\r\n\t            this._calNextShapeStartPos(_eventShape.getShape());\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoAttr = function () {\r\n\t        //BO\r\n\t        if (!this._data.boAttrArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrArr = this._data.boAttrArr,\r\n\t            _boAttrLen = _boAttrArr.length,\r\n\t            _boAttrShape, _lineShape,\r\n\t            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\t\r\n\t        for (var i = 0; i < _boAttrLen; i++) {\r\n\t            if (i == 0) {\r\n\t                _lineShape = Line.BoLine(this._nextStartPos); //\r\n\t            }\r\n\t            else {\r\n\t                _lineShape = Line.AttrLine(this._nextStartPos);//\r\n\t            }\r\n\t\r\n\t            this._group.add(_lineShape);\r\n\t\r\n\t            this._calNextShapeStartPos(_lineShape);\r\n\t\r\n\t            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n\t                {\r\n\t                    startPos: this._nextStartPos,\r\n\t                    displayDataType: this._displayAttrDataType,\r\n\t                    displayEventDecision: this._displayAttrEvent,\r\n\t                    eventClickable: this._attrEventClickable,\r\n\t                    eventPopupOpts: this._attrEventPopupOpts,\r\n\t                    bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t                }\r\n\t            );\r\n\t            this._group.add(_boAttrShape.getShape());\r\n\t            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n\t        }\r\n\t\r\n\t        if (this._displayAttrEvent) {\r\n\t            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n\t                this._nextStartPos.y - _attrEventStartPos.y\r\n\t            );\r\n\t            this._group.add(_lineShape);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param curShape \r\n\t     * @private\r\n\t     */\r\n\t    boProto._calNextShapeStartPos = function (curShape) {\r\n\t        //\r\n\t        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\t\r\n\t        //BO\r\n\t        this._boShapeHeight += curShape.getBoundingRect().height;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoShape = function () {\r\n\t        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n\t                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n\t            shape = new graphic.Rect({\r\n\t                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\t\r\n\t                shape: {\r\n\t                    r: 5,\r\n\t                    width: Const.BO_NODE_WIDTH,\r\n\t                    height: height\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    brushType: 'both',\r\n\t                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 1,\r\n\t                    lineCape: 'round'\r\n\t                },\r\n\t\r\n\t                zlevel: -1\r\n\t            });\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            shape._data = this._data;\r\n\t            shape._boPopupOpts = this._boPopupOpts;\r\n\t\r\n\t            shape.clickable = this._boClickable;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boProto._click = function () {\r\n\t        var options = Object.assign(\r\n\t            {\r\n\t                DATA: this._data\r\n\t            }, this._boPopupOpts);\r\n\t\r\n\t        nodeOptions.bindBoClickEvent(options);\r\n\t    };\r\n\t\r\n\t    module.exports = BO;\r\n\t\r\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    module.exports = {\r\n\t        BO_NODE_WIDTH: 180,    //BO\r\n\t        BO_NODE_DEFAULT_HEIGHT: 60,\t//BOBO\r\n\t        BO_NODE_OFFSET_X: 90, //BO=\r\n\t        BO_NODE_OFFSET_Y: 50, //BO\r\n\t\r\n\t        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO,\r\n\t        BO_NAME_PADDING_TOP: 10,   //BO\r\n\t        BO_NAME_PADDING_BOTTOM: 15,   //BO\r\n\t\r\n\t        BO_EVENT_HEIGHT: 20,   //BO\r\n\t        BO_EVENT_WIDTH: 140,   //BO\r\n\t        BO_EVENT_FONT: 'normal 14px Arial',  //BO\r\n\t\r\n\t        BO_ATTR_FONT: 'normal 14px Arial',   //BO\r\n\t        BO_ATTR_PADDING_TOP: 5,   //BO\r\n\t        BO_ATTR_PADDING_BOTTOM: 5,   //BO\r\n\t        BO_ATTR_PADDING_LEFT: 5,   //BO\r\n\t        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO\r\n\t        BO_ATTR_EVENT_WIDTH: 135,   //BO\r\n\t\r\n\t        LINE_DASH: 10,  //\r\n\t        RELATION_OFFSET: 40,   //\r\n\t        RELATION_ARROW_WIDTH: 10,  //\r\n\t        RELATION_ARROW_HEIGHT: 5,  //\r\n\t        RELATION_TEXT_OFFSET_X: 10, //\r\n\t        RELATION_TEXT_OFFSET_Y: 5 //\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * @module fish-topo-bo/node/BoName\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {String} text, BO\r\n\t     * @param {{x: number, y: number}} startPos, \r\n\t     * @returns {zrender/graphic/Text}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoName(text, startPos) {\r\n\t        var x = startPos.x,\r\n\t            y = startPos.y + Const.BO_NAME_PADDING_TOP, // padding-top=10\r\n\t\r\n\t            shape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: text,\r\n\t                    textFont: Const.BO_NAME_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        // =  + (BO - )/2\r\n\t        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\t\r\n\t        //BO =  + padding-top + padding-bottom\r\n\t        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t    module.exports = BoName;\r\n\t\r\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    var pathTool = __webpack_require__(46);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(47);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(15);\r\n\t    var vector = __webpack_require__(8);\r\n\t    var Gradient = __webpack_require__(59);\r\n\t    var Draggable = __webpack_require__(9);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(12);\r\n\t\r\n\t    graphic.Image = __webpack_require__(31);\r\n\t\r\n\t    graphic.Text = __webpack_require__(60);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(35);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(61);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(62);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(64);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(65);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(69);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(70);\r\n\t\r\n\t    graphic.Line = __webpack_require__(71);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(72);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(73);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(74);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(75);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t    graphic.States = __webpack_require__(76);\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        (el.type === 'group' || el.type === 'GroupNode')\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar transformPath = __webpack_require__(58);\n\t\n\t// command chars\n\tvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI = Math.PI;\n\t\n\tvar vMag = function (v) {\n\t  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t};\n\t\n\tvar vRatio = function (u, v) {\n\t  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t};\n\t\n\tvar vAngle = function (u, v) {\n\t  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t};\n\t\n\tfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t  var psi = psiDeg * (PI / 180.0);\n\t  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n\t  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n\t  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t\n\t  if (lambda > 1) {\n\t    rx *= mathSqrt(lambda);\n\t    ry *= mathSqrt(lambda);\n\t  }\n\t\n\t  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t  var cxp = f * rx * yp / ry;\n\t  var cyp = f * -ry * xp / rx;\n\t  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n\t  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n\t  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n\t  var dTheta = vAngle(u, v);\n\t\n\t  if (vRatio(u, v) <= -1) {\n\t    dTheta = PI;\n\t  }\n\t\n\t  if (vRatio(u, v) >= 1) {\n\t    dTheta = 0;\n\t  }\n\t\n\t  if (fs === 0 && dTheta > 0) {\n\t    dTheta = dTheta - 2 * PI;\n\t  }\n\t\n\t  if (fs === 1 && dTheta < 0) {\n\t    dTheta = dTheta + 2 * PI;\n\t  }\n\t\n\t  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t}\n\t\n\tfunction createPathProxyFromString(data) {\n\t  if (!data) {\n\t    return [];\n\t  } // command string\n\t\n\t\n\t  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t  var n; // create pipes so that we can split the data\n\t\n\t  for (n = 0; n < cc.length; n++) {\n\t    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t  } // create array\n\t\n\t\n\t  var arr = cs.split('|'); // init context point\n\t\n\t  var cpx = 0;\n\t  var cpy = 0;\n\t  var path = new PathProxy();\n\t  var CMD = PathProxy.CMD;\n\t  var prevCmd;\n\t\n\t  for (n = 1; n < arr.length; n++) {\n\t    var str = arr[n];\n\t    var c = str.charAt(0);\n\t    var off = 0;\n\t    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t    var cmd;\n\t\n\t    if (p.length > 0 && p[0] === '') {\n\t      p.shift();\n\t    }\n\t\n\t    for (var i = 0; i < p.length; i++) {\n\t      p[i] = parseFloat(p[i]);\n\t    }\n\t\n\t    while (off < p.length && !isNaN(p[off])) {\n\t      if (isNaN(p[0])) {\n\t        break;\n\t      }\n\t\n\t      var ctlPtx;\n\t      var ctlPty;\n\t      var rx;\n\t      var ry;\n\t      var psi;\n\t      var fa;\n\t      var fs;\n\t      var x1 = cpx;\n\t      var y1 = cpy; // convert l, H, h, V, and v to L\n\t\n\t      switch (c) {\n\t        case 'l':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'L':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'm':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'l';\n\t          break;\n\t\n\t        case 'M':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'L';\n\t          break;\n\t\n\t        case 'h':\n\t          cpx += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'H':\n\t          cpx = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'v':\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'V':\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'C':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t          cpx = p[off - 2];\n\t          cpy = p[off - 1];\n\t          break;\n\t\n\t        case 'c':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t          cpx += p[off - 2];\n\t          cpy += p[off - 1];\n\t          break;\n\t\n\t        case 'S':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 's':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = cpx + p[off++];\n\t          y1 = cpy + p[off++];\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'Q':\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'q':\n\t          x1 = p[off++] + cpx;\n\t          y1 = p[off++] + cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'T':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 't':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 'A':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t\n\t        case 'a':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (c === 'z' || c === 'Z') {\n\t      cmd = CMD.Z;\n\t      path.addData(cmd);\n\t    }\n\t\n\t    prevCmd = cmd;\n\t  }\n\t\n\t  path.toStatic();\n\t  return path;\n\t} // TODO Optimize double memory cost problem\n\t\n\t\n\tfunction createPathOptions(str, opts) {\n\t  var pathProxy = createPathProxyFromString(str);\n\t  opts = opts || {};\n\t\n\t  opts.buildPath = function (path) {\n\t    if (path.setData) {\n\t      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\t\n\t      var ctx = path.getContext();\n\t\n\t      if (ctx) {\n\t        path.rebuildPath(ctx);\n\t      }\n\t    } else {\n\t      var ctx = path;\n\t      pathProxy.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  opts.applyTransform = function (m) {\n\t    transformPath(pathProxy, m);\n\t    this.dirty(true);\n\t  };\n\t\n\t  return opts;\n\t}\n\t/**\n\t * Create a Path object from path string data\n\t * http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction createFromString(str, opts) {\n\t  return new Path(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Create a Path class from path string data\n\t * @param  {string} str\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction extendFromString(str, opts) {\n\t  return Path.extend(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Merge multiple paths\n\t */\n\t// TODO Apply transform\n\t// TODO stroke dash\n\t// TODO Optimize double memory cost problem\n\t\n\t\n\tfunction mergePath(pathEls, opts) {\n\t  var pathList = [];\n\t  var len = pathEls.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    var pathEl = pathEls[i];\n\t\n\t    if (!pathEl.path) {\n\t      pathEl.createPathProxy();\n\t    }\n\t\n\t    if (pathEl.__dirtyPath) {\n\t      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t    }\n\t\n\t    pathList.push(pathEl.path);\n\t  }\n\t\n\t  var pathBundle = new Path(opts); // Need path proxy.\n\t\n\t  pathBundle.createPathProxy();\n\t\n\t  pathBundle.buildPath = function (path) {\n\t    path.appendPath(pathList); // Svg and vml renderer don't have context\n\t\n\t    var ctx = path.getContext();\n\t\n\t    if (ctx) {\n\t      path.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  return pathBundle;\n\t}\n\t\n\texports.createFromString = createFromString;\n\texports.extendFromString = extendFromString;\n\texports.mergePath = mergePath;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar pathContain = __webpack_require__(51);\n\t\n\tvar Pattern = __webpack_require__(29);\n\t\n\tvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\tvar abs = Math.abs;\n\tvar pathProxyForDraw = new PathProxy(true);\n\t/**\n\t * @alias module:zrender/graphic/Path\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\t\n\tfunction Path(opts) {\n\t  Displayable.call(this, opts);\n\t  /**\n\t   * @type {module:zrender/core/PathProxy}\n\t   * @readOnly\n\t   */\n\t\n\t  this.path = null;\n\t}\n\t\n\tPath.prototype = {\n\t  constructor: Path,\n\t  type: 'path',\n\t  __dirtyPath: true,\n\t  strokeContainThreshold: 5,\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var path = this.path || pathProxyForDraw;\n\t    var hasStroke = style.hasStroke();\n\t    var hasFill = style.hasFill();\n\t    var fill = style.fill;\n\t    var stroke = style.stroke;\n\t    var hasFillGradient = hasFill && !!fill.colorStops;\n\t    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t    var hasFillPattern = hasFill && !!fill.image;\n\t    var hasStrokePattern = hasStroke && !!stroke.image;\n\t    style.bind(ctx, this, prevEl);\n\t    this.setTransform(ctx);\n\t\n\t    if (this.__dirty) {\n\t      var rect; // Update gradient because bounding rect may changed\n\t\n\t      if (hasFillGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._fillGradient = style.getGradient(ctx, fill, rect);\n\t      }\n\t\n\t      if (hasStrokeGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t      }\n\t    } // Use the gradient or pattern\n\t\n\t\n\t    if (hasFillGradient) {\n\t      // PENDING If may have affect the state\n\t      ctx.fillStyle = this._fillGradient;\n\t    } else if (hasFillPattern) {\n\t      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t    }\n\t\n\t    if (hasStrokeGradient) {\n\t      ctx.strokeStyle = this._strokeGradient;\n\t    } else if (hasStrokePattern) {\n\t      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t    }\n\t\n\t    var lineDash = style.lineDash;\n\t    var lineDashOffset = style.lineDashOffset;\n\t    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\t\n\t    var scale = this.getGlobalScale();\n\t    path.setScale(scale[0], scale[1]); // Proxy context\n\t    // Rebuild path in following 2 cases\n\t    // 1. Path is dirty\n\t    // 2. Path needs javascript implemented lineDash stroking.\n\t    //    In this case, lineDash information will not be saved in PathProxy\n\t\n\t    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t      path.beginPath(ctx); // Setting line dash before build path\n\t\n\t      if (lineDash && !ctxLineDash) {\n\t        path.setLineDash(lineDash);\n\t        path.setLineDashOffset(lineDashOffset);\n\t      }\n\t\n\t      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\t\n\t      if (this.path) {\n\t        this.__dirtyPath = false;\n\t      }\n\t    } else {\n\t      // Replay path building\n\t      ctx.beginPath();\n\t      this.path.rebuildPath(ctx);\n\t    }\n\t\n\t    hasFill && path.fill(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      ctx.setLineDash(lineDash);\n\t      ctx.lineDashOffset = lineDashOffset;\n\t    }\n\t\n\t    hasStroke && path.stroke(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      // PENDING\n\t      // Remove lineDash\n\t      ctx.setLineDash([]);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t  // Like in circle\n\t  buildPath: function (ctx, shapeCfg, inBundle) {},\n\t  createPathProxy: function () {\n\t    this.path = new PathProxy();\n\t  },\n\t  getBoundingRect: function () {\n\t    var rect = this._rect;\n\t    var style = this.style;\n\t    var needsUpdateRect = !rect;\n\t\n\t    if (needsUpdateRect) {\n\t      var path = this.path;\n\t\n\t      if (!path) {\n\t        // Create path on demand.\n\t        path = this.path = new PathProxy();\n\t      }\n\t\n\t      if (this.__dirtyPath) {\n\t        path.beginPath();\n\t        this.buildPath(path, this.shape, false);\n\t      }\n\t\n\t      rect = path.getBoundingRect();\n\t    }\n\t\n\t    this._rect = rect;\n\t\n\t    if (style.hasStroke()) {\n\t      // Needs update rect with stroke lineWidth when\n\t      // 1. Element changes scale or lineWidth\n\t      // 2. Shape is changed\n\t      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t\n\t      if (this.__dirty || needsUpdateRect) {\n\t        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\t\n\t        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\t\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\t\n\t        if (!style.hasFill()) {\n\t          w = Math.max(w, this.strokeContainThreshold || 4);\n\t        } // Consider line width\n\t        // Line scale can't be 0;\n\t\n\t\n\t        if (lineScale > 1e-10) {\n\t          rectWithStroke.width += w / lineScale;\n\t          rectWithStroke.height += w / lineScale;\n\t          rectWithStroke.x -= w / lineScale / 2;\n\t          rectWithStroke.y -= w / lineScale / 2;\n\t        }\n\t      } // Return rect with stroke\n\t\n\t\n\t      return rectWithStroke;\n\t    }\n\t\n\t    return rect;\n\t  },\n\t  contain: function (x, y) {\n\t    var localPos = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    var style = this.style;\n\t    x = localPos[0];\n\t    y = localPos[1];\n\t\n\t    if (rect.contain(x, y)) {\n\t      var pathData = this.path.data;\n\t\n\t      if (style.hasStroke()) {\n\t        var lineWidth = style.lineWidth;\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\t\n\t        if (lineScale > 1e-10) {\n\t          // Only add extra hover lineWidth when there are no fill\n\t          if (!style.hasFill()) {\n\t            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t          }\n\t\n\t          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (style.hasFill()) {\n\t        return pathContain.contain(pathData, x, y);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  /**\n\t   * @param  {boolean} dirtyPath\n\t   */\n\t  dirty: function (dirtyPath) {\n\t    if (dirtyPath == null) {\n\t      dirtyPath = true;\n\t    } // Only mark dirty, not mark clean\n\t\n\t\n\t    if (dirtyPath) {\n\t      this.__dirtyPath = dirtyPath;\n\t      this._rect = null;\n\t    }\n\t\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\t\n\t    if (this.__clipTarget) {\n\t      this.__clipTarget.dirty();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Alias for animate('shape')\n\t   * @param {boolean} loop\n\t   */\n\t  animateShape: function (loop) {\n\t    return this.animate('shape', loop);\n\t  },\n\t  // Overwrite attrKV\n\t  attrKV: function (key, value) {\n\t    // FIXME\n\t    if (key === 'shape') {\n\t      this.setShape(value);\n\t      this.__dirtyPath = true;\n\t      this._rect = null;\n\t    } else {\n\t      Displayable.prototype.attrKV.call(this, key, value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setShape: function (key, value) {\n\t    var shape = this.shape; // Path from string may not have shape\n\t\n\t    if (shape) {\n\t      if (zrUtil.isObject(key)) {\n\t        for (var name in key) {\n\t          if (key.hasOwnProperty(name)) {\n\t            shape[name] = key[name];\n\t          }\n\t        }\n\t      } else {\n\t        shape[key] = value;\n\t      }\n\t\n\t      this.dirty(true);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  getLineScale: function () {\n\t    var m = this.transform; // Get the line scale.\n\t    // Determinant of `m` means how much the area is enlarged by the\n\t    // transformation. So its square root can be used as a scale factor\n\t    // for width.\n\t\n\t    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t  }\n\t};\n\t/**\n\t *  Path element, \n\t * Extend a path element\n\t * @param {Object} props\n\t * @param {string} props.type Path type\n\t * @param {Function} props.init Initialize\n\t * @param {Function} props.buildPath Overwrite buildPath method\n\t * @param {Object} [props.style] Extended default style config\n\t * @param {Object} [props.shape] Extended default shape config\n\t */\n\t\n\tPath.extend = function (defaults) {\n\t  var Sub = function (opts) {\n\t    Path.call(this, opts);\n\t\n\t    if (defaults.style) {\n\t      // Extend default style\n\t      this.style.extendFrom(defaults.style, false);\n\t    } // Extend default shape\n\t\n\t\n\t    var defaultShape = defaults.shape;\n\t\n\t    if (defaultShape) {\n\t      this.shape = this.shape || {};\n\t      var thisShape = this.shape;\n\t\n\t      for (var name in defaultShape) {\n\t        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t          thisShape[name] = defaultShape[name];\n\t        }\n\t      }\n\t    }\n\t\n\t    defaults.init && defaults.init.call(this, opts);\n\t  };\n\t\n\t  zrUtil.inherits(Sub, Path); // FIXME  extend position, rotation \n\t\n\t  for (var name in defaults) {\n\t    // Extending prototype values and methods\n\t    if (name !== 'style' && name !== 'shape') {\n\t      Sub.prototype[name] = defaults[name];\n\t    }\n\t  }\n\t\n\t  return Sub;\n\t};\n\t\n\tzrUtil.inherits(Path, Displayable);\n\tvar _default = Path;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(49);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar bbox = __webpack_require__(50);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar dpr = _config.devicePixelRatio;\n\t\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t// TODO getTotalLength, getPointAtLength\n\tvar CMD = {\n\t  M: 1,\n\t  L: 2,\n\t  C: 3,\n\t  Q: 4,\n\t  A: 5,\n\t  Z: 6,\n\t  // Rect\n\t  R: 7\n\t}; // var CMD_MEM_SIZE = {\n\t//     M: 3,\n\t//     L: 3,\n\t//     C: 7,\n\t//     Q: 5,\n\t//     A: 9,\n\t//     R: 5,\n\t//     Z: 1\n\t// };\n\t\n\tvar min = [];\n\tvar max = [];\n\tvar min2 = [];\n\tvar max2 = [];\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathCos = Math.cos;\n\tvar mathSin = Math.sin;\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAbs = Math.abs;\n\tvar hasTypedArray = typeof Float32Array != 'undefined';\n\t/**\n\t * @alias module:zrender/core/PathProxy\n\t * @constructor\n\t */\n\t\n\tvar PathProxy = function (notSaveData) {\n\t  this._saveData = !(notSaveData || false);\n\t\n\t  if (this._saveData) {\n\t    /**\n\t     * Path data. Stored as flat array\n\t     * @type {Array.<Object>}\n\t     */\n\t    this.data = [];\n\t  }\n\t\n\t  this._ctx = null;\n\t};\n\t/**\n\t * Path\n\t * @return {Object}\n\t */\n\t\n\t\n\tPathProxy.prototype = {\n\t  constructor: PathProxy,\n\t  _xi: 0,\n\t  _yi: 0,\n\t  _x0: 0,\n\t  _y0: 0,\n\t  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t  _ux: 0,\n\t  _uy: 0,\n\t  _len: 0,\n\t  _lineDash: null,\n\t  _dashOffset: 0,\n\t  _dashIdx: 0,\n\t  _dashSum: 0,\n\t\n\t  /**\n\t   * @readOnly\n\t   */\n\t  setScale: function (sx, sy) {\n\t    this._ux = mathAbs(1 / dpr / sx) || 0;\n\t    this._uy = mathAbs(1 / dpr / sy) || 0;\n\t  },\n\t  getContext: function () {\n\t    return this._ctx;\n\t  },\n\t\n\t  /**\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  beginPath: function (ctx) {\n\t    this._ctx = ctx;\n\t    ctx && ctx.beginPath();\n\t    ctx && (this.dpr = ctx.dpr); // Reset\n\t\n\t    if (this._saveData) {\n\t      this._len = 0;\n\t    }\n\t\n\t    if (this._lineDash) {\n\t      this._lineDash = null;\n\t      this._dashOffset = 0;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  moveTo: function (x, y) {\n\t    this.addData(CMD.M, x, y);\n\t    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi  _dashedXXXXTo \n\t    // xi, yi , x0, y0  closePath \n\t    //  beginPath  lineTo x0, y0 \n\t    //  lineTo dashed line  IE10- \n\t\n\t    this._x0 = x;\n\t    this._y0 = y;\n\t    this._xi = x;\n\t    this._yi = y;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  lineTo: function (x, y) {\n\t    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n\t    || this._len < 5;\n\t    this.addData(CMD.L, x, y);\n\t\n\t    if (this._ctx && exceedUnit) {\n\t      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t    }\n\t\n\t    if (exceedUnit) {\n\t      this._xi = x;\n\t      this._yi = y;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @param  {number} x3\n\t   * @param  {number} y3\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t    }\n\t\n\t    this._xi = x3;\n\t    this._yi = y3;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  quadraticCurveTo: function (x1, y1, x2, y2) {\n\t    this.addData(CMD.Q, x1, y1, x2, y2);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t    }\n\t\n\t    this._xi = x2;\n\t    this._yi = y2;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} cx\n\t   * @param  {number} cy\n\t   * @param  {number} r\n\t   * @param  {number} startAngle\n\t   * @param  {number} endAngle\n\t   * @param  {boolean} anticlockwise\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t    this._xi = mathCos(endAngle) * r + cx;\n\t    this._yi = mathSin(endAngle) * r + cx;\n\t    return this;\n\t  },\n\t  // TODO\n\t  arcTo: function (x1, y1, x2, y2, radius) {\n\t    if (this._ctx) {\n\t      this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  // TODO\n\t  rect: function (x, y, w, h) {\n\t    this._ctx && this._ctx.rect(x, y, w, h);\n\t    this.addData(CMD.R, x, y, w, h);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  closePath: function () {\n\t    this.addData(CMD.Z);\n\t    var ctx = this._ctx;\n\t    var x0 = this._x0;\n\t    var y0 = this._y0;\n\t\n\t    if (ctx) {\n\t      this._needsDash() && this._dashedLineTo(x0, y0);\n\t      ctx.closePath();\n\t    }\n\t\n\t    this._xi = x0;\n\t    this._yi = y0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Context  rebuildPath  fill\n\t   * stroke \n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  fill: function (ctx) {\n\t    ctx && ctx.fill();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  stroke: function (ctx) {\n\t    ctx && ctx.stroke();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * \n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDash: function (lineDash) {\n\t    if (lineDash instanceof Array) {\n\t      this._lineDash = lineDash;\n\t      this._dashIdx = 0;\n\t      var lineDashSum = 0;\n\t\n\t      for (var i = 0; i < lineDash.length; i++) {\n\t        lineDashSum += lineDash[i];\n\t      }\n\t\n\t      this._dashSum = lineDashSum;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDashOffset: function (offset) {\n\t    this._dashOffset = offset;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   *\n\t   * @return {boolean}\n\t   */\n\t  len: function () {\n\t    return this._len;\n\t  },\n\t\n\t  /**\n\t   *  Path \n\t   */\n\t  setData: function (data) {\n\t    var len = data.length;\n\t\n\t    if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t      this.data = new Float32Array(len);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      this.data[i] = data[i];\n\t    }\n\t\n\t    this._len = len;\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t   */\n\t  appendPath: function (path) {\n\t    if (!(path instanceof Array)) {\n\t      path = [path];\n\t    }\n\t\n\t    var len = path.length;\n\t    var appendSize = 0;\n\t    var offset = this._len;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      appendSize += path[i].len();\n\t    }\n\t\n\t    if (hasTypedArray && this.data instanceof Float32Array) {\n\t      this.data = new Float32Array(offset + appendSize);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var appendPathData = path[i].data;\n\t\n\t      for (var k = 0; k < appendPathData.length; k++) {\n\t        this.data[offset++] = appendPathData[k];\n\t      }\n\t    }\n\t\n\t    this._len = offset;\n\t  },\n\t\n\t  /**\n\t   *  Path \n\t   * \n\t   */\n\t  addData: function (cmd) {\n\t    if (!this._saveData) {\n\t      return;\n\t    }\n\t\n\t    var data = this.data;\n\t\n\t    if (this._len + arguments.length > data.length) {\n\t      //  Float32Array\n\t      // \n\t      this._expandData();\n\t\n\t      data = this.data;\n\t    }\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      data[this._len++] = arguments[i];\n\t    }\n\t\n\t    this._prevCmd = cmd;\n\t  },\n\t  _expandData: function () {\n\t    // Only if data is Float32Array\n\t    if (!(this.data instanceof Array)) {\n\t      var newData = [];\n\t\n\t      for (var i = 0; i < this._len; i++) {\n\t        newData[i] = this.data[i];\n\t      }\n\t\n\t      this.data = newData;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * If needs js implemented dashed line\n\t   * @return {boolean}\n\t   * @private\n\t   */\n\t  _needsDash: function () {\n\t    return this._lineDash;\n\t  },\n\t  _dashedLineTo: function (x1, y1) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var dx = x1 - x0;\n\t    var dy = y1 - y0;\n\t    var dist = mathSqrt(dx * dx + dy * dy);\n\t    var x = x0;\n\t    var y = y0;\n\t    var dash;\n\t    var nDash = lineDash.length;\n\t    var idx;\n\t    dx /= dist;\n\t    dy /= dist;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum;\n\t    x -= offset * dx;\n\t    y -= offset * dy;\n\t\n\t    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t      idx = this._dashIdx;\n\t      dash = lineDash[idx];\n\t      x += dx * dash;\n\t      y += dy * dash;\n\t      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\t\n\t      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t        continue;\n\t      }\n\t\n\t      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t    } // Offset for next lineTo\n\t\n\t\n\t    dx = x - x1;\n\t    dy = y - y1;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  // Not accurate dashed line to\n\t  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var t;\n\t    var dx;\n\t    var dy;\n\t    var cubicAt = curve.cubicAt;\n\t    var bezierLen = 0;\n\t    var idx = this._dashIdx;\n\t    var nDash = lineDash.length;\n\t    var x;\n\t    var y;\n\t    var tmpLen = 0;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum; // Bezier approx length\n\t\n\t    for (t = 0; t < 1; t += 0.1) {\n\t      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t      bezierLen += mathSqrt(dx * dx + dy * dy);\n\t    } // Find idx after add offset\n\t\n\t\n\t    for (; idx < nDash; idx++) {\n\t      tmpLen += lineDash[idx];\n\t\n\t      if (tmpLen > offset) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    t = (tmpLen - offset) / bezierLen;\n\t\n\t    while (t <= 1) {\n\t      x = cubicAt(x0, x1, x2, x3, t);\n\t      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n\t      // Bad result if dash is long\n\t\n\t      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t      t += lineDash[idx] / bezierLen;\n\t      idx = (idx + 1) % nDash;\n\t    } // Finish the last segment and calculate the new offset\n\t\n\t\n\t    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t    dx = x3 - x;\n\t    dy = y3 - y;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t    // Convert quadratic to cubic using degree elevation\n\t    var x3 = x2;\n\t    var y3 = y2;\n\t    x2 = (x2 + 2 * x1) / 3;\n\t    y2 = (y2 + 2 * y1) / 3;\n\t    x1 = (this._xi + 2 * x1) / 3;\n\t    y1 = (this._yi + 2 * y1) / 3;\n\t\n\t    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t  },\n\t\n\t  /**\n\t   *  Float32Array \n\t   * Convert dynamic array to static Float32Array\n\t   */\n\t  toStatic: function () {\n\t    var data = this.data;\n\t\n\t    if (data instanceof Array) {\n\t      data.length = this._len;\n\t\n\t      if (hasTypedArray) {\n\t        this.data = new Float32Array(data);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function () {\n\t    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t    var data = this.data;\n\t    var xi = 0;\n\t    var yi = 0;\n\t    var x0 = 0;\n\t    var y0 = 0;\n\t\n\t    for (var i = 0; i < data.length;) {\n\t      var cmd = data[i++];\n\t\n\t      if (i == 1) {\n\t        //  L, C, Q\n\t        //  previous point  point\n\t        //\n\t        //  Arc \n\t        xi = data[i];\n\t        yi = data[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          // moveTo  subpath, \n\t          //  closePath \n\t          x0 = data[i++];\n\t          y0 = data[i++];\n\t          xi = x0;\n\t          yi = y0;\n\t          min2[0] = x0;\n\t          min2[1] = y0;\n\t          max2[0] = x0;\n\t          max2[1] = y0;\n\t          break;\n\t\n\t        case CMD.L:\n\t          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.C:\n\t          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.A:\n\t          // TODO Arc \n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++];\n\t          var endAngle = data[i++] + startAngle; // TODO Arc \n\t\n\t          var psi = data[i++];\n\t          var anticlockwise = 1 - data[i++];\n\t\n\t          if (i == 1) {\n\t            //  arc \n\t            // \n\t            x0 = mathCos(startAngle) * rx + cx;\n\t            y0 = mathSin(startAngle) * ry + cy;\n\t          }\n\t\n\t          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = data[i++];\n\t          y0 = yi = data[i++];\n\t          var width = data[i++];\n\t          var height = data[i++]; // Use fromLine\n\t\n\t          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          xi = x0;\n\t          yi = y0;\n\t          break;\n\t      } // Union\n\t\n\t\n\t      vec2.min(min, min, min2);\n\t      vec2.max(max, max, max2);\n\t    } // No data\n\t\n\t\n\t    if (i === 0) {\n\t      min[0] = min[1] = max[0] = max[1] = 0;\n\t    }\n\t\n\t    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t  },\n\t\n\t  /**\n\t   * Rebuild path from current data\n\t   * Rebuild path will not consider javascript implemented line dash.\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  rebuildPath: function (ctx) {\n\t    var d = this.data;\n\t    var x0, y0;\n\t    var xi, yi;\n\t    var x, y;\n\t    var ux = this._ux;\n\t    var uy = this._uy;\n\t    var len = this._len;\n\t\n\t    for (var i = 0; i < len;) {\n\t      var cmd = d[i++];\n\t\n\t      if (i == 1) {\n\t        //  L, C, Q\n\t        //  previous point  point\n\t        //\n\t        //  Arc \n\t        xi = d[i];\n\t        yi = d[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          x0 = xi = d[i++];\n\t          y0 = yi = d[i++];\n\t          ctx.moveTo(xi, yi);\n\t          break;\n\t\n\t        case CMD.L:\n\t          x = d[i++];\n\t          y = d[i++]; // Not draw too small seg between\n\t\n\t          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t            ctx.lineTo(x, y);\n\t            xi = x;\n\t            yi = y;\n\t          }\n\t\n\t          break;\n\t\n\t        case CMD.C:\n\t          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.A:\n\t          var cx = d[i++];\n\t          var cy = d[i++];\n\t          var rx = d[i++];\n\t          var ry = d[i++];\n\t          var theta = d[i++];\n\t          var dTheta = d[i++];\n\t          var psi = d[i++];\n\t          var fs = d[i++];\n\t          var r = rx > ry ? rx : ry;\n\t          var scaleX = rx > ry ? 1 : rx / ry;\n\t          var scaleY = rx > ry ? ry / rx : 1;\n\t          var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t          var endAngle = theta + dTheta;\n\t\n\t          if (isEllipse) {\n\t            ctx.translate(cx, cy);\n\t            ctx.rotate(psi);\n\t            ctx.scale(scaleX, scaleY);\n\t            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t            ctx.scale(1 / scaleX, 1 / scaleY);\n\t            ctx.rotate(-psi);\n\t            ctx.translate(-cx, -cy);\n\t          } else {\n\t            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t          }\n\t\n\t          if (i == 1) {\n\t            //  arc \n\t            // \n\t            x0 = mathCos(theta) * rx + cx;\n\t            y0 = mathSin(theta) * ry + cy;\n\t          }\n\t\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = d[i];\n\t          y0 = yi = d[i + 1];\n\t          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          ctx.closePath();\n\t          xi = x0;\n\t          yi = y0;\n\t      }\n\t    }\n\t  }\n\t};\n\tPathProxy.CMD = CMD;\n\tvar _default = PathProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Create = _vector.create;\n\tvar v2DistSquare = _vector.distSquare;\n\t\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tvar mathPow = Math.pow;\n\tvar mathSqrt = Math.sqrt;\n\tvar EPSILON = 1e-8;\n\tvar EPSILON_NUMERIC = 1e-4;\n\tvar THREE_SQRT = mathSqrt(3);\n\tvar ONE_THIRD = 1 / 3; // \n\t\n\tvar _v0 = v2Create();\n\t\n\tvar _v1 = v2Create();\n\t\n\tvar _v2 = v2Create();\n\t\n\tfunction isAroundZero(val) {\n\t  return val > -EPSILON && val < EPSILON;\n\t}\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} val\n\t * @param  {Array.<number>} roots\n\t * @return {number} \n\t */\n\t\n\t\n\tfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t  // Evaluate roots of cubic functions\n\t  var a = p3 + 3 * (p1 - p2) - p0;\n\t  var b = 3 * (p2 - p1 * 2 + p0);\n\t  var c = 3 * (p1 - p0);\n\t  var d = p0 - val;\n\t  var A = b * b - 3 * a * c;\n\t  var B = b * c - 9 * a * d;\n\t  var C = c * c - 3 * b * d;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(A) && isAroundZero(B)) {\n\t    if (isAroundZero(b)) {\n\t      roots[0] = 0;\n\t    } else {\n\t      var t1 = -c / b; //t1, t2, t3, b is not zero\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = B * B - 4 * A * C;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var K = B / A;\n\t      var t1 = -b / a + K; // t1, a is not zero\n\t\n\t      var t2 = -K / 2; // t2, t3\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t\n\t      if (Y1 < 0) {\n\t        Y1 = -mathPow(-Y1, ONE_THIRD);\n\t      } else {\n\t        Y1 = mathPow(Y1, ONE_THIRD);\n\t      }\n\t\n\t      if (Y2 < 0) {\n\t        Y2 = -mathPow(-Y2, ONE_THIRD);\n\t      } else {\n\t        Y2 = mathPow(Y2, ONE_THIRD);\n\t      }\n\t\n\t      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else {\n\t      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t      var theta = Math.acos(T) / 3;\n\t      var ASqrt = mathSqrt(A);\n\t      var tmp = Math.cos(theta);\n\t      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t\n\t      if (t3 >= 0 && t3 <= 1) {\n\t        roots[n++] = t3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {Array.<number>} extrema\n\t * @return {number} \n\t */\n\t\n\t\n\tfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n\t  var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t  var c = 3 * p1 - 3 * p0;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      extrema[0] = -b / (2 * a);\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        extrema[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p23 = (p3 - p2) * t + p2;\n\t  var p012 = (p12 - p01) * t + p01;\n\t  var p123 = (p23 - p12) * t + p12;\n\t  var p0123 = (p123 - p012) * t + p012; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012;\n\t  out[3] = p0123; // Seg1\n\t\n\t  out[4] = p0123;\n\t  out[5] = p123;\n\t  out[6] = p23;\n\t  out[7] = p3;\n\t}\n\t/**\n\t * \n\t * \n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} [out] \n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  var prev;\n\t  var next;\n\t  var d1;\n\t  var d2;\n\t  _v0[0] = x;\n\t  _v0[1] = y; //  t \n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t    d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    prev = t - interval;\n\t    next = t + interval; // t - interval\n\t\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t    d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t      d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = cubicAt(x0, x1, x2, x3, t);\n\t    out[1] = cubicAt(y0, y1, y2, y3, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t/**\n\t * \n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticAt(p0, p1, p2, t) {\n\t  var onet = 1 - t;\n\t  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t}\n\t/**\n\t * \n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticDerivativeAt(p0, p1, p2, t) {\n\t  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t}\n\t/**\n\t * \n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} roots\n\t * @return {number} \n\t */\n\t\n\t\n\tfunction quadraticRootAt(p0, p1, p2, val, roots) {\n\t  var a = p0 - 2 * p1 + p2;\n\t  var b = 2 * (p1 - p0);\n\t  var c = p0 - val;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var t1 = -b / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticExtremum(p0, p1, p2) {\n\t  var divider = p0 + p2 - 2 * p1;\n\t\n\t  if (divider === 0) {\n\t    // p1 is center of p0 and p2\n\t    return 0.5;\n\t  } else {\n\t    return (p0 - p1) / divider;\n\t  }\n\t}\n\t/**\n\t * \n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction quadraticSubdivide(p0, p1, p2, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p012 = (p12 - p01) * t + p01; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012; // Seg1\n\t\n\t  out[3] = p012;\n\t  out[4] = p12;\n\t  out[5] = p2;\n\t}\n\t/**\n\t * \n\t * \n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} out \n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  _v0[0] = x;\n\t  _v0[1] = y; //  t \n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t    _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t    var d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    var prev = t - interval;\n\t    var next = t + interval; // t - interval\n\t\n\t    _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t    _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t    var d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = quadraticAt(x0, x1, x2, next);\n\t      _v2[1] = quadraticAt(y0, y1, y2, next);\n\t      var d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = quadraticAt(x0, x1, x2, t);\n\t    out[1] = quadraticAt(y0, y1, y2, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t\n\texports.cubicAt = cubicAt;\n\texports.cubicDerivativeAt = cubicDerivativeAt;\n\texports.cubicRootAt = cubicRootAt;\n\texports.cubicExtrema = cubicExtrema;\n\texports.cubicSubdivide = cubicSubdivide;\n\texports.cubicProjectPoint = cubicProjectPoint;\n\texports.quadraticAt = quadraticAt;\n\texports.quadraticDerivativeAt = quadraticDerivativeAt;\n\texports.quadraticRootAt = quadraticRootAt;\n\texports.quadraticExtremum = quadraticExtremum;\n\texports.quadraticSubdivide = quadraticSubdivide;\n\texports.quadraticProjectPoint = quadraticProjectPoint;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar curve = __webpack_require__(49);\n\t\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI2 = Math.PI * 2;\n\tvar start = vec2.create();\n\tvar end = vec2.create();\n\tvar extremity = vec2.create();\n\t/**\n\t * `min``max`\n\t * @module zrender/core/bbox\n\t * @param {Array<Object>} points \n\t * @param {number} min\n\t * @param {number} max\n\t */\n\t\n\tfunction fromPoints(points, min, max) {\n\t  if (points.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var p = points[0];\n\t  var left = p[0];\n\t  var right = p[0];\n\t  var top = p[1];\n\t  var bottom = p[1];\n\t  var i;\n\t\n\t  for (i = 1; i < points.length; i++) {\n\t    p = points[i];\n\t    left = mathMin(left, p[0]);\n\t    right = mathMax(right, p[0]);\n\t    top = mathMin(top, p[1]);\n\t    bottom = mathMax(bottom, p[1]);\n\t  }\n\t\n\t  min[0] = left;\n\t  min[1] = top;\n\t  max[0] = right;\n\t  max[1] = bottom;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromLine(x0, y0, x1, y1, min, max) {\n\t  min[0] = mathMin(x0, x1);\n\t  min[1] = mathMin(y0, y1);\n\t  max[0] = mathMax(x0, x1);\n\t  max[1] = mathMax(y0, y1);\n\t}\n\t\n\tvar xDim = [];\n\tvar yDim = [];\n\t/**\n\t * (p0, p1, p2, p3)`min``max`\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\tfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t  var cubicExtrema = curve.cubicExtrema;\n\t  var cubicAt = curve.cubicAt;\n\t  var i;\n\t  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t  min[0] = Infinity;\n\t  min[1] = Infinity;\n\t  max[0] = -Infinity;\n\t  max[1] = -Infinity;\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t    min[0] = mathMin(x, min[0]);\n\t    max[0] = mathMax(x, max[0]);\n\t  }\n\t\n\t  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t    min[1] = mathMin(y, min[1]);\n\t    max[1] = mathMax(y, max[1]);\n\t  }\n\t\n\t  min[0] = mathMin(x0, min[0]);\n\t  max[0] = mathMax(x0, max[0]);\n\t  min[0] = mathMin(x3, min[0]);\n\t  max[0] = mathMax(x3, max[0]);\n\t  min[1] = mathMin(y0, min[1]);\n\t  max[1] = mathMax(y0, max[1]);\n\t  min[1] = mathMin(y3, min[1]);\n\t  max[1] = mathMax(y3, max[1]);\n\t}\n\t/**\n\t * (p0, p1, p2)`min``max`\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n\t  var quadraticExtremum = curve.quadraticExtremum;\n\t  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\t\n\t  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t  var x = quadraticAt(x0, x1, x2, tx);\n\t  var y = quadraticAt(y0, y1, y2, ty);\n\t  min[0] = mathMin(x0, x2, x);\n\t  min[1] = mathMin(y0, y2, y);\n\t  max[0] = mathMax(x0, x2, x);\n\t  max[1] = mathMax(y0, y2, y);\n\t}\n\t/**\n\t * `min``max`\n\t * @method\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} rx\n\t * @param {number} ry\n\t * @param {number} startAngle\n\t * @param {number} endAngle\n\t * @param {number} anticlockwise\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t  var vec2Min = vec2.min;\n\t  var vec2Max = vec2.max;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t    // Is a circle\n\t    min[0] = x - rx;\n\t    min[1] = y - ry;\n\t    max[0] = x + rx;\n\t    max[1] = y + ry;\n\t    return;\n\t  }\n\t\n\t  start[0] = mathCos(startAngle) * rx + x;\n\t  start[1] = mathSin(startAngle) * ry + y;\n\t  end[0] = mathCos(endAngle) * rx + x;\n\t  end[1] = mathSin(endAngle) * ry + y;\n\t  vec2Min(min, start, end);\n\t  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\t\n\t  startAngle = startAngle % PI2;\n\t\n\t  if (startAngle < 0) {\n\t    startAngle = startAngle + PI2;\n\t  }\n\t\n\t  endAngle = endAngle % PI2;\n\t\n\t  if (endAngle < 0) {\n\t    endAngle = endAngle + PI2;\n\t  }\n\t\n\t  if (startAngle > endAngle && !anticlockwise) {\n\t    endAngle += PI2;\n\t  } else if (startAngle < endAngle && anticlockwise) {\n\t    startAngle += PI2;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = endAngle;\n\t    endAngle = startAngle;\n\t    startAngle = tmp;\n\t  } // var number = 0;\n\t  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t\n\t\n\t  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t    if (angle > startAngle) {\n\t      extremity[0] = mathCos(angle) * rx + x;\n\t      extremity[1] = mathSin(angle) * ry + y;\n\t      vec2Min(min, extremity, min);\n\t      vec2Max(max, extremity, max);\n\t    }\n\t  }\n\t}\n\t\n\texports.fromPoints = fromPoints;\n\texports.fromLine = fromLine;\n\texports.fromCubic = fromCubic;\n\texports.fromQuadratic = fromQuadratic;\n\texports.fromArc = fromArc;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar line = __webpack_require__(52);\n\t\n\tvar cubic = __webpack_require__(53);\n\t\n\tvar quadratic = __webpack_require__(54);\n\t\n\tvar arc = __webpack_require__(55);\n\t\n\tvar _util = __webpack_require__(56);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\t\n\tvar curve = __webpack_require__(49);\n\t\n\tvar windingLine = __webpack_require__(57);\n\t\n\tvar CMD = PathProxy.CMD;\n\tvar PI2 = Math.PI * 2;\n\tvar EPSILON = 1e-4;\n\t\n\tfunction isAroundEqual(a, b) {\n\t  return Math.abs(a - b) < EPSILON;\n\t} // \n\t\n\t\n\tvar roots = [-1, -1, -1];\n\tvar extrema = [-1, -1];\n\t\n\tfunction swapExtrema() {\n\t  var tmp = extrema[0];\n\t  extrema[0] = extrema[1];\n\t  extrema[1] = tmp;\n\t}\n\t\n\tfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var w = 0;\n\t    var nExtrema = -1;\n\t    var y0_, y1_;\n\t\n\t    for (var i = 0; i < nRoots; i++) {\n\t      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t      var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        continue;\n\t      }\n\t\n\t      if (nExtrema < 0) {\n\t        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t\n\t        if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t          swapExtrema();\n\t        }\n\t\n\t        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t\n\t        if (nExtrema > 1) {\n\t          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t        }\n\t      }\n\t\n\t      if (nExtrema == 2) {\n\t        // \n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else if (t < extrema[1]) {\n\t          w += y1_ < y0_ ? unit : -unit;\n\t        } else {\n\t          w += y3 < y1_ ? unit : -unit;\n\t        }\n\t      } else {\n\t        // \n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y3 < y0_ ? unit : -unit;\n\t        }\n\t      }\n\t    }\n\t\n\t    return w;\n\t  }\n\t}\n\t\n\tfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var t = curve.quadraticExtremum(y0, y1, y2);\n\t\n\t    if (t >= 0 && t <= 1) {\n\t      var w = 0;\n\t      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t\n\t      for (var i = 0; i < nRoots; i++) {\n\t        // Remove one endpoint.\n\t        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t\n\t        if (x_ < x) {\n\t          // Quick reject\n\t          continue;\n\t        }\n\t\n\t        if (roots[i] < t) {\n\t          w += y_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y2 < y_ ? unit : -unit;\n\t        }\n\t      }\n\t\n\t      return w;\n\t    } else {\n\t      // Remove one endpoint.\n\t      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        return 0;\n\t      }\n\t\n\t      return y2 < y0 ? unit : -unit;\n\t    }\n\t  }\n\t} // TODO\n\t// Arc \n\t\n\t\n\tfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t  y -= cy;\n\t\n\t  if (y > r || y < -r) {\n\t    return 0;\n\t  }\n\t\n\t  var tmp = Math.sqrt(r * r - y * y);\n\t  roots[0] = -tmp;\n\t  roots[1] = tmp;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff < 1e-4) {\n\t    return 0;\n\t  }\n\t\n\t  if (diff % PI2 < 1e-4) {\n\t    // Is a circle\n\t    startAngle = 0;\n\t    endAngle = PI2;\n\t    var dir = anticlockwise ? 1 : -1;\n\t\n\t    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t      return dir;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var w = 0;\n\t\n\t  for (var i = 0; i < 2; i++) {\n\t    var x_ = roots[i];\n\t\n\t    if (x_ + cx > x) {\n\t      var angle = Math.atan2(y, x_);\n\t      var dir = anticlockwise ? 1 : -1;\n\t\n\t      if (angle < 0) {\n\t        angle = PI2 + angle;\n\t      }\n\t\n\t      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t          dir = -dir;\n\t        }\n\t\n\t        w += dir;\n\t      }\n\t    }\n\t  }\n\t\n\t  return w;\n\t}\n\t\n\tfunction containPath(data, lineWidth, isStroke, x, y) {\n\t  var w = 0;\n\t  var xi = 0;\n\t  var yi = 0;\n\t  var x0 = 0;\n\t  var y0 = 0;\n\t\n\t  for (var i = 0; i < data.length;) {\n\t    var cmd = data[i++]; // Begin a new subpath\n\t\n\t    if (cmd === CMD.M && i > 1) {\n\t      // Close previous subpath\n\t      if (!isStroke) {\n\t        w += windingLine(xi, yi, x0, y0, x, y);\n\t      } //  subpath \n\t      // if (w !== 0) {\n\t      //     return true;\n\t      // }\n\t\n\t    }\n\t\n\t    if (i == 1) {\n\t      //  L, C, Q\n\t      //  previous point  point\n\t      //\n\t      //  Arc \n\t      xi = data[i];\n\t      yi = data[i + 1];\n\t      x0 = xi;\n\t      y0 = yi;\n\t    }\n\t\n\t    switch (cmd) {\n\t      case CMD.M:\n\t        // moveTo  subpath, \n\t        //  closePath \n\t        x0 = data[i++];\n\t        y0 = data[i++];\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t\n\t      case CMD.L:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // NOTE  L, C, Q  NaN\n\t          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.C:\n\t        if (isStroke) {\n\t          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.Q:\n\t        if (isStroke) {\n\t          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.A:\n\t        // TODO Arc \n\t        var cx = data[i++];\n\t        var cy = data[i++];\n\t        var rx = data[i++];\n\t        var ry = data[i++];\n\t        var theta = data[i++];\n\t        var dTheta = data[i++]; // TODO Arc \n\t\n\t        var psi = data[i++];\n\t        var anticlockwise = 1 - data[i++];\n\t        var x1 = Math.cos(theta) * rx + cx;\n\t        var y1 = Math.sin(theta) * ry + cy; //  arc \n\t\n\t        if (i > 1) {\n\t          w += windingLine(xi, yi, x1, y1, x, y);\n\t        } else {\n\t          // \n\t          x0 = x1;\n\t          y0 = y1;\n\t        } // zr scale, x\n\t\n\t\n\t        var _x = (x - cx) * ry / rx + cx;\n\t\n\t        if (isStroke) {\n\t          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t        }\n\t\n\t        xi = Math.cos(theta + dTheta) * rx + cx;\n\t        yi = Math.sin(theta + dTheta) * ry + cy;\n\t        break;\n\t\n\t      case CMD.R:\n\t        x0 = xi = data[i++];\n\t        y0 = yi = data[i++];\n\t        var width = data[i++];\n\t        var height = data[i++];\n\t        var x1 = x0 + width;\n\t        var y1 = y0 + height;\n\t\n\t        if (isStroke) {\n\t          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // FIXME Clockwise ?\n\t          w += windingLine(x1, y0, x1, y1, x, y);\n\t          w += windingLine(x0, y1, x0, y0, x, y);\n\t        }\n\t\n\t        break;\n\t\n\t      case CMD.Z:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // Close a subpath\n\t          w += windingLine(xi, yi, x0, y0, x, y); //  subpath \n\t          // FIXME subpaths may overlap\n\t          // if (w !== 0) {\n\t          //     return true;\n\t          // }\n\t        }\n\t\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!isStroke && !isAroundEqual(yi, y0)) {\n\t    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t  }\n\t\n\t  return w !== 0;\n\t}\n\t\n\tfunction contain(pathData, x, y) {\n\t  return containPath(pathData, 0, false, x, y);\n\t}\n\t\n\tfunction containStroke(pathData, lineWidth, x, y) {\n\t  return containPath(pathData, lineWidth, true, x, y);\n\t}\n\t\n\texports.contain = contain;\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * \n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  var _a = 0;\n\t  var _b = x0; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t    return false;\n\t  }\n\t\n\t  if (x0 !== x1) {\n\t    _a = (y0 - y1) / (x0 - x1);\n\t    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t  } else {\n\t    return Math.abs(x - x0) <= _l / 2;\n\t  }\n\t\n\t  var tmp = _a * x - y + _b;\n\t\n\t  var _s = tmp * tmp / (_a * _a + 1);\n\t\n\t  return _s <= _l / 2 * _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(49);\n\t\n\t/**\n\t * \n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  x3\n\t * @param  {number}  y3\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _curve = __webpack_require__(49);\n\t\n\tvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\t\n\t/**\n\t * \n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(56);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\tvar PI2 = Math.PI * 2;\n\t/**\n\t * \n\t * @param  {number}  cx\n\t * @param  {number}  cy\n\t * @param  {number}  r\n\t * @param  {number}  startAngle\n\t * @param  {number}  endAngle\n\t * @param  {boolean}  anticlockwise\n\t * @param  {number} lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {Boolean}\n\t */\n\t\n\tfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  x -= cx;\n\t  y -= cy;\n\t  var d = Math.sqrt(x * x + y * y);\n\t\n\t  if (d - _l > r || d + _l < r) {\n\t    return false;\n\t  }\n\t\n\t  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t    // Is a circle\n\t    return true;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var angle = Math.atan2(y, x);\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\n\tvar PI2 = Math.PI * 2;\n\t\n\tfunction normalizeRadian(angle) {\n\t  angle %= PI2;\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle;\n\t}\n\t\n\texports.normalizeRadian = normalizeRadian;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\n\tfunction windingLine(x0, y0, x1, y1, x, y) {\n\t  if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t    return 0;\n\t  } // Ignore horizontal line\n\t\n\t\n\t  if (y1 === y0) {\n\t    return 0;\n\t  }\n\t\n\t  var dir = y1 < y0 ? 1 : -1;\n\t  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t  if (t === 1 || t === 0) {\n\t    dir = y1 < y0 ? 0.5 : -0.5;\n\t  }\n\t\n\t  var x_ = t * (x1 - x0) + x0;\n\t  return x_ > x ? dir : 0;\n\t}\n\t\n\tmodule.exports = windingLine;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2ApplyTransform = _vector.applyTransform;\n\tvar CMD = PathProxy.CMD;\n\tvar points = [[], [], []];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAtan2 = Math.atan2;\n\t\n\tfunction _default(path, m) {\n\t  var data = path.data;\n\t  var cmd;\n\t  var nPoint;\n\t  var i;\n\t  var j;\n\t  var k;\n\t  var p;\n\t  var M = CMD.M;\n\t  var C = CMD.C;\n\t  var L = CMD.L;\n\t  var R = CMD.R;\n\t  var A = CMD.A;\n\t  var Q = CMD.Q;\n\t\n\t  for (i = 0, j = 0; i < data.length;) {\n\t    cmd = data[i++];\n\t    j = i;\n\t    nPoint = 0;\n\t\n\t    switch (cmd) {\n\t      case M:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case L:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case C:\n\t        nPoint = 3;\n\t        break;\n\t\n\t      case Q:\n\t        nPoint = 2;\n\t        break;\n\t\n\t      case A:\n\t        var x = m[4];\n\t        var y = m[5];\n\t        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\t\n\t        data[i] *= sx;\n\t        data[i++] += x; // cy\n\t\n\t        data[i] *= sy;\n\t        data[i++] += y; // Scale rx and ry\n\t        // FIXME Assume psi is 0 here\n\t\n\t        data[i++] *= sx;\n\t        data[i++] *= sy; // Start angle\n\t\n\t        data[i++] += angle; // end angle\n\t\n\t        data[i++] += angle; // FIXME psi\n\t\n\t        i += 2;\n\t        j = i;\n\t        break;\n\t\n\t      case R:\n\t        // x0, y0\n\t        p[0] = data[i++];\n\t        p[1] = data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1]; // x1, y1\n\t\n\t        p[0] += data[i++];\n\t        p[1] += data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1];\n\t    }\n\t\n\t    for (k = 0; k < nPoint; k++) {\n\t      var p = points[k];\n\t      p[0] = data[i++];\n\t      p[1] = data[i++];\n\t      v2ApplyTransform(p, p, m); // Write back\n\t\n\t      data[j++] = p[0];\n\t      data[j++] = p[1];\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Array.<Object>} colorStops\n\t */\n\tvar Gradient = function (colorStops) {\n\t  this.colorStops = colorStops || [];\n\t};\n\t\n\tGradient.prototype = {\n\t  constructor: Gradient,\n\t  addColorStop: function (offset, color) {\n\t    this.colorStops.push({\n\t      offset: offset,\n\t      color: color\n\t    });\n\t  }\n\t};\n\tvar _default = Gradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar textHelper = __webpack_require__(34);\n\t\n\t/**\n\t * @alias zrender/graphic/Text\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tvar Text = function (opts) {\n\t  // jshint ignore:line\n\t  Displayable.call(this, opts);\n\t};\n\t\n\tText.prototype = {\n\t  constructor: Text,\n\t  type: 'text',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\t\n\t    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += ''); // Always bind style\n\t\n\t    style.bind(ctx, this, prevEl);\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    }\n\t\n\t    this.setTransform(ctx);\n\t    textHelper.renderText(this, ctx, text, style);\n\t    this.restoreTransform(ctx);\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t    if (!this._rect) {\n\t      var text = style.text;\n\t      text != null ? text += '' : text = '';\n\t      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n\t      rect.x += style.x || 0;\n\t      rect.y += style.y || 0;\n\t\n\t      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n\t        var w = style.textStrokeWidth;\n\t        rect.x -= w / 2;\n\t        rect.y -= w / 2;\n\t        rect.width += w;\n\t        rect.height += w;\n\t      }\n\t\n\t      this._rect = rect;\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(Text, Displayable);\n\tvar _default = Text;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\tvar _default = Path.extend({\n\t  type: 'circle',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0\n\t  },\n\t  buildPath: function (ctx, shape, inBundle) {\n\t    // Better stroking in ShapeBundle\n\t    // Always do it may have performence issue ( fill may be 2x more cost)\n\t    if (inBundle) {\n\t      ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t    } // else {\n\t    //     if (ctx.allocate && !ctx.data.length) {\n\t    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n\t    //     }\n\t    // }\n\t    // Better stroking in ShapeBundle\n\t    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t\n\t\n\t    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar fixClipWithShadow = __webpack_require__(63);\n\t\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\tvar _default = Path.extend({\n\t  type: 'sector',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r0: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  brush: fixClipWithShadow(Path.prototype.brush),\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r0 = Math.max(shape.r0 || 0, 0);\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t    ctx.lineTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t\n\t    if (r0 !== 0) {\n\t      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\t// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n\t// where exception \"unexpected call to method or property access\"\n\t// might be thrown when calling ctx.fill or ctx.stroke after a path\n\t// whose area size is zero is drawn and ctx.clip() is called and\n\t// shadowBlur is set. See #4572, #3112, #5777.\n\t// (e.g.,\n\t//  ctx.moveTo(10, 10);\n\t//  ctx.lineTo(20, 10);\n\t//  ctx.closePath();\n\t//  ctx.clip();\n\t//  ctx.shadowBlur = 10;\n\t//  ...\n\t//  ctx.fill();\n\t// )\n\tvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\t\n\tfunction _default(orignalBrush) {\n\t  // version string can be: '11.0'\n\t  return env.browser.ie && env.browser.version >= 11 ? function () {\n\t    var clipPaths = this.__clipPaths;\n\t    var style = this.style;\n\t    var modified;\n\t\n\t    if (clipPaths) {\n\t      for (var i = 0; i < clipPaths.length; i++) {\n\t        var clipPath = clipPaths[i];\n\t        var shape = clipPath && clipPath.shape;\n\t        var type = clipPath && clipPath.type;\n\t\n\t        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n\t          for (var j = 0; j < shadowTemp.length; j++) {\n\t            // It is save to put shadowTemp static, because shadowTemp\n\t            // will be all modified each item brush called.\n\t            shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t            style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t          }\n\t\n\t          modified = true;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    orignalBrush.apply(this, arguments);\n\t\n\t    if (modified) {\n\t      for (var j = 0; j < shadowTemp.length; j++) {\n\t        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t      }\n\t    }\n\t  } : orignalBrush;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\tvar _default = Path.extend({\n\t  type: 'ring',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    r0: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var PI2 = Math.PI * 2;\n\t    ctx.moveTo(x + shape.r, y);\n\t    ctx.arc(x, y, shape.r, 0, PI2, false);\n\t    ctx.moveTo(x + shape.r0, y);\n\t    ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar polyHelper = __webpack_require__(66);\n\t\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polygon',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar smoothSpline = __webpack_require__(67);\n\t\n\tvar smoothBezier = __webpack_require__(68);\n\t\n\tfunction buildPath(ctx, shape, closePath) {\n\t  var points = shape.points;\n\t  var smooth = shape.smooth;\n\t\n\t  if (points && points.length >= 2) {\n\t    if (smooth && smooth !== 'spline') {\n\t      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t      var len = points.length;\n\t\n\t      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t        var cp1 = controlPoints[i * 2];\n\t        var cp2 = controlPoints[i * 2 + 1];\n\t        var p = points[(i + 1) % len];\n\t        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t      }\n\t    } else {\n\t      if (smooth === 'spline') {\n\t        points = smoothSpline(points, closePath);\n\t      }\n\t\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t\n\t      for (var i = 1, l = points.length; i < l; i++) {\n\t        ctx.lineTo(points[i][0], points[i][1]);\n\t      }\n\t    }\n\t\n\t    closePath && ctx.closePath();\n\t  }\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Distance = _vector.distance;\n\t\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * @inner\n\t */\n\tfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t/**\n\t * @alias module:zrender/shape/util/smoothSpline\n\t * @param {Array} points \n\t * @param {boolean} isLoop\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction _default(points, isLoop) {\n\t  var len = points.length;\n\t  var ret = [];\n\t  var distance = 0;\n\t\n\t  for (var i = 1; i < len; i++) {\n\t    distance += v2Distance(points[i - 1], points[i]);\n\t  }\n\t\n\t  var segs = distance / 2;\n\t  segs = segs < len ? len : segs;\n\t\n\t  for (var i = 0; i < segs; i++) {\n\t    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t    var idx = Math.floor(pos);\n\t    var w = pos - idx;\n\t    var p0;\n\t    var p1 = points[idx % len];\n\t    var p2;\n\t    var p3;\n\t\n\t    if (!isLoop) {\n\t      p0 = points[idx === 0 ? idx : idx - 1];\n\t      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t    } else {\n\t      p0 = points[(idx - 1 + len) % len];\n\t      p2 = points[(idx + 1) % len];\n\t      p3 = points[(idx + 2) % len];\n\t    }\n\t\n\t    var w2 = w * w;\n\t    var w3 = w * w2;\n\t    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Min = _vector.min;\n\tvar v2Max = _vector.max;\n\tvar v2Scale = _vector.scale;\n\tvar v2Distance = _vector.distance;\n\tvar v2Add = _vector.add;\n\tvar v2Clone = _vector.clone;\n\tvar v2Sub = _vector.sub;\n\t\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * \n\t * @alias module:zrender/shape/util/smoothBezier\n\t * @param {Array} points \n\t * @param {number} smooth , 0-1\n\t * @param {boolean} isLoop\n\t * @param {Array} constraint \n\t *                            [[0, 0], [100, 100]], \n\t *                           \n\t * @param {Array} \n\t */\n\tfunction _default(points, smooth, isLoop, constraint) {\n\t  var cps = [];\n\t  var v = [];\n\t  var v1 = [];\n\t  var v2 = [];\n\t  var prevPoint;\n\t  var nextPoint;\n\t  var min, max;\n\t\n\t  if (constraint) {\n\t    min = [Infinity, Infinity];\n\t    max = [-Infinity, -Infinity];\n\t\n\t    for (var i = 0, len = points.length; i < len; i++) {\n\t      v2Min(min, min, points[i]);\n\t      v2Max(max, max, points[i]);\n\t    } // \n\t\n\t\n\t    v2Min(min, min, constraint[0]);\n\t    v2Max(max, max, constraint[1]);\n\t  }\n\t\n\t  for (var i = 0, len = points.length; i < len; i++) {\n\t    var point = points[i];\n\t\n\t    if (isLoop) {\n\t      prevPoint = points[i ? i - 1 : len - 1];\n\t      nextPoint = points[(i + 1) % len];\n\t    } else {\n\t      if (i === 0 || i === len - 1) {\n\t        cps.push(v2Clone(points[i]));\n\t        continue;\n\t      } else {\n\t        prevPoint = points[i - 1];\n\t        nextPoint = points[i + 1];\n\t      }\n\t    }\n\t\n\t    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\t\n\t    v2Scale(v, v, smooth);\n\t    var d0 = v2Distance(point, prevPoint);\n\t    var d1 = v2Distance(point, nextPoint);\n\t    var sum = d0 + d1;\n\t\n\t    if (sum !== 0) {\n\t      d0 /= sum;\n\t      d1 /= sum;\n\t    }\n\t\n\t    v2Scale(v1, v, -d0);\n\t    v2Scale(v2, v, d1);\n\t    var cp0 = v2Add([], point, v1);\n\t    var cp1 = v2Add([], point, v2);\n\t\n\t    if (constraint) {\n\t      v2Max(cp0, cp0, min);\n\t      v2Min(cp0, cp0, max);\n\t      v2Max(cp1, cp1, min);\n\t      v2Min(cp1, cp1, max);\n\t    }\n\t\n\t    cps.push(cp0);\n\t    cps.push(cp1);\n\t  }\n\t\n\t  if (isLoop) {\n\t    cps.push(cps.shift());\n\t  }\n\t\n\t  return cps;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar polyHelper = __webpack_require__(66);\n\t\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polyline',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, false);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar roundRectHelper = __webpack_require__(37);\n\t\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\tvar _default = Path.extend({\n\t  type: 'rect',\n\t  shape: {\n\t    // r1r2r3r4\n\t    // r1          [1, 1, 1, 1]\n\t    // r[1]        [1, 1, 1, 1]\n\t    // r[1, 2]     [1, 2, 1, 2]\n\t    // r[1, 2, 3]  [1, 2, 3, 2]\n\t    r: 0,\n\t    x: 0,\n\t    y: 0,\n\t    width: 0,\n\t    height: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.x;\n\t    var y = shape.y;\n\t    var width = shape.width;\n\t    var height = shape.height;\n\t\n\t    if (!shape.r) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, shape);\n\t    }\n\t\n\t    ctx.closePath();\n\t    return;\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\tvar _default = Path.extend({\n\t  type: 'line',\n\t  shape: {\n\t    // Start point\n\t    x1: 0,\n\t    y1: 0,\n\t    // End point\n\t    x2: 0,\n\t    y2: 0,\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (percent < 1) {\n\t      x2 = x1 * (1 - percent) + x2 * percent;\n\t      y2 = y1 * (1 - percent) + y2 * percent;\n\t    }\n\t\n\t    ctx.lineTo(x2, y2);\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} percent\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (p) {\n\t    var shape = this.shape;\n\t    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar _curve = __webpack_require__(49);\n\t\n\tvar quadraticSubdivide = _curve.quadraticSubdivide;\n\tvar cubicSubdivide = _curve.cubicSubdivide;\n\tvar quadraticAt = _curve.quadraticAt;\n\tvar cubicAt = _curve.cubicAt;\n\tvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\n\tvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\t\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\tvar out = [];\n\t\n\tfunction someVectorAt(shape, t, isTangent) {\n\t  var cpx2 = shape.cpx2;\n\t  var cpy2 = shape.cpy2;\n\t\n\t  if (cpx2 === null || cpy2 === null) {\n\t    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n\t  } else {\n\t    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n\t  }\n\t}\n\t\n\tvar _default = Path.extend({\n\t  type: 'bezier-curve',\n\t  shape: {\n\t    x1: 0,\n\t    y1: 0,\n\t    x2: 0,\n\t    y2: 0,\n\t    cpx1: 0,\n\t    cpy1: 0,\n\t    // cpx2: 0,\n\t    // cpy2: 0\n\t    // Curve show percent, for animating\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var cpx1 = shape.cpx1;\n\t    var cpy1 = shape.cpy1;\n\t    var cpx2 = shape.cpx2;\n\t    var cpy2 = shape.cpy2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (cpx2 == null || cpy2 == null) {\n\t      if (percent < 1) {\n\t        quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t        cpx1 = out[1];\n\t        x2 = out[2];\n\t        quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t        cpy1 = out[1];\n\t        y2 = out[2];\n\t      }\n\t\n\t      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t    } else {\n\t      if (percent < 1) {\n\t        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t        cpx1 = out[1];\n\t        cpx2 = out[2];\n\t        x2 = out[3];\n\t        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t        cpy1 = out[1];\n\t        cpy2 = out[2];\n\t        y2 = out[3];\n\t      }\n\t\n\t      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (t) {\n\t    return someVectorAt(this.shape, t, false);\n\t  },\n\t\n\t  /**\n\t   * Get tangent at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  tangentAt: function (t) {\n\t    var p = someVectorAt(this.shape, t, true);\n\t    return vec2.normalize(p, p);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\tvar _default = Path.extend({\n\t  type: 'arc',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\t/**\n\t * x, y, x2, y2 are all percent from 0 to 1\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @param {number} [x2=1]\n\t * @param {number} [y2=0]\n\t * @param {Array.<Object>} colorStops\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'linear', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0 : x;\n\t  this.y = y == null ? 0 : y;\n\t  this.x2 = x2 == null ? 1 : x2;\n\t  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\t\n\t  this.type = 'linear'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tLinearGradient.prototype = {\n\t  constructor: LinearGradient\n\t};\n\tzrUtil.inherits(LinearGradient, Gradient);\n\tvar _default = LinearGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\t/**\n\t * x, y, r are all percent from 0 to 1\n\t * @param {number} [x=0.5]\n\t * @param {number} [y=0.5]\n\t * @param {number} [r=0.5]\n\t * @param {Array.<Object>} [colorStops]\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'radial', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0.5 : x;\n\t  this.y = y == null ? 0.5 : y;\n\t  this.r = r == null ? 0.5 : r; // Can be cloned\n\t\n\t  this.type = 'radial'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tRadialGradient.prototype = {\n\t  constructor: RadialGradient\n\t};\n\tzrUtil.inherits(RadialGradient, Gradient);\n\tvar _default = RadialGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar vec2Copy = _vector.copy;\n\t\n\t/**\n\t * States machine for managing graphic states\n\t */\n\t\n\t/**\n\t * @typedef {Object} IGraphicState\n\t * @property {number} [zlevel]\n\t * @property {number} [z]\n\t * @property {Array.<number>} {position}\n\t * @property {Array.<number>|number} {rotation}\n\t * @property {Array.<number>} {scale}\n\t * @property {Object} style\n\t *\n\t * @property {Function} onenter\n\t * @property {Function} onleave\n\t * @property {Function} ontransition\n\t * @property {Array.<IGraphicStateTransition|string>} transition\n\t *           Transition object or a string descriptor like '* 30 0 Linear'\n\t */\n\tvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n\t/**\n\t * @module zrender/graphic/States~TransitionObject\n\t */\n\t\n\tvar TransitionObject = function (opts) {\n\t  if (typeof opts == 'string') {\n\t    this._fromStr(opts);\n\t  } else if (opts) {\n\t    opts.property && (this.property = opts.property);\n\t    opts.duration != null && (this.duration = opts.duration);\n\t    opts.easing && (this.easing = opts.easing);\n\t    opts.delay && (this.delay = opts.delay);\n\t  }\n\t\n\t  if (this.property !== '*') {\n\t    this.property = this.property.split(',');\n\t  } else {\n\t    this.property = transitionProperties;\n\t  }\n\t};\n\t\n\tTransitionObject.prototype = {\n\t  constructor: TransitionObject,\n\t\n\t  /**\n\t   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n\t   * e.g. 'position,style.color'. '*' will match all the valid properties.\n\t   * @type {string}\n\t   * @default *\n\t   */\n\t  property: '*',\n\t\n\t  /**\n\t   * @type {string}\n\t   * @default 'Linear'\n\t   */\n\t  easing: 'Linear',\n\t\n\t  /**\n\t   * @type {number}\n\t   * @default 'number'\n\t   */\n\t  duration: 500,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  delay: 0,\n\t  _fromStr: function (str) {\n\t    var arr = str.split(/\\s+/g);\n\t    this.property = arr[0];\n\t    this.duration = +arr[1];\n\t    this.delay = +arr[2];\n\t    this.easing = arr[3];\n\t  }\n\t};\n\t/**\n\t * @alias module:zrender/graphic/States\n\t */\n\t\n\tvar GraphicStates = function (opts) {\n\t  opts = opts || {};\n\t  this._states = {};\n\t  /**\n\t   * Target element\n\t   * @type {zrender/graphic/Displayable|zrender/container/Group}\n\t   */\n\t\n\t  this._el = opts.el;\n\t  this._subStates = [];\n\t  this._transitionAnimators = [];\n\t\n\t  if (opts.initialState) {\n\t    this._initialState = opts.initialState;\n\t  }\n\t\n\t  var optsStates = opts.states;\n\t\n\t  if (optsStates) {\n\t    for (var name in optsStates) {\n\t      if (optsStates.hasOwnProperty(name)) {\n\t        var state = optsStates[name];\n\t\n\t        this._addState(name, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  this.setState(this._initialState);\n\t};\n\t\n\tGraphicStates.prototype = {\n\t  constructor: GraphicStates,\n\t\n\t  /**\n\t   * All other state will be extended from initial state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _initialState: 'normal',\n\t\n\t  /**\n\t   * Current state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _currentState: '',\n\t  el: function () {\n\t    return this._el;\n\t  },\n\t  _addState: function (name, state) {\n\t    this._states[name] = state;\n\t\n\t    if (state.transition) {\n\t      state.transition = new TransitionObject(state.transition);\n\t    } // Extend from initial state\n\t\n\t\n\t    if (name !== this._initialState) {\n\t      this._extendFromInitial(state);\n\t    } else {\n\t      var el = this._el; // setState  style  shape \n\t      //  style  shape \n\t\n\t      zrUtil.merge(state.style, el.style, false, false);\n\t\n\t      if (state.shape) {\n\t        zrUtil.merge(state.shape, el.shape, false, true);\n\t      } else {\n\t        state.shape = zrUtil.clone(el.shape, true);\n\t      }\n\t\n\t      for (var name in this._states) {\n\t        if (this._states.hasOwnProperty(name)) {\n\t          this._extendFromInitial(this._states[name]);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _extendFromInitial: function (state) {\n\t    var initialState = this._states[this._initialState];\n\t\n\t    if (initialState && state !== initialState) {\n\t      zrUtil.merge(state, initialState, false, true);\n\t    }\n\t  },\n\t  setState: function (name, silent) {\n\t    if (name === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[name];\n\t\n\t    if (state) {\n\t      this._stopTransition();\n\t\n\t      if (!silent) {\n\t        var prevState = this._states[this._currentState];\n\t\n\t        if (prevState) {\n\t          prevState.onleave && prevState.onleave.call(this);\n\t        }\n\t\n\t        state.onenter && state.onenter.call(this);\n\t      }\n\t\n\t      this._currentState = name;\n\t\n\t      if (this._el) {\n\t        var el = this._el; // Setting attributes\n\t\n\t        if (state.zlevel != null) {\n\t          el.zlevel = state.zlevel;\n\t        }\n\t\n\t        if (state.z != null) {\n\t          el.z = state.z;\n\t        } // SRT\n\t\n\t\n\t        state.position && vec2Copy(el.position, state.position);\n\t        state.scale && vec2Copy(el.scale, state.scale);\n\t\n\t        if (state.rotation != null) {\n\t          el.rotation = state.rotation;\n\t        } // Style\n\t\n\t\n\t        if (state.style) {\n\t          var initialState = this._states[this._initialState];\n\t          el.style = new Style();\n\t\n\t          if (initialState) {\n\t            el.style.extendFrom(initialState.style, false);\n\t          }\n\t\n\t          if ( // Not initial state\n\t          name != this._initialState // Not copied from initial state in _extendFromInitial method\n\t          && initialState.style !== state.style) {\n\t            el.style.extendFrom(state.style, true);\n\t          }\n\t        }\n\t\n\t        if (state.shape) {\n\t          el.shape = zrUtil.clone(state.shape, true);\n\t        }\n\t\n\t        el.dirty();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < this._subStates.length; i++) {\n\t      this._subStates.setState(name);\n\t    }\n\t  },\n\t  getState: function () {\n\t    return this._currentState;\n\t  },\n\t  transitionState: function (target, done) {\n\t    if (target === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[target];\n\t    var styleShapeReg = /$[style|shape]\\./;\n\t    var self = this; // Animation \n\t\n\t    var propPathMap = {};\n\t\n\t    if (state) {\n\t      self._stopTransition();\n\t\n\t      var el = self._el;\n\t\n\t      if (state.transition && el && el.__zr) {\n\t        // El can be animated\n\t        var transitionCfg = state.transition;\n\t        var property = transitionCfg.property;\n\t        var animatingCount = 0;\n\t\n\t        var animationDone = function () {\n\t          animatingCount--;\n\t\n\t          if (animatingCount === 0) {\n\t            self.setState(target);\n\t            done && done();\n\t          }\n\t        };\n\t\n\t        for (var i = 0; i < property.length; i++) {\n\t          var propName = property[i]; // Animating all the properties in style or shape\n\t\n\t          if (propName === 'style' || propName === 'shape') {\n\t            if (state[propName]) {\n\t              for (var key in state[propName]) {\n\t                if (!state[propName].hasOwnProperty(key)) {\n\t                  continue;\n\t                }\n\t\n\t                var path = propName + '.' + key;\n\t\n\t                if (propPathMap[path]) {\n\t                  continue;\n\t                }\n\t\n\t                propPathMap[path] = 1;\n\t                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n\t              }\n\t            }\n\t          } else {\n\t            if (propPathMap[propName]) {\n\t              continue;\n\t            }\n\t\n\t            propPathMap[propName] = 1; // Animating particular property in style or style\n\t\n\t            if (propName.match(styleShapeReg)) {\n\t              // remove 'style.', 'shape.' prefix\n\t              var subProp = propName.slice(0, 5);\n\t              propName = propName.slice(6);\n\t              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n\t            } else {\n\t              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n\t            }\n\t          }\n\t        } // No transition properties\n\t\n\t\n\t        if (animatingCount === 0) {\n\t          self.setState(target);\n\t          done && done();\n\t        }\n\t      } else {\n\t        self.setState(target);\n\t        done && done();\n\t      }\n\t    }\n\t\n\t    var subStates = self._subStates;\n\t\n\t    for (var i = 0; i < subStates.length; i++) {\n\t      subStates.transitionState(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Do transition animation of particular property\n\t   * @param {Object} state\n\t   * @param {string} subPropKey\n\t   * @param {string} key\n\t   * @param {Object} transitionCfg\n\t   * @param {Function} done\n\t   * @private\n\t   */\n\t  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n\t    var el = this._el;\n\t    var stateObj = subPropKey ? state[subPropKey] : state;\n\t    var elObj = subPropKey ? el[subPropKey] : el;\n\t    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    if (availableProp) {\n\t      var obj = {};\n\t\n\t      if (stateObj[key] === elObj[key]) {\n\t        return 0;\n\t      }\n\t\n\t      obj[key] = stateObj[key];\n\t      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n\t        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\t\n\t        if (idx > 0) {\n\t          transitionAnimators.splice(idx, 1);\n\t        }\n\t\n\t        done();\n\t      }).start(transitionCfg.easing);\n\t      transitionAnimators.push(animator);\n\t      return 1;\n\t    }\n\t\n\t    return 0;\n\t  },\n\t  _stopTransition: function () {\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    for (var i = 0; i < transitionAnimators.length; i++) {\n\t      transitionAnimators[i].stop();\n\t    }\n\t\n\t    transitionAnimators.length = 0;\n\t  },\n\t  transiting: function () {\n\t    return this._transitionAnimators.length > 0;\n\t  },\n\t  addSubStates: function (states) {\n\t    this._subStates.push(states);\n\t  },\n\t  removeSubStates: function (states) {\n\t    var idx = zrUtil.indexOf(this._subStates, states);\n\t\n\t    if (idx >= 0) {\n\t      this._subStates.splice(states, 1);\n\t    }\n\t  }\n\t};\n\tvar _default = GraphicStates;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * \r\n\t * @module fish-topo-bo/node/EventDecisionNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    function EventDecisionNode(data, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = data;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        this._type = opts.type || 'boEvent';\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._clickable = opts.clickable || false;\r\n\t        this._popupOpts = opts.popupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //BO\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var eventProto = EventDecisionNode.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    eventProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._render = function () {\r\n\t        //\r\n\t        this._createEventShape();\r\n\t        //\r\n\t        this._createEVentName();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEventShape = function () {\r\n\t\r\n\t        //\r\n\t        var height = Const.BO_EVENT_HEIGHT,\r\n\t            x = this._startPos.x + 1,\r\n\t            y = this._startPos.y,\r\n\t            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\t\r\n\t            shape = new graphic.Polygon({\r\n\t                name: this._data.id,\r\n\t                shape: {\r\n\t                    points: [\r\n\t                        [x, y],\r\n\t                        [x + width - 10, y],\r\n\t                        [x + width, y + height / 2],\r\n\t                        [x + width - 10, y + height],\r\n\t                        [x, y + height]]\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    fill: '#FFCCCC',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 0.75\r\n\t                }\r\n\t\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            shape.clickable = this._clickable;\r\n\t            shape._data = this._data;\r\n\t            shape._popupOpts = this._popupOpts;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._click = function () {\r\n\t        var options = Object.assign(\r\n\t            {\r\n\t                DATA: this._data\r\n\t            }, this._popupOpts);\r\n\t\r\n\t        nodeOptions.bindBoClickEvent(options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEVentName = function () {\r\n\t        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            eventNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_EVENT_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            eventNameShape.clickable = this._clickable;\r\n\t            eventNameShape._data = this._data;\r\n\t            eventNameShape._popupOpts = this._popupOpts;\r\n\t            eventNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(eventNameShape);\r\n\t    };\r\n\t\r\n\t    module.exports = EventDecisionNode;\r\n\t\r\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * @module fish-topo-bo/node/LineNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var util = __webpack_require__(6);\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\t\r\n\t        return _line(startPos, endPos);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BOBO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @param {int} attrHeight, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrEventLine(startPos, attrHeight) {\r\n\t        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @param {{x: *, y: *}} endPos, \r\n\t     * @param {Object} style, ,\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @private\r\n\t     */\r\n\t    function _line(startPos, endPos, style) {\r\n\t\r\n\t        var _style = {\r\n\t            strokeColor: '#000000',\r\n\t            lineWidth: 0.5,\r\n\t            percent: 1\r\n\t        };\r\n\t\r\n\t        util.extend(_style, style);\r\n\t\r\n\t        var shape = new graphic.Line({\r\n\t            shape: {\r\n\t                // Start point\r\n\t                x1: startPos.x,\r\n\t                y1: startPos.y,\r\n\t\r\n\t                // End point\r\n\t                x2: endPos.x,\r\n\t                y2: endPos.y,\r\n\t\r\n\t                percent: 1\r\n\t            },\r\n\t\r\n\t            style: _style\r\n\t        });\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        BoLine: BoLine,\r\n\t        AttrLine: AttrLine,\r\n\t        AttrEventLine: AttrEventLine\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * 1.BO\r\n\t * 2.BO\r\n\t * 3.BO\r\n\t * @module fish-topo-bo/node/BoAttrNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var EventDecision = __webpack_require__(77);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String bo,\r\n\t     *          code: String bo\r\n\t     *          keyValue: boolean ,\r\n\t     *          dataType: String ,\r\n\t     *          boAttrEventArr:[] \r\n\t     *          }} boAttrData BO,\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number},\r\n\t     *          displayDataType: boolean ,\r\n\t     *          displayEventDecision: boolean ,\r\n\t     *          eventClickable: boolean BO,  false,\r\n\t     *          eventPopupOpts: Object BOurl,width,height,\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoAttr(boAttrData, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boAttrData;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._keyValue = boAttrData.keyValue || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayDataType = opts.displayDataType || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayEventDecision = opts.displayEventDecision || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._eventClickable = opts.eventClickable || false;\r\n\t        this._eventPopupOpts = opts.eventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //BO\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var boAttrProto = BoAttr.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boAttrProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._render = function () {\r\n\t        //\r\n\t        this._createText();\r\n\t\r\n\t        //\r\n\t        this._createDataType();\r\n\t\r\n\t        //\r\n\t        this._createEventDecision();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createText = function () {\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            attrNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top',\r\n\t                    //lineWidth: 1,\r\n\t                    fill: this._keyValue ? 'red' : 'black'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        // =  + padding-top + padding-bottom\r\n\t        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n\t        // = BORelation\r\n\t        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\t\r\n\t        //B = \r\n\t        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n\t        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\t\r\n\t        this._group.add(attrNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createDataType = function () {\r\n\t        if (!this._displayDataType) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n\t            y = this._startPos.y,\r\n\t            textAlign = 'right';\r\n\t\r\n\t        //\r\n\t        if (this._displayEventDecision) {\r\n\t            textAlign = 'left';\r\n\t            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n\t        }\r\n\t\r\n\t        var _dataTypeShape = new graphic.Text({\r\n\t            style: {\r\n\t                text: this._data.dataType || '',\r\n\t                textFont: Const.BO_ATTR_FONT,\r\n\t                textAlign: textAlign,  //\r\n\t                textBaseline: 'top',\r\n\t                lineWidth: 1\r\n\t            },\r\n\t\r\n\t            position: [x, y]\r\n\t        });\r\n\t\r\n\t        this._group.add(_dataTypeShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createEventDecision = function () {\r\n\t        if (!this._displayEventDecision) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n\t            _boAttrEventLen = _boAttrEventArr.length,\r\n\t            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n\t            _startPos = {\r\n\t                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n\t                y: this._startPos.y\r\n\t            };\r\n\t\r\n\t        //\r\n\t        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n\t            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n\t                startPos: _startPos,\r\n\t                type: 'boAttrEvent',\r\n\t                clickable: this._eventClickable,\r\n\t                popupOpts: this._eventPopupOpts,\r\n\t                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t            }).getShape());\r\n\t            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n\t        }\r\n\t        /*_startPos = {\r\n\t         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n\t         y: this._startPos.y};\r\n\t\r\n\t         for (var i = 0; i < _boAttrEventLen; i++) {\r\n\t         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n\t         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n\t         }*/\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = BoAttr;\r\n\t\r\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * \r\n\t * \r\n\t * @module fish-topo-bo/node/Relation\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param sourceShape, \r\n\t     * @param targetShape, \r\n\t     * @param {String} sourceText, ,\r\n\t     * @param {String} targetText, ,\r\n\t     * @param {String} lineStyle, \r\n\t     * @param {String} lineHoverStyle, hover\r\n\t     * @param {String} arrowStyle, \r\n\t     * @param {String} arrowHoverStyle, hover\r\n\t     * @constructor\r\n\t     */\r\n\t    function Relation(sourceShape, targetShape, sourceText, targetText, lineStyle, lineHoverStyle, arrowStyle, arrowHoverStyle) {\r\n\t        this._sourceText = sourceText;\r\n\t        this._targetText = targetText;\r\n\t\r\n\t        this._group = new graphic.Group();\r\n\t\r\n\t        //\r\n\t        this._lStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._lEndPos = {\r\n\t            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._rStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._rEndPos = {\r\n\t            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\t\r\n\t        //\r\n\t        this._lineStyle = lineStyle;\r\n\t\r\n\t        //hover\r\n\t        this._lineHoverStyle = lineHoverStyle;\r\n\t\r\n\t        //\r\n\t        this._arrowStyle = arrowStyle;\r\n\t\r\n\t        //hover\r\n\t        this._arrowHoverStyle = arrowHoverStyle;\r\n\t\r\n\t        //\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var relationProto = Relation.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {*}\r\n\t     */\r\n\t    relationProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._render = function () {\r\n\t        //\r\n\t        this._createLine();\r\n\t\r\n\t        //\r\n\t        this._createArrow();\r\n\t\r\n\t        //\r\n\t        this._createText();\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createLine = function () {\r\n\t        var _linePoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t        }\r\n\t        else {\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t        }\r\n\t\r\n\t        var _lineShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _linePoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                //fill: 'blue',\r\n\t                stroke: this._lineStyle.stroke,\r\n\t                lineWidth: this._lineStyle.lineWidth,\r\n\t                lineDash: this._lineStyle.lineDash\r\n\t            }\r\n\t\r\n\t        });\r\n\t\r\n\t        this._group.add(_lineShape);\r\n\t\r\n\t        //hover\r\n\t        this._createHoverStyle(_lineShape, this._lineHoverStyle);\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createArrow = function () {\r\n\t        var _arrowPoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t        else {\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t\r\n\t        var _arrowShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _arrowPoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this._arrowStyle.fill,\r\n\t                stroke: this._arrowStyle.stroke\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_arrowShape);\r\n\t\r\n\t        //hover\r\n\t        this._createHoverStyle(_arrowShape, this._arrowHoverStyle);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createText = function () {\r\n\t        var _sourceTextPos,\r\n\t            _targetTextPos,\r\n\t            _textAlign;\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'right';\r\n\t        }\r\n\t        else {\r\n\t            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'left';\r\n\t        }\r\n\t\r\n\t        //\r\n\t        if (this._sourceText) {\r\n\t            var _srcTextShape = new graphic.Text({\r\n\t                position: _sourceTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._sourceText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_srcTextShape);\r\n\t        }\r\n\t\r\n\t        //\r\n\t        if (this._targetText) {\r\n\t            var _targetTextShape = new graphic.Text({\r\n\t                position: _targetTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._targetText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_targetTextShape);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * hover\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createHoverStyle = function (el, style) {\r\n\t        if (style) {\r\n\t            graphic.setElementHoverStl(el, style);\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                graphic.doEnterHover(el);\r\n\t                this._group.eachChild(function(line) {\r\n\t                    graphic.doEnterHover(line);\r\n\t                });\r\n\t            }, this))\r\n\t            .on('mouseout', zrUtil.bind(function() {\r\n\t                graphic.doLeaveHover(el);\r\n\t                this._group.eachChild(function(line) {\r\n\t                    graphic.doLeaveHover(line);\r\n\t                });\r\n\t            }, this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Relation;\r\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports) {\n\n\t\r\n\t    if (typeof Object.assign != 'function') {\r\n\t        // Must be writable: true, enumerable: false, configurable: true\r\n\t        Object.defineProperty(Object, \"assign\", {\r\n\t            value: function assign(target, varArgs) { // .length of function is 2\r\n\t                'use strict';\r\n\t                if (target == null) { // TypeError if undefined or null\r\n\t                    throw new TypeError('Cannot convert undefined or null to object');\r\n\t                }\r\n\t\r\n\t                var to = Object(target);\r\n\t\r\n\t                for (var index = 1; index < arguments.length; index++) {\r\n\t                    var nextSource = arguments[index];\r\n\t\r\n\t                    if (nextSource != null) { // Skip over if undefined or null\r\n\t                    for (var nextKey in nextSource) {\r\n\t                        // Avoid bugs when hasOwnProperty is shadowed\r\n\t                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n\t                        to[nextKey] = nextSource[nextKey];\r\n\t                        }\r\n\t                    }\r\n\t                    }\r\n\t                }\r\n\t                return to;\r\n\t            },\r\n\t            writable: true,\r\n\t            configurable: true\r\n\t        });\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(83);\n\t\n\tvar _zrender = __webpack_require__(3);\n\t\n\tvar registerPainter = _zrender.registerPainter;\n\t\n\tvar Painter = __webpack_require__(85);\n\t\n\tregisterPainter('vml', Painter);\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar applyTransform = _vector.applyTransform;\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar colorTool = __webpack_require__(20);\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar textHelper = __webpack_require__(34);\n\t\n\tvar RectText = __webpack_require__(33);\n\t\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar ZImage = __webpack_require__(31);\n\t\n\tvar Text = __webpack_require__(60);\n\t\n\tvar Path = __webpack_require__(47);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\tvar vmlCore = __webpack_require__(84);\n\t\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\tvar CMD = PathProxy.CMD;\n\tvar round = Math.round;\n\tvar sqrt = Math.sqrt;\n\tvar abs = Math.abs;\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar mathMax = Math.max;\n\t\n\tif (!env.canvasSupported) {\n\t  var comma = ',';\n\t  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t  var Z = 21600;\n\t  var Z2 = Z / 2;\n\t  var ZLEVEL_BASE = 100000;\n\t  var Z_BASE = 1000;\n\t\n\t  var initRootElStyle = function (el) {\n\t    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t    el.coordsize = Z + ',' + Z;\n\t    el.coordorigin = '0,0';\n\t  };\n\t\n\t  var encodeHtmlAttribute = function (s) {\n\t    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t  };\n\t\n\t  var rgb2Str = function (r, g, b) {\n\t    return 'rgb(' + [r, g, b].join(',') + ')';\n\t  };\n\t\n\t  var append = function (parent, child) {\n\t    if (child && parent && child.parentNode !== parent) {\n\t      parent.appendChild(child);\n\t    }\n\t  };\n\t\n\t  var remove = function (parent, child) {\n\t    if (child && parent && child.parentNode === parent) {\n\t      parent.removeChild(child);\n\t    }\n\t  };\n\t\n\t  var getZIndex = function (zlevel, z, z2) {\n\t    // z  [0, 1000]\n\t    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t  };\n\t\n\t  var parsePercent = function (value, maxValue) {\n\t    if (typeof value === 'string') {\n\t      if (value.lastIndexOf('%') >= 0) {\n\t        return parseFloat(value) / 100 * maxValue;\n\t      }\n\t\n\t      return parseFloat(value);\n\t    }\n\t\n\t    return value;\n\t  };\n\t  /***************************************************\n\t   * PATH\n\t   **************************************************/\n\t\n\t\n\t  var setColorAndOpacity = function (el, color, opacity) {\n\t    var colorArr = colorTool.parse(color);\n\t    opacity = +opacity;\n\t\n\t    if (isNaN(opacity)) {\n\t      opacity = 1;\n\t    }\n\t\n\t    if (colorArr) {\n\t      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t      el.opacity = opacity * colorArr[3];\n\t    }\n\t  };\n\t\n\t  var getColorAndAlpha = function (color) {\n\t    var colorArr = colorTool.parse(color);\n\t    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n\t  };\n\t\n\t  var updateFillNode = function (el, style, zrEl) {\n\t    // TODO pattern\n\t    var fill = style.fill;\n\t\n\t    if (fill != null) {\n\t      // Modified from excanvas\n\t      if (fill instanceof Gradient) {\n\t        var gradientType;\n\t        var angle = 0;\n\t        var focus = [0, 0]; // additional offset\n\t\n\t        var shift = 0; // scale factor for offset\n\t\n\t        var expansion = 1;\n\t        var rect = zrEl.getBoundingRect();\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t\n\t        if (fill.type === 'linear') {\n\t          gradientType = 'gradient';\n\t          var transform = zrEl.transform;\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t            applyTransform(p1, p1, transform);\n\t          }\n\t\n\t          var dx = p1[0] - p0[0];\n\t          var dy = p1[1] - p0[1];\n\t          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\t\n\t          if (angle < 0) {\n\t            angle += 360;\n\t          } // Very small angles produce an unexpected result because they are\n\t          // converted to a scientific notation string.\n\t\n\t\n\t          if (angle < 1e-6) {\n\t            angle = 0;\n\t          }\n\t        } else {\n\t          gradientType = 'gradientradial';\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var transform = zrEl.transform;\n\t          var scale = zrEl.scale;\n\t          var width = rectWidth;\n\t          var height = rectHeight;\n\t          focus = [// Percent in bounding rect\n\t          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t          }\n\t\n\t          width /= scale[0] * Z;\n\t          height /= scale[1] * Z;\n\t          var dimension = mathMax(width, height);\n\t          shift = 2 * 0 / dimension;\n\t          expansion = 2 * fill.r / dimension - shift;\n\t        } // We need to sort the color stops in ascending order by offset,\n\t        // otherwise IE won't interpret it correctly.\n\t\n\t\n\t        var stops = fill.colorStops.slice();\n\t        stops.sort(function (cs1, cs2) {\n\t          return cs1.offset - cs2.offset;\n\t        });\n\t        var length = stops.length; // Color and alpha list of first and last stop\n\t\n\t        var colorAndAlphaList = [];\n\t        var colors = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          var stop = stops[i];\n\t          var colorAndAlpha = getColorAndAlpha(stop.color);\n\t          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t\n\t          if (i === 0 || i === length - 1) {\n\t            colorAndAlphaList.push(colorAndAlpha);\n\t          }\n\t        }\n\t\n\t        if (length >= 2) {\n\t          var color1 = colorAndAlphaList[0][0];\n\t          var color2 = colorAndAlphaList[1][0];\n\t          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t          el.type = gradientType;\n\t          el.method = 'none';\n\t          el.focus = '100%';\n\t          el.angle = angle;\n\t          el.color = color1;\n\t          el.color2 = color2;\n\t          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n\t          // are reversed.\n\t\n\t          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\t\n\t          el.opacity2 = opacity1;\n\t        }\n\t\n\t        if (gradientType === 'radial') {\n\t          el.focusposition = focus.join(',');\n\t        }\n\t      } else {\n\t        // FIXME Change from Gradient fill to color fill\n\t        setColorAndOpacity(el, fill, style.opacity);\n\t      }\n\t    }\n\t  };\n\t\n\t  var updateStrokeNode = function (el, style) {\n\t    // if (style.lineJoin != null) {\n\t    //     el.joinstyle = style.lineJoin;\n\t    // }\n\t    // if (style.miterLimit != null) {\n\t    //     el.miterlimit = style.miterLimit * Z;\n\t    // }\n\t    // if (style.lineCap != null) {\n\t    //     el.endcap = style.lineCap;\n\t    // }\n\t    if (style.lineDash != null) {\n\t      el.dashstyle = style.lineDash.join(' ');\n\t    }\n\t\n\t    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t      setColorAndOpacity(el, style.stroke, style.opacity);\n\t    }\n\t  };\n\t\n\t  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t    var isFill = type == 'fill';\n\t    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\t\n\t    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\t\n\t      if (style[type] instanceof Gradient) {\n\t        remove(vmlEl, el);\n\t      }\n\t\n\t      if (!el) {\n\t        el = vmlCore.createNode(type);\n\t      }\n\t\n\t      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t      append(vmlEl, el);\n\t    } else {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t      remove(vmlEl, el);\n\t    }\n\t  };\n\t\n\t  var points = [[], [], []];\n\t\n\t  var pathDataToString = function (path, m) {\n\t    var M = CMD.M;\n\t    var C = CMD.C;\n\t    var L = CMD.L;\n\t    var A = CMD.A;\n\t    var Q = CMD.Q;\n\t    var str = [];\n\t    var nPoint;\n\t    var cmdStr;\n\t    var cmd;\n\t    var i;\n\t    var xi;\n\t    var yi;\n\t    var data = path.data;\n\t    var dataLength = path.len();\n\t\n\t    for (i = 0; i < dataLength;) {\n\t      cmd = data[i++];\n\t      cmdStr = '';\n\t      nPoint = 0;\n\t\n\t      switch (cmd) {\n\t        case M:\n\t          cmdStr = ' m ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case L:\n\t          cmdStr = ' l ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case Q:\n\t        case C:\n\t          cmdStr = ' c ';\n\t          nPoint = 3;\n\t          var x1 = data[i++];\n\t          var y1 = data[i++];\n\t          var x2 = data[i++];\n\t          var y2 = data[i++];\n\t          var x3;\n\t          var y3;\n\t\n\t          if (cmd === Q) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            x3 = x2;\n\t            y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (xi + 2 * x1) / 3;\n\t            y1 = (yi + 2 * y1) / 3;\n\t          } else {\n\t            x3 = data[i++];\n\t            y3 = data[i++];\n\t          }\n\t\n\t          points[0][0] = x1;\n\t          points[0][1] = y1;\n\t          points[1][0] = x2;\n\t          points[1][1] = y2;\n\t          points[2][0] = x3;\n\t          points[2][1] = y3;\n\t          xi = x3;\n\t          yi = y3;\n\t          break;\n\t\n\t        case A:\n\t          var x = 0;\n\t          var y = 0;\n\t          var sx = 1;\n\t          var sy = 1;\n\t          var angle = 0;\n\t\n\t          if (m) {\n\t            // Extract SRT from matrix\n\t            x = m[4];\n\t            y = m[5];\n\t            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t          }\n\t\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++] + angle;\n\t          var endAngle = data[i++] + startAngle + angle; // FIXME\n\t          // var psi = data[i++];\n\t\n\t          i++;\n\t          var clockwise = data[i++];\n\t          var x0 = cx + cos(startAngle) * rx;\n\t          var y0 = cy + sin(startAngle) * ry;\n\t          var x1 = cx + cos(endAngle) * rx;\n\t          var y1 = cy + sin(endAngle) * ry;\n\t          var type = clockwise ? ' wa ' : ' at ';\n\t\n\t          if (Math.abs(x0 - x1) < 1e-4) {\n\t            // IE won't render arches drawn counter clockwise if x0 == x1.\n\t            if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t              // Offset x0 by 1/80 of a pixel. Use something\n\t              // that can be represented in binary\n\t              if (clockwise) {\n\t                x0 += 270 / Z;\n\t              }\n\t            } else {\n\t              // Avoid case draw full circle\n\t              if (Math.abs(y0 - cy) < 1e-4) {\n\t                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n\t                  y1 -= 270 / Z;\n\t                } else {\n\t                  y1 += 270 / Z;\n\t                }\n\t              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n\t                x1 += 270 / Z;\n\t              } else {\n\t                x1 -= 270 / Z;\n\t              }\n\t            }\n\t          }\n\t\n\t          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n\t          xi = x1;\n\t          yi = y1;\n\t          break;\n\t\n\t        case CMD.R:\n\t          var p0 = points[0];\n\t          var p1 = points[1]; // x0, y0\n\t\n\t          p0[0] = data[i++];\n\t          p0[1] = data[i++]; // x1, y1\n\t\n\t          p1[0] = p0[0] + data[i++];\n\t          p1[1] = p0[1] + data[i++];\n\t\n\t          if (m) {\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t          }\n\t\n\t          p0[0] = round(p0[0] * Z - Z2);\n\t          p1[0] = round(p1[0] * Z - Z2);\n\t          p0[1] = round(p0[1] * Z - Z2);\n\t          p1[1] = round(p1[1] * Z - Z2);\n\t          str.push( // x0, y0\n\t          ' m ', p0[0], comma, p0[1], // x1, y0\n\t          ' l ', p1[0], comma, p0[1], // x1, y1\n\t          ' l ', p1[0], comma, p1[1], // x0, y1\n\t          ' l ', p0[0], comma, p1[1]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          // FIXME Update xi, yi\n\t          str.push(' x ');\n\t      }\n\t\n\t      if (nPoint > 0) {\n\t        str.push(cmdStr);\n\t\n\t        for (var k = 0; k < nPoint; k++) {\n\t          var p = points[k];\n\t          m && applyTransform(p, p, m); //  round \n\t\n\t          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n\t        }\n\t      }\n\t    }\n\t\n\t    return str.join('');\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  Path.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      vmlEl = vmlCore.createNode('shape');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    updateFillAndStroke(vmlEl, 'fill', style, this);\n\t    updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t    var m = this.transform;\n\t    var needTransform = m != null;\n\t    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t\n\t    if (strokeEl) {\n\t      var lineWidth = style.lineWidth; // Get the line scale.\n\t      // Determinant of this.m_ means how much the area is enlarged by the\n\t      // transformation. So its square root can be used as a scale factor\n\t      // for width.\n\t\n\t      if (needTransform && !style.strokeNoScale) {\n\t        var det = m[0] * m[3] - m[1] * m[2];\n\t        lineWidth *= sqrt(abs(det));\n\t      }\n\t\n\t      strokeEl.weight = lineWidth + 'px';\n\t    }\n\t\n\t    var path = this.path || (this.path = new PathProxy());\n\t\n\t    if (this.__dirtyPath) {\n\t      path.beginPath();\n\t      this.buildPath(path, this.shape);\n\t      path.toStatic();\n\t      this.__dirtyPath = false;\n\t    }\n\t\n\t    vmlEl.path = pathDataToString(path, this.transform);\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Path.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Path.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * IMAGE\n\t   **************************************************/\n\t\n\t\n\t  var isImage = function (img) {\n\t    // FIXME img instanceof Image  img IE8 \n\t    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  ZImage.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var image = style.image; // Image original width, height\n\t\n\t    var ow;\n\t    var oh;\n\t\n\t    if (isImage(image)) {\n\t      var src = image.src;\n\t\n\t      if (src === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      } else {\n\t        var imageRuntimeStyle = image.runtimeStyle;\n\t        var oldRuntimeWidth = imageRuntimeStyle.width;\n\t        var oldRuntimeHeight = imageRuntimeStyle.height;\n\t        imageRuntimeStyle.width = 'auto';\n\t        imageRuntimeStyle.height = 'auto'; // get the original size\n\t\n\t        ow = image.width;\n\t        oh = image.height; // and remove overides\n\t\n\t        imageRuntimeStyle.width = oldRuntimeWidth;\n\t        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\t\n\t        this._imageSrc = src;\n\t        this._imageWidth = ow;\n\t        this._imageHeight = oh;\n\t      }\n\t\n\t      image = src;\n\t    } else {\n\t      if (image === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      }\n\t    }\n\t\n\t    if (!image) {\n\t      return;\n\t    }\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var dw = style.width;\n\t    var dh = style.height;\n\t    var sw = style.sWidth;\n\t    var sh = style.sHeight;\n\t    var sx = style.sx || 0;\n\t    var sy = style.sy || 0;\n\t    var hasCrop = sw && sh;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      // FIXME  group  left, top  0 \n\t      // vmlEl = vmlCore.createNode('group');\n\t      vmlEl = vmlCore.doc.createElement('div');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    var vmlElStyle = vmlEl.style;\n\t    var hasRotation = false;\n\t    var m;\n\t    var scaleX = 1;\n\t    var scaleY = 1;\n\t\n\t    if (this.transform) {\n\t      m = this.transform;\n\t      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t      hasRotation = m[1] || m[2];\n\t    }\n\t\n\t    if (hasRotation) {\n\t      // If filters are necessary (rotation exists), create them\n\t      // filters are bog-slow, so only create them if abbsolutely necessary\n\t      // The following check doesn't account for skews (which don't exist\n\t      // in the canvas spec (yet) anyway.\n\t      // From excanvas\n\t      var p0 = [x, y];\n\t      var p1 = [x + dw, y];\n\t      var p2 = [x, y + dh];\n\t      var p3 = [x + dw, y + dh];\n\t      applyTransform(p0, p0, m);\n\t      applyTransform(p1, p1, m);\n\t      applyTransform(p2, p2, m);\n\t      applyTransform(p3, p3, m);\n\t      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t      var transformFilter = [];\n\t      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n\t      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform  IE11 \n\t\n\t      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n\t    } else {\n\t      if (m) {\n\t        x = x * scaleX + m[4];\n\t        y = y * scaleY + m[5];\n\t      }\n\t\n\t      vmlElStyle.filter = '';\n\t      vmlElStyle.left = round(x) + 'px';\n\t      vmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    var imageEl = this._imageEl;\n\t    var cropEl = this._cropEl;\n\t\n\t    if (!imageEl) {\n\t      imageEl = vmlCore.doc.createElement('div');\n\t      this._imageEl = imageEl;\n\t    }\n\t\n\t    var imageELStyle = imageEl.style;\n\t\n\t    if (hasCrop) {\n\t      // Needs know image original width and height\n\t      if (!(ow && oh)) {\n\t        var tmpImage = new Image();\n\t        var self = this;\n\t\n\t        tmpImage.onload = function () {\n\t          tmpImage.onload = null;\n\t          ow = tmpImage.width;\n\t          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t\n\t          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\t\n\t          self._imageWidth = ow;\n\t          self._imageHeight = oh;\n\t          self._imageSrc = image;\n\t        };\n\t\n\t        tmpImage.src = image;\n\t      } else {\n\t        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t      }\n\t\n\t      if (!cropEl) {\n\t        cropEl = vmlCore.doc.createElement('div');\n\t        cropEl.style.overflow = 'hidden';\n\t        this._cropEl = cropEl;\n\t      }\n\t\n\t      var cropElStyle = cropEl.style;\n\t      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\t\n\t      if (!cropEl.parentNode) {\n\t        vmlEl.appendChild(cropEl);\n\t      }\n\t\n\t      if (imageEl.parentNode != cropEl) {\n\t        cropEl.appendChild(imageEl);\n\t      }\n\t    } else {\n\t      imageELStyle.width = round(scaleX * dw) + 'px';\n\t      imageELStyle.height = round(scaleY * dh) + 'px';\n\t      vmlEl.appendChild(imageEl);\n\t\n\t      if (cropEl && cropEl.parentNode) {\n\t        vmlEl.removeChild(cropEl);\n\t        this._cropEl = null;\n\t      }\n\t    }\n\t\n\t    var filterStr = '';\n\t    var alpha = style.opacity;\n\t\n\t    if (alpha < 1) {\n\t      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t    }\n\t\n\t    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t    imageELStyle.filter = filterStr;\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    }\n\t  };\n\t\n\t  ZImage.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this._vmlEl = null;\n\t    this._cropEl = null;\n\t    this._imageEl = null;\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  ZImage.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * TEXT\n\t   **************************************************/\n\t\n\t\n\t  var DEFAULT_STYLE_NORMAL = 'normal';\n\t  var fontStyleCache = {};\n\t  var fontStyleCacheCount = 0;\n\t  var MAX_FONT_CACHE_SIZE = 100;\n\t  var fontEl = document.createElement('div');\n\t\n\t  var getFontStyle = function (fontString) {\n\t    var fontStyle = fontStyleCache[fontString];\n\t\n\t    if (!fontStyle) {\n\t      // Clear cache\n\t      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t        fontStyleCacheCount = 0;\n\t        fontStyleCache = {};\n\t      }\n\t\n\t      var style = fontEl.style;\n\t      var fontFamily;\n\t\n\t      try {\n\t        style.font = fontString;\n\t        fontFamily = style.fontFamily.split(',')[0];\n\t      } catch (e) {}\n\t\n\t      fontStyle = {\n\t        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t        size: parseFloat(style.fontSize || 12) | 0,\n\t        family: fontFamily || 'Microsoft YaHei'\n\t      };\n\t      fontStyleCache[fontString] = fontStyle;\n\t      fontStyleCacheCount++;\n\t    }\n\t\n\t    return fontStyle;\n\t  };\n\t\n\t  var textMeasureEl; // Overwrite measure text method\n\t\n\t  textContain.$override('measureText', function (text, textFont) {\n\t    var doc = vmlCore.doc;\n\t\n\t    if (!textMeasureEl) {\n\t      textMeasureEl = doc.createElement('div');\n\t      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n\t      vmlCore.doc.body.appendChild(textMeasureEl);\n\t    }\n\t\n\t    try {\n\t      textMeasureEl.style.font = textFont;\n\t    } catch (ex) {// Ignore failures to set to invalid font.\n\t    }\n\t\n\t    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t\n\t    textMeasureEl.appendChild(doc.createTextNode(text));\n\t    return {\n\t      width: textMeasureEl.offsetWidth\n\t    };\n\t  });\n\t  var tmpRect = new BoundingRect();\n\t\n\t  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!text) {\n\t      return;\n\t    } // Convert rich text to plain text. Rich text is not supported in\n\t    // IE8-, but tags in rich text template will be removed.\n\t\n\t\n\t    if (style.rich) {\n\t      var contentBlock = textContain.parseRichText(text, style);\n\t      text = [];\n\t\n\t      for (var i = 0; i < contentBlock.lines.length; i++) {\n\t        var tokens = contentBlock.lines[i].tokens;\n\t        var textLine = [];\n\t\n\t        for (var j = 0; j < tokens.length; j++) {\n\t          textLine.push(tokens[j].text);\n\t        }\n\t\n\t        text.push(textLine.join(''));\n\t      }\n\t\n\t      text = text.join('\\n');\n\t    }\n\t\n\t    var x;\n\t    var y;\n\t    var align = style.textAlign;\n\t    var verticalAlign = style.textVerticalAlign;\n\t    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\t\n\t    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\t\n\t    var m = this.transform; // Ignore transform for text in other element\n\t\n\t    if (m && !fromTextEl) {\n\t      tmpRect.copy(rect);\n\t      tmpRect.applyTransform(m);\n\t      rect = tmpRect;\n\t    }\n\t\n\t    if (!fromTextEl) {\n\t      var textPosition = style.textPosition;\n\t      var distance = style.textDistance; // Text position represented by coord\n\t\n\t      if (textPosition instanceof Array) {\n\t        x = rect.x + parsePercent(textPosition[0], rect.width);\n\t        y = rect.y + parsePercent(textPosition[1], rect.height);\n\t        align = align || 'left';\n\t      } else {\n\t        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n\t        x = res.x;\n\t        y = res.y; // Default align and baseline when has textPosition\n\t\n\t        align = align || res.textAlign;\n\t        verticalAlign = verticalAlign || res.textVerticalAlign;\n\t      }\n\t    } else {\n\t      x = rect.x;\n\t      y = rect.y;\n\t    }\n\t\n\t    x = textContain.adjustTextX(x, textRect.width, align);\n\t    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\t\n\t    y += textRect.height / 2; // var fontSize = fontStyle.size;\n\t    // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t    // switch (baseline) {\n\t    // case 'hanging':\n\t    // case 'top':\n\t    //     y += fontSize / 1.75;\n\t    //     break;\n\t    //     case 'middle':\n\t    //         break;\n\t    //     default:\n\t    //     // case null:\n\t    //     // case 'alphabetic':\n\t    //     // case 'ideographic':\n\t    //     // case 'bottom':\n\t    //         y -= fontSize / 2.25;\n\t    //         break;\n\t    // }\n\t    // switch (align) {\n\t    //     case 'left':\n\t    //         break;\n\t    //     case 'center':\n\t    //         x -= textRect.width / 2;\n\t    //         break;\n\t    //     case 'right':\n\t    //         x -= textRect.width;\n\t    //         break;\n\t    // case 'end':\n\t    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t    // break;\n\t    // case 'start':\n\t    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t    // break;\n\t    // default:\n\t    //     align = 'left';\n\t    // }\n\t\n\t    var createNode = vmlCore.createNode;\n\t    var textVmlEl = this._textVmlEl;\n\t    var pathEl;\n\t    var textPathEl;\n\t    var skewEl;\n\t\n\t    if (!textVmlEl) {\n\t      textVmlEl = createNode('line');\n\t      pathEl = createNode('path');\n\t      textPathEl = createNode('textpath');\n\t      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n\t      // Align 'center' seems wrong\n\t\n\t      textPathEl.style['v-text-align'] = 'left';\n\t      initRootElStyle(textVmlEl);\n\t      pathEl.textpathok = true;\n\t      textPathEl.on = true;\n\t      textVmlEl.from = '0 0';\n\t      textVmlEl.to = '1000 0.05';\n\t      append(textVmlEl, skewEl);\n\t      append(textVmlEl, pathEl);\n\t      append(textVmlEl, textPathEl);\n\t      this._textVmlEl = textVmlEl;\n\t    } else {\n\t      //  appendChild \n\t      skewEl = textVmlEl.firstChild;\n\t      pathEl = skewEl.nextSibling;\n\t      textPathEl = pathEl.nextSibling;\n\t    }\n\t\n\t    var coords = [x, y];\n\t    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\t\n\t    if (m && fromTextEl) {\n\t      applyTransform(coords, coords, m);\n\t      skewEl.on = true;\n\t      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\t\n\t      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\t\n\t      skewEl.origin = '0 0';\n\t      textVmlElStyle.left = '0px';\n\t      textVmlElStyle.top = '0px';\n\t    } else {\n\t      skewEl.on = false;\n\t      textVmlElStyle.left = round(x) + 'px';\n\t      textVmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\t\n\t    try {\n\t      textPathEl.style.font = font;\n\t    } // Error font format\n\t    catch (e) {}\n\t\n\t    updateFillAndStroke(textVmlEl, 'fill', {\n\t      fill: style.textFill,\n\t      opacity: style.opacity\n\t    }, this);\n\t    updateFillAndStroke(textVmlEl, 'stroke', {\n\t      stroke: style.textStroke,\n\t      opacity: style.opacity,\n\t      lineDash: style.lineDash\n\t    }, this);\n\t    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\t\n\t    append(vmlRoot, textVmlEl);\n\t  };\n\t\n\t  var removeRectText = function (vmlRoot) {\n\t    remove(vmlRoot, this._textVmlEl);\n\t    this._textVmlEl = null;\n\t  };\n\t\n\t  var appendRectText = function (vmlRoot) {\n\t    append(vmlRoot, this._textVmlEl);\n\t  };\n\t\n\t  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\t\n\t  for (var i = 0; i < list.length; i++) {\n\t    var proto = list[i].prototype;\n\t    proto.drawRectText = drawRectText;\n\t    proto.removeRectText = removeRectText;\n\t    proto.appendRectText = appendRectText;\n\t  }\n\t\n\t  Text.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, {\n\t        x: style.x || 0,\n\t        y: style.y || 0,\n\t        width: 0,\n\t        height: 0\n\t      }, this.getBoundingRect(), true);\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Text.prototype.onRemove = function (vmlRoot) {\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Text.prototype.onAdd = function (vmlRoot) {\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t}\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\tvar urn = 'urn:schemas-microsoft-com:vml';\n\tvar win = typeof window === 'undefined' ? null : window;\n\tvar vmlInited = false;\n\tvar doc = win && win.document;\n\t\n\tfunction createNode(tagName) {\n\t  return doCreateNode(tagName);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tvar doCreateNode;\n\t\n\tif (doc && !env.canvasSupported) {\n\t  try {\n\t    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t    };\n\t  } catch (e) {\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t    };\n\t  }\n\t} // From raphael\n\t\n\t\n\tfunction initVML() {\n\t  if (vmlInited || !doc) {\n\t    return;\n\t  }\n\t\n\t  vmlInited = true;\n\t  var styleSheets = doc.styleSheets;\n\t\n\t  if (styleSheets.length < 31) {\n\t    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  } else {\n\t    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  }\n\t}\n\t\n\texports.doc = doc;\n\texports.createNode = createNode;\n\texports.initVML = initVML;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrLog = __webpack_require__(22);\n\t\n\tvar vmlCore = __webpack_require__(84);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar each = _util.each;\n\t\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t/**\n\t * @alias module:zrender/vml/Painter\n\t */\n\t\n\t\n\tfunction VMLPainter(root, storage) {\n\t  vmlCore.initVML();\n\t  this.root = root;\n\t  this.storage = storage;\n\t  var vmlViewport = document.createElement('div');\n\t  var vmlRoot = document.createElement('div');\n\t  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t  root.appendChild(vmlViewport);\n\t  this._vmlRoot = vmlRoot;\n\t  this._vmlViewport = vmlViewport;\n\t  this.resize(); // Modify storage\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t\n\t    if (el) {\n\t      el.onRemove && el.onRemove(vmlRoot);\n\t    }\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    // Displayable already has a vml node\n\t    el.onAdd && el.onAdd(vmlRoot);\n\t    oldAddToStorage.call(storage, el);\n\t  };\n\t\n\t  this._firstPaint = true;\n\t}\n\t\n\tVMLPainter.prototype = {\n\t  constructor: VMLPainter,\n\t  getType: function () {\n\t    return 'vml';\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._vmlViewport;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * \n\t   */\n\t  refresh: function () {\n\t    var list = this.storage.getDisplayList(true, true);\n\t\n\t    this._paintList(list);\n\t  },\n\t  _paintList: function (list) {\n\t    var vmlRoot = this._vmlRoot;\n\t\n\t    for (var i = 0; i < list.length; i++) {\n\t      var el = list[i];\n\t\n\t      if (el.invisible || el.ignore) {\n\t        if (!el.__alreadyNotVisible) {\n\t          el.onRemove(vmlRoot);\n\t        } // Set as already invisible\n\t\n\t\n\t        el.__alreadyNotVisible = true;\n\t      } else {\n\t        if (el.__alreadyNotVisible) {\n\t          el.onAdd(vmlRoot);\n\t        }\n\t\n\t        el.__alreadyNotVisible = false;\n\t\n\t        if (el.__dirty) {\n\t          el.beforeBrush && el.beforeBrush();\n\t          (el.brushVML || el.brush).call(el, vmlRoot);\n\t          el.afterBrush && el.afterBrush();\n\t        }\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (this._firstPaint) {\n\t      // Detached from document at first time\n\t      // to avoid page refreshing too many times\n\t      // FIXME  removeChild \n\t      this._vmlViewport.appendChild(vmlRoot);\n\t\n\t      this._firstPaint = false;\n\t    }\n\t  },\n\t  resize: function (width, height) {\n\t    var width = width == null ? this._getWidth() : width;\n\t    var height = height == null ? this._getHeight() : height;\n\t\n\t    if (this._width != width || this._height != height) {\n\t      this._width = width;\n\t      this._height = height;\n\t      var vmlViewportStyle = this._vmlViewport.style;\n\t      vmlViewportStyle.width = width + 'px';\n\t      vmlViewportStyle.height = height + 'px';\n\t    }\n\t  },\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this._vmlRoot = this._vmlViewport = this.storage = null;\n\t  },\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  clear: function () {\n\t    if (this._vmlViewport) {\n\t      this.root.removeChild(this._vmlViewport);\n\t    }\n\t  },\n\t  _getWidth: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n\t  },\n\t  _getHeight: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n\t  }\n\t}; // Not supported methods\n\t\n\tfunction createMethodNotSupport(method) {\n\t  return function () {\n\t    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t  };\n\t} // Unsupported methods\n\t\n\t\n\teach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n\t  VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t});\n\tvar _default = VMLPainter;\n\tmodule.exports = _default;\n\n/***/ })\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f19dda89bdc4710c95f7","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-bo/lib/FishTopoBo.js');\r\n//IE8 VML IE8\r\nrequire('zrender/lib/vml/vml');\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.bo.js\n// module id = 1\n// module chunks = 0","/**\r\n * Created by majianan on 16/5/19.\r\n *\r\n */\r\n\r\n    var zr = require('zrender/lib/zrender');\r\n    var util = require('zrender/lib/core/util');\r\n    var BoNode = require('./node/BoNode');\r\n    var Relation = require('./node/Relation');\r\n    var Const = require('./models/Const');\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    require('../../fish-topo-core/lib/objectAssignPolyfill.js');\r\n\r\n    function FishTopoBo(dom, opts) {\r\n        /**\r\n         * \r\n         * @type {number}\r\n         */\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n\r\n        /**\r\n         * zrender\r\n         */\r\n        this._zr = zr.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n    }\r\n\r\n    var fishTopoProto = FishTopoBo.prototype;\r\n\r\n    /**\r\n     * \r\n     */\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n    };\r\n\r\n    /**\r\n     *   \r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {Object} boData, bo\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} ,\r\n     *          displayAttrDataType: boolean ,\r\n     *          displayAttrEvent: boolean ,\r\n     *          boClickable: boolean BO,  false\r\n     *          boPopupUrl: String BO\r\n     *          boEventClickable: boolean BO,  false\r\n     *          boEventPopupUrl: String BO\r\n     *          bindBoClickEvent: function(options) BOoptionsDATA\r\n     *          attrEventClickable: boolean BO,  false\r\n     *          attrEventPopupUrl: String BO\r\n     *          isCurrent: boolean BO\r\n     *          lineStyle: {stroke: string, lineWidth: number, lineDash: Array} \r\n     *          lineHoverStyle: {stroke: string, lineWidth: number, lineDash: Array} hover\r\n     *          arrowStyle: {fill: string, stroke: string} \r\n     *          arrowHoverStyle: {fill: string, stroke: string} hover\r\n     *          }} opts\r\n     * @returns {*}\r\n     */\r\n    fishTopoProto.addBo = function (boData, opts) {\r\n        //BO\r\n        this._setParent(boData);\r\n\r\n        //layout BOx,y, level:\r\n        boData.layout = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y,\r\n            level: 1\r\n        };\r\n\r\n        //BOX\r\n        this._bfs(boData);\r\n\r\n        //\r\n        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\r\n        //BO\r\n        var boNode = new BoNode(boData, opts);\r\n        this.group.add(boNode.getShape());\r\n\r\n        //BO\r\n        this.addChildBo(boNode, opts);\r\n\r\n        return boNode;\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {Object} boData BO\r\n     * @private\r\n     */\r\n    fishTopoProto._setParent = function (boData) {\r\n        if (boData.child) {\r\n            var childCnt = boData.child.length,\r\n                childBoArr = boData.child;\r\n            for (var i = 0; i < childCnt; i++) {\r\n                childBoArr[i].parent = boData;\r\n                if (childBoArr[i + 1]) {\r\n                    childBoArr[i].next = childBoArr[i + 1];\r\n                }\r\n                //next=\r\n                else if (boData.next && boData.next.child) {\r\n                    childBoArr[i].next = boData.next.child[0];\r\n                }\r\n                this._setParent(childBoArr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Breadth-First-Search X\r\n     * BOBOX\r\n     * BOBOY\r\n     * @param boData\r\n     * @private\r\n     */\r\n    fishTopoProto._bfs = function (boData) {\r\n        //level\r\n        this._levelMaxPos = {};\r\n\r\n        this._queue = [];   //BO\r\n        this._queue.push(boData);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift();\r\n            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //level\r\n            if (!this._levelMaxPos[tmp.layout.level]) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //\r\n            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //\r\n            else {\r\n                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //x\r\n            if (tmp.child) {\r\n                var childCnt = tmp.child.length;\r\n\r\n                for (var i = 0; i < childCnt; i++) {\r\n\r\n                    tmp.child[i].layout = {\r\n                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n                        level: tmp.layout.level + 1\r\n                    };\r\n\r\n                    this._queue.push(tmp.child[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByChild = function (boData, width) {\r\n        if (boData) {\r\n\r\n            if (!boData.layout.moved) {\r\n\r\n                if (boData.layout.level == 1) {\r\n                    boData.layout.x += width / 2;\r\n                } else {\r\n                    boData.layout.x += width;\r\n                }\r\n\r\n                boData.layout.moved = true;\r\n            }\r\n            //\r\n            this._moveRightByPrevious(boData.next, width);\r\n            //\r\n            this._moveRightByChild(boData.parent, width);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            //\r\n            this._moveRightByPrevious(boData.next, width);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByParent = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            if (boData.child) {\r\n                for (var i = 0; i < boData.child.length; i++) {\r\n                    this._moveRightByParent(boData.child[i], width);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {BoNode} parentBoNode\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\r\n        this._queue = []; //BOYBoNode\r\n        this._queue.push(parentBoNode);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift(),\r\n                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            //Level\r\n            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            if (tmp.getData().child) {\r\n\r\n                var childBoArr = tmp.getData().child,\r\n                    childCnt = childBoArr.length,\r\n                    boNode,\r\n                    relationNode;\r\n\r\n                //levelY\r\n                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n                for (var i = 0; i < childCnt; i++) {\r\n                    opts.startPos.x = childBoArr[i].layout.x;\r\n                    childBoArr[i].layout.y = opts.startPos.y;\r\n                    boNode = new BoNode(childBoArr[i], opts);\r\n                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\r\n                    this.group.add(boNode.getShape());\r\n                    this._queue.push(boNode);\r\n\r\n                    //BO\r\n                    if (childBoArr[i].relation) {\r\n                        var _relationLen = childBoArr[i].relation.length;\r\n                        for (var j = 0; j < _relationLen; j++) {\r\n                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n                                targetId = childBoArr[i].relation[j].targetId,\r\n                                sourceText = childBoArr[i].relation[j].sourceText,\r\n                                targetText = childBoArr[i].relation[j].targetText;\r\n\r\n                            relationNode = new Relation(\r\n                                boNode.getShape().childOfName(sourceId),\r\n                                tmp.getShape().childOfName(targetId),\r\n                                sourceText,\r\n                                targetText,\r\n                                opts.lineStyle,\r\n                                opts.lineHoverStyle,\r\n                                opts.arrowStyle,\r\n                                opts.arrowHoverStyle\r\n                            );\r\n                            this.group.add(relationNode.getShape());\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {String} boId, BO\r\n     * @param {Object} style, BO,\r\n     */\r\n    fishTopoProto.setCurrentBo = function (boId, style) {\r\n        var length = this.group.childCount();\r\n        for (var i = 0; i < length; i++) {\r\n            if (this.group.childAt(i).name == boId) {\r\n                this.group.childAt(i).setCurrent(style);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     */\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param type\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        var that = this;\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta = 1 / 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n        } else {\r\n            that._zr.on('mousewheel', function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n            });\r\n        }\r\n        ;\r\n        function zoom(zoomDelta, zoomX, zoomY) {\r\n            if (that.canScale == false) {\r\n                return;\r\n            }\r\n            var target = that.group;\r\n            if (target) {\r\n                var pos = target.position;\r\n                var scale = target.scale;\r\n                var newZoom = that._zoom = that._zoom || 1;\r\n                newZoom *= zoomDelta;\r\n                var zoomScale = newZoom / that._zoom;\r\n                // if(newZoom>2.6||newZoom<0.38){\r\n                //     return;\r\n                // };\r\n                that._zoom = newZoom;\r\n\r\n                that.nowZoom = newZoom;\r\n                // Keep the mouse center when scaling\r\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n                scale[0] *= zoomScale;\r\n                scale[1] *= zoomScale;\r\n                target.attr(\"position\", [pos[0], pos[1]]);\r\n                target.attr(\"scale\", [scale[0], scale[1]]);\r\n                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Group\r\n     */\r\n    fishTopoProto.groupDrag = function () {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function (e) {\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param node\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function (e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n            if (node.alarm) {\r\n                var newAlarmPosition = node.alarm.position;\r\n                alarmPositionX = node.alarm.position[0];\r\n                alarmPositionY = node.alarm.position[1];\r\n            }\r\n            ;\r\n            function moveDrag(e) {\r\n                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //nodegroup\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                } else {\r\n                    nowGroupPosition[0] = groupPositionX + (sX);\r\n                    nowGroupPosition[1] = groupPositionY + (sY);\r\n                    node.attr(\"position\", nowGroupPosition);\r\n                    if (node.alarm) {\r\n                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                        node.alarm.attr(\"position\", newAlarmPosition);\r\n                    }\r\n                    ;\r\n                }\r\n                ConnectionManager.refreshLineByNode(node);\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n            //\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\"node\": node});\r\n                }\r\n                if (that.forceLayoutOption) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (_.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                ;\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n\r\n    // ---------fishTopoBo------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n    var fishTopoBo = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '3.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoBo.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        util.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoBo = new FishTopoBo(dom, opts);\r\n        fishTopoBo.init();\r\n\r\n        fishTopoBo.id = 'ft_' + idBase++;\r\n        instances[fishTopoBo.id] = fishTopoBo;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\r\n        return fishTopoBo;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoBo.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoBo.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoBo.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoBo;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/FishTopoBo.js\n// module id = 2\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar env = require(\"./core/env\");\n\nvar zrUtil = require(\"./core/util\");\n\nvar Handler = require(\"./Handler\");\n\nvar Storage = require(\"./Storage\");\n\nvar Painter = require(\"./Painter\");\n\nvar Animation = require(\"./animation/Animation\");\n\nvar HandlerProxy = require(\"./dom/HandlerProxy\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRendermap\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; //  storage.delFromStorage, \n  // FIXME ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * \n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 3\n// module chunks = 0","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 4\n// module chunks = 0","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // canvas\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 5\n// module chunks = 0","/**\n * @module zrender/core/util\n */\n// mergeDate\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // overwritetrue\n        // NOTE target[key] \n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * \n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz \n * @param {Function} baseClazz \n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 6\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * cursor style\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * \n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} \n   * @param {string} eventName \n   * @param {Object} event \n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      //  zrender \n      this.trigger(eventName, eventPacket); // \n      //  click  dispose painter \n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 7\n// module chunks = 0","var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} \n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 8\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 9\n// module chunks = 0","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * \n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * trigger\n   *\n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} [handler] \n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   *\n   * @param {string} type \n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * context, context\n   * @param {string} type \n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; //  onxxxx \n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 10\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./container/Group\");\n\nvar timsort = require(\"./core/timsort\");\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n *  (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [update=false] \n   * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n   *\n   * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * \n   * GroupShapeShape\n   * zlevel > z > \n   * @param {boolean} [includeIgnore=false]  ignore \n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME \n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath  clipPath \n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {string|Array.<string>} [el] Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // el\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 11\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Element = require(\"../Element\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * \n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   *  index \n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * \n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   *  nextSibling \n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * \n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 12\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * \n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * \n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender  element  zrender \n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * true\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * (shape) Group \n   * \n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 13\n// module chunks = 0","var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * \n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * \n * , position, rotation, scaletransformtransform\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // \n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // \n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * transformcontext\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * `transform``position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n *  shape \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 14\n// module chunks = 0","/**\n * 3x2\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 15\n// module chunks = 0","var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * \n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 16\n// module chunks = 0","var Clip = require(\"./Clip\");\n\nvar color = require(\"../tool/color\");\n\nvar _util = require(\"../core/util\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * \n   * @param  {number} time ms\n   * @param  {Object} props key-value\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * \n   * @param  {string|Function} [easing]\n   *         {@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * \n   * @param  {number} time ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 17\n// module chunks = 0","var easingFuncs = require(\"./easing\");\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // \n\n  this._life = options.life || 1000; // \n\n  this._delay = options.delay || 0; // \n  // this._startTime = new Date().getTime() + this._delay;// \n\n  this._initialized = false; // \n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // \n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // \n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // \n        //  stage.update \n\n        return 'restart';\n      } // \n      // Animation.update\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 18\n// module chunks = 0","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // t^3\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // t^4\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // t^5\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // sin(t)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 2^t\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // sqrt(1-t^2)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 19\n// module chunks = 0","var LRU = require(\"../core/LRU\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 20\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 21\n// module chunks = 0","var _config = require(\"../config\");\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 22\n// module chunks = 0","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config\n * @exports zrender/config\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n/**\n * debugcatchBrushExceptiontrue\n * 0 : debug\n * 1 : \n * 2 : \n */\n\n\nvar debugMode = 0; // retina \n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 23\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar matrix = require(\"./matrix\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // \n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 24\n// module chunks = 0","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 25\n// module chunks = 0","var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // \n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root \n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * \n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [paintAll=false] displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   *  zlevel \n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // \n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * hover\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * zlevel\n   *\n   * @param {string} zlevel\n   * @param {Object} config \n   * @param {string} [config.clearColor=0] \n   * @param {string} [config.motionBlur=false] \n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 alpha\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {number} zlevel zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * \n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * \n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * \n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * \n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * \n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 26\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * dom\n *\n * @inner\n * @param {string} id dom id \n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // append~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // \n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * \n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * \n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * alpha\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 27\n// module chunks = 0","var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 28\n// module chunks = 0","var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 29\n// module chunks = 0","var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 30\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar imageHelper = require(\"./helper/image\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // \n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 31\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"../Element\");\n\nvar RectText = require(\"./mixin/RectText\");\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable Painter \n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * true\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * zlevelcanvas\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * \n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * \n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   *  x, y \n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   *  x, y \n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * \n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * \n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO,  bind \n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 32\n// module chunks = 0","var textHelper = require(\"../helper/text\");\n\nvar BoundingRect = require(\"../../core/BoundingRect\");\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 33\n// module chunks = 0","var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/text.js\n// module id = 34\n// module chunks = 0","var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 35\n// module chunks = 0","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/image.js\n// module id = 36\n// module chunks = 0","function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 37\n// module chunks = 0","var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   *  clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   *  animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * \n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * \n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * \n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * animator\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] \n   * @param  {Function} [options.getter=null]\n   *         gettergetter\n   * @param  {Function} [options.setter=null]\n   *         settersetter\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 38\n// module chunks = 0","var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * domtouch.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // \n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 39\n// module chunks = 0","var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\nvar GestureMgr = require(\"../core/GestureMgr\");\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // rootdommouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * dom \n *\n * @inner\n * @param {module:zrender/Handler} instance \n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 40\n// module chunks = 0","var eventUtil = require(\"./event\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 41\n// module chunks = 0","/**\r\n * BO\r\n * 1.BO\r\n * 2.BO\r\n * 3.BO[]\r\n * 4.BO[]\r\n * 5.BOBO\r\n * 6.BO\r\n * 7.BOBO\r\n * @module fish-topo-bo/node/BoNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var BoName = require('../node/BoName');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var Line = require('../node/LineNode');\r\n    var BoAttr = require('../node/BoAttrNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String BO,\r\n     *          name: String BO,\r\n     *          boEventArr: [] BO,\r\n     *          boAttrArr: [] BO\r\n     *          }} boData, bo\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} ,\r\n     *          displayAttrDataType: boolean ,\r\n     *          displayAttrEvent: boolean ,\r\n     *          boClickable: boolean BO,  false\r\n     *          boPopupOpts: Object BOurl,width,height\r\n     *          boEventClickable: boolean BO,  false\r\n     *          boEventPopupOpts: Object BOurl,width,height\r\n     *          bindBoClickEvent: function(options) BOoptionsDATA\r\n     *          attrEventClickable: boolean BO,  false\r\n     *          attrEventPopupOpts: Object BOurl,width,height\r\n     *          isCurrent: boolean BO\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BO(boData, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boData;\r\n\r\n        /**\r\n         * BO\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._oriStartPos = opts.startPos;\r\n\r\n        /**\r\n         * \r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._nextStartPos = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y\r\n        };\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\r\n        //TODO\r\n        if (this._displayAttrEvent) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n        } else if (this._displayAttrDataType) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n        }\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._boClickable = opts.boClickable || false;\r\n        this._boPopupOpts = opts.boPopupOpts;\r\n        this._boEventClickable = opts.boEventClickable || false;\r\n        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n        this._attrEventClickable = opts.attrEventClickable || false;\r\n        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\r\n        /**\r\n         * BOBO\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._isCurrent = opts.isCurrent || false;\r\n\r\n\r\n        /**\r\n         * BO\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._boShapeHeight = 0;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n        this._group.setCurrent = function (style) {\r\n            //GroupBO\r\n            var _boShape = this.childAt(this.childCount() - 1);\r\n\r\n            if (style) {\r\n                Object.assign(_boShape.style, style);\r\n            } else {\r\n                //\r\n                _boShape.style.fill = '#66CC99';\r\n            }\r\n\r\n        };\r\n\r\n        this._render();\r\n    }\r\n\r\n\r\n    var boProto = BO.prototype;\r\n\r\n    /**\r\n     * BO\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @returns {Object}\r\n     */\r\n    boProto.getData = function () {\r\n        return this._data;\r\n    };\r\n\r\n    boProto.getLayout = function () {\r\n        return this._data.layout;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * BO\r\n     */\r\n    boProto.setCurrent = function () {\r\n        //BO\r\n        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._render = function () {\r\n        //BO\r\n        this._createBoName();\r\n\r\n        //BO\r\n        this._createEventDecision();\r\n\r\n        //BO\r\n        this._createBoAttr();\r\n\r\n        //BO\r\n        this._createBoShape();\r\n\r\n        //TODO\r\n        Const.BO_NODE_WIDTH = 180;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoName = function () {\r\n        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\r\n        if (this._boClickable) {\r\n            _boNameShape.clickable = this._boClickable;\r\n            _boNameShape._data = this._data;\r\n            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n            _boNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(_boNameShape);\r\n        this._calNextShapeStartPos(_boNameShape);\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createEventDecision = function () {\r\n\r\n        //BO\r\n        if (!this._data.boEventArr) {\r\n            return;\r\n        }\r\n\r\n        var _boEventArr = this._data.boEventArr,\r\n            _boEventLen = _boEventArr.length,\r\n            _eventShape,\r\n            _eventOpts = {\r\n                startPos: this._nextStartPos,\r\n                clickable: this._boEventClickable,\r\n                popupOpts: this._boEventPopupOpts,\r\n                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n            };\r\n\r\n        for (var i = 0; i < _boEventLen; i++) {\r\n            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n            this._group.add(_eventShape.getShape());\r\n            this._calNextShapeStartPos(_eventShape.getShape());\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoAttr = function () {\r\n        //BO\r\n        if (!this._data.boAttrArr) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrArr = this._data.boAttrArr,\r\n            _boAttrLen = _boAttrArr.length,\r\n            _boAttrShape, _lineShape,\r\n            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\r\n        for (var i = 0; i < _boAttrLen; i++) {\r\n            if (i == 0) {\r\n                _lineShape = Line.BoLine(this._nextStartPos); //\r\n            }\r\n            else {\r\n                _lineShape = Line.AttrLine(this._nextStartPos);//\r\n            }\r\n\r\n            this._group.add(_lineShape);\r\n\r\n            this._calNextShapeStartPos(_lineShape);\r\n\r\n            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n                {\r\n                    startPos: this._nextStartPos,\r\n                    displayDataType: this._displayAttrDataType,\r\n                    displayEventDecision: this._displayAttrEvent,\r\n                    eventClickable: this._attrEventClickable,\r\n                    eventPopupOpts: this._attrEventPopupOpts,\r\n                    bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n                }\r\n            );\r\n            this._group.add(_boAttrShape.getShape());\r\n            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n        }\r\n\r\n        if (this._displayAttrEvent) {\r\n            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n                this._nextStartPos.y - _attrEventStartPos.y\r\n            );\r\n            this._group.add(_lineShape);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @param curShape \r\n     * @private\r\n     */\r\n    boProto._calNextShapeStartPos = function (curShape) {\r\n        //\r\n        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\r\n        //BO\r\n        this._boShapeHeight += curShape.getBoundingRect().height;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoShape = function () {\r\n        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n            shape = new graphic.Rect({\r\n                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\r\n                shape: {\r\n                    r: 5,\r\n                    width: Const.BO_NODE_WIDTH,\r\n                    height: height\r\n                },\r\n\r\n                style: {\r\n                    brushType: 'both',\r\n                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n                    stroke: '#000000',\r\n                    lineWidth: 1,\r\n                    lineCape: 'round'\r\n                },\r\n\r\n                zlevel: -1\r\n            });\r\n\r\n        if (this._boClickable) {\r\n            shape._data = this._data;\r\n            shape._boPopupOpts = this._boPopupOpts;\r\n\r\n            shape.clickable = this._boClickable;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boProto._click = function () {\r\n        var options = Object.assign(\r\n            {\r\n                DATA: this._data\r\n            }, this._boPopupOpts);\r\n\r\n        nodeOptions.bindBoClickEvent(options);\r\n    };\r\n\r\n    module.exports = BO;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoNode.js\n// module id = 42\n// module chunks = 0","/**\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    module.exports = {\r\n        BO_NODE_WIDTH: 180,    //BO\r\n        BO_NODE_DEFAULT_HEIGHT: 60,\t//BOBO\r\n        BO_NODE_OFFSET_X: 90, //BO=\r\n        BO_NODE_OFFSET_Y: 50, //BO\r\n\r\n        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO,\r\n        BO_NAME_PADDING_TOP: 10,   //BO\r\n        BO_NAME_PADDING_BOTTOM: 15,   //BO\r\n\r\n        BO_EVENT_HEIGHT: 20,   //BO\r\n        BO_EVENT_WIDTH: 140,   //BO\r\n        BO_EVENT_FONT: 'normal 14px Arial',  //BO\r\n\r\n        BO_ATTR_FONT: 'normal 14px Arial',   //BO\r\n        BO_ATTR_PADDING_TOP: 5,   //BO\r\n        BO_ATTR_PADDING_BOTTOM: 5,   //BO\r\n        BO_ATTR_PADDING_LEFT: 5,   //BO\r\n        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO\r\n        BO_ATTR_EVENT_WIDTH: 135,   //BO\r\n\r\n        LINE_DASH: 10,  //\r\n        RELATION_OFFSET: 40,   //\r\n        RELATION_ARROW_WIDTH: 10,  //\r\n        RELATION_ARROW_HEIGHT: 5,  //\r\n        RELATION_TEXT_OFFSET_X: 10, //\r\n        RELATION_TEXT_OFFSET_Y: 5 //\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/models/Const.js\n// module id = 43\n// module chunks = 0","/**\r\n * BO\r\n * @module fish-topo-bo/node/BoName\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {String} text, BO\r\n     * @param {{x: number, y: number}} startPos, \r\n     * @returns {zrender/graphic/Text}\r\n     * @constructor\r\n     */\r\n    function BoName(text, startPos) {\r\n        var x = startPos.x,\r\n            y = startPos.y + Const.BO_NAME_PADDING_TOP, // padding-top=10\r\n\r\n            shape = new graphic.Text({\r\n                style: {\r\n                    text: text,\r\n                    textFont: Const.BO_NAME_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        // =  + (BO - )/2\r\n        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\r\n        //BO =  + padding-top + padding-bottom\r\n        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\r\n        return shape;\r\n    }\r\n\r\n    module.exports = BoName;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoName.js\n// module id = 44\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    graphic.States = require(\"zrender/lib/graphic/States.js\");\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        (el.type === 'group' || el.type === 'GroupNode')\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/graphic.js\n// module id = 45\n// module chunks = 0","var Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar transformPath = require(\"./transformPath\");\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 46\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n *  Path element, \n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME  extend position, rotation \n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 47\n// module chunks = 0","var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * Path\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi  _dashedXXXXTo \n    // xi, yi , x0, y0  closePath \n    //  beginPath  lineTo x0, y0 \n    //  lineTo dashed line  IE10- \n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context  rebuildPath  fill\n   * stroke \n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   *  Path \n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * \n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   *  Path \n   * \n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      //  Float32Array\n      // \n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   *  Float32Array \n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo  subpath, \n          //  closePath \n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc \n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc \n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 48\n// module chunks = 0","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // \n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} \n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] \n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out \n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 49\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * `min``max`\n * @module zrender/core/bbox\n * @param {Array<Object>} points \n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * (p0, p1, p2, p3)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * (p0, p1, p2)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * `min``max`\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 50\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = require(\"../core/curve\");\n\nvar windingLine = require(\"./windingLine\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // \n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc \n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } //  subpath \n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      //  L, C, Q\n      //  previous point  point\n      //\n      //  Arc \n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo  subpath, \n        //  closePath \n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE  L, C, Q  NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc \n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc \n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; //  arc \n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // \n          x0 = x1;\n          y0 = y1;\n        } // zr scale, x\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); //  subpath \n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 51\n// module chunks = 0","/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 52\n// module chunks = 0","var curve = require(\"../core/curve\");\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 53\n// module chunks = 0","var _curve = require(\"../core/curve\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 54\n// module chunks = 0","var _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * \n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 55\n// module chunks = 0","var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 56\n// module chunks = 0","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 57\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar _vector = require(\"../core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 58\n// module chunks = 0","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 59\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"./helper/text\");\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 60\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 61\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../helper/fixClipWithShadow\");\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 62\n// module chunks = 0","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 63\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 64\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * \n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 65\n// module chunks = 0","var smoothSpline = require(\"./smoothSpline\");\n\nvar smoothBezier = require(\"./smoothBezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 66\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points \n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 67\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * \n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points \n * @param {number} smooth , 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint \n *                            [[0, 0], [100, 100]], \n *                           \n * @param {Array} \n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // \n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 68\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 69\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../helper/roundRect\");\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // r1r2r3r4\n    // r1          [1, 1, 1, 1]\n    // r[1]        [1, 1, 1, 1]\n    // r[1, 2]     [1, 2, 1, 2]\n    // r[1, 2, 3]  [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 70\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 71\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar _curve = require(\"../../core/curve\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 72\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 73\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 74\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 75\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar _vector = require(\"../core/vector\");\n\nvar vec2Copy = _vector.copy;\n\n/**\n * States machine for managing graphic states\n */\n\n/**\n * @typedef {Object} IGraphicState\n * @property {number} [zlevel]\n * @property {number} [z]\n * @property {Array.<number>} {position}\n * @property {Array.<number>|number} {rotation}\n * @property {Array.<number>} {scale}\n * @property {Object} style\n *\n * @property {Function} onenter\n * @property {Function} onleave\n * @property {Function} ontransition\n * @property {Array.<IGraphicStateTransition|string>} transition\n *           Transition object or a string descriptor like '* 30 0 Linear'\n */\nvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n/**\n * @module zrender/graphic/States~TransitionObject\n */\n\nvar TransitionObject = function (opts) {\n  if (typeof opts == 'string') {\n    this._fromStr(opts);\n  } else if (opts) {\n    opts.property && (this.property = opts.property);\n    opts.duration != null && (this.duration = opts.duration);\n    opts.easing && (this.easing = opts.easing);\n    opts.delay && (this.delay = opts.delay);\n  }\n\n  if (this.property !== '*') {\n    this.property = this.property.split(',');\n  } else {\n    this.property = transitionProperties;\n  }\n};\n\nTransitionObject.prototype = {\n  constructor: TransitionObject,\n\n  /**\n   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n   * e.g. 'position,style.color'. '*' will match all the valid properties.\n   * @type {string}\n   * @default *\n   */\n  property: '*',\n\n  /**\n   * @type {string}\n   * @default 'Linear'\n   */\n  easing: 'Linear',\n\n  /**\n   * @type {number}\n   * @default 'number'\n   */\n  duration: 500,\n\n  /**\n   * @type {number}\n   */\n  delay: 0,\n  _fromStr: function (str) {\n    var arr = str.split(/\\s+/g);\n    this.property = arr[0];\n    this.duration = +arr[1];\n    this.delay = +arr[2];\n    this.easing = arr[3];\n  }\n};\n/**\n * @alias module:zrender/graphic/States\n */\n\nvar GraphicStates = function (opts) {\n  opts = opts || {};\n  this._states = {};\n  /**\n   * Target element\n   * @type {zrender/graphic/Displayable|zrender/container/Group}\n   */\n\n  this._el = opts.el;\n  this._subStates = [];\n  this._transitionAnimators = [];\n\n  if (opts.initialState) {\n    this._initialState = opts.initialState;\n  }\n\n  var optsStates = opts.states;\n\n  if (optsStates) {\n    for (var name in optsStates) {\n      if (optsStates.hasOwnProperty(name)) {\n        var state = optsStates[name];\n\n        this._addState(name, state);\n      }\n    }\n  }\n\n  this.setState(this._initialState);\n};\n\nGraphicStates.prototype = {\n  constructor: GraphicStates,\n\n  /**\n   * All other state will be extended from initial state\n   * @type {string}\n   * @private\n   */\n  _initialState: 'normal',\n\n  /**\n   * Current state\n   * @type {string}\n   * @private\n   */\n  _currentState: '',\n  el: function () {\n    return this._el;\n  },\n  _addState: function (name, state) {\n    this._states[name] = state;\n\n    if (state.transition) {\n      state.transition = new TransitionObject(state.transition);\n    } // Extend from initial state\n\n\n    if (name !== this._initialState) {\n      this._extendFromInitial(state);\n    } else {\n      var el = this._el; // setState  style  shape \n      //  style  shape \n\n      zrUtil.merge(state.style, el.style, false, false);\n\n      if (state.shape) {\n        zrUtil.merge(state.shape, el.shape, false, true);\n      } else {\n        state.shape = zrUtil.clone(el.shape, true);\n      }\n\n      for (var name in this._states) {\n        if (this._states.hasOwnProperty(name)) {\n          this._extendFromInitial(this._states[name]);\n        }\n      }\n    }\n  },\n  _extendFromInitial: function (state) {\n    var initialState = this._states[this._initialState];\n\n    if (initialState && state !== initialState) {\n      zrUtil.merge(state, initialState, false, true);\n    }\n  },\n  setState: function (name, silent) {\n    if (name === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[name];\n\n    if (state) {\n      this._stopTransition();\n\n      if (!silent) {\n        var prevState = this._states[this._currentState];\n\n        if (prevState) {\n          prevState.onleave && prevState.onleave.call(this);\n        }\n\n        state.onenter && state.onenter.call(this);\n      }\n\n      this._currentState = name;\n\n      if (this._el) {\n        var el = this._el; // Setting attributes\n\n        if (state.zlevel != null) {\n          el.zlevel = state.zlevel;\n        }\n\n        if (state.z != null) {\n          el.z = state.z;\n        } // SRT\n\n\n        state.position && vec2Copy(el.position, state.position);\n        state.scale && vec2Copy(el.scale, state.scale);\n\n        if (state.rotation != null) {\n          el.rotation = state.rotation;\n        } // Style\n\n\n        if (state.style) {\n          var initialState = this._states[this._initialState];\n          el.style = new Style();\n\n          if (initialState) {\n            el.style.extendFrom(initialState.style, false);\n          }\n\n          if ( // Not initial state\n          name != this._initialState // Not copied from initial state in _extendFromInitial method\n          && initialState.style !== state.style) {\n            el.style.extendFrom(state.style, true);\n          }\n        }\n\n        if (state.shape) {\n          el.shape = zrUtil.clone(state.shape, true);\n        }\n\n        el.dirty();\n      }\n    }\n\n    for (var i = 0; i < this._subStates.length; i++) {\n      this._subStates.setState(name);\n    }\n  },\n  getState: function () {\n    return this._currentState;\n  },\n  transitionState: function (target, done) {\n    if (target === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[target];\n    var styleShapeReg = /$[style|shape]\\./;\n    var self = this; // Animation \n\n    var propPathMap = {};\n\n    if (state) {\n      self._stopTransition();\n\n      var el = self._el;\n\n      if (state.transition && el && el.__zr) {\n        // El can be animated\n        var transitionCfg = state.transition;\n        var property = transitionCfg.property;\n        var animatingCount = 0;\n\n        var animationDone = function () {\n          animatingCount--;\n\n          if (animatingCount === 0) {\n            self.setState(target);\n            done && done();\n          }\n        };\n\n        for (var i = 0; i < property.length; i++) {\n          var propName = property[i]; // Animating all the properties in style or shape\n\n          if (propName === 'style' || propName === 'shape') {\n            if (state[propName]) {\n              for (var key in state[propName]) {\n                if (!state[propName].hasOwnProperty(key)) {\n                  continue;\n                }\n\n                var path = propName + '.' + key;\n\n                if (propPathMap[path]) {\n                  continue;\n                }\n\n                propPathMap[path] = 1;\n                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n              }\n            }\n          } else {\n            if (propPathMap[propName]) {\n              continue;\n            }\n\n            propPathMap[propName] = 1; // Animating particular property in style or style\n\n            if (propName.match(styleShapeReg)) {\n              // remove 'style.', 'shape.' prefix\n              var subProp = propName.slice(0, 5);\n              propName = propName.slice(6);\n              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n            } else {\n              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n            }\n          }\n        } // No transition properties\n\n\n        if (animatingCount === 0) {\n          self.setState(target);\n          done && done();\n        }\n      } else {\n        self.setState(target);\n        done && done();\n      }\n    }\n\n    var subStates = self._subStates;\n\n    for (var i = 0; i < subStates.length; i++) {\n      subStates.transitionState(target);\n    }\n  },\n\n  /**\n   * Do transition animation of particular property\n   * @param {Object} state\n   * @param {string} subPropKey\n   * @param {string} key\n   * @param {Object} transitionCfg\n   * @param {Function} done\n   * @private\n   */\n  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n    var el = this._el;\n    var stateObj = subPropKey ? state[subPropKey] : state;\n    var elObj = subPropKey ? el[subPropKey] : el;\n    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n    var transitionAnimators = this._transitionAnimators;\n\n    if (availableProp) {\n      var obj = {};\n\n      if (stateObj[key] === elObj[key]) {\n        return 0;\n      }\n\n      obj[key] = stateObj[key];\n      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\n        if (idx > 0) {\n          transitionAnimators.splice(idx, 1);\n        }\n\n        done();\n      }).start(transitionCfg.easing);\n      transitionAnimators.push(animator);\n      return 1;\n    }\n\n    return 0;\n  },\n  _stopTransition: function () {\n    var transitionAnimators = this._transitionAnimators;\n\n    for (var i = 0; i < transitionAnimators.length; i++) {\n      transitionAnimators[i].stop();\n    }\n\n    transitionAnimators.length = 0;\n  },\n  transiting: function () {\n    return this._transitionAnimators.length > 0;\n  },\n  addSubStates: function (states) {\n    this._subStates.push(states);\n  },\n  removeSubStates: function (states) {\n    var idx = zrUtil.indexOf(this._subStates, states);\n\n    if (idx >= 0) {\n      this._subStates.splice(states, 1);\n    }\n  }\n};\nvar _default = GraphicStates;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/States.js\n// module id = 76\n// module chunks = 0","/**\r\n * \r\n * @module fish-topo-bo/node/EventDecisionNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    function EventDecisionNode(data, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = data;\r\n\r\n        /**\r\n         * \r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        this._type = opts.type || 'boEvent';\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._clickable = opts.clickable || false;\r\n        this._popupOpts = opts.popupOpts;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //BO\r\n        this._render();\r\n    }\r\n\r\n    var eventProto = EventDecisionNode.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    eventProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._render = function () {\r\n        //\r\n        this._createEventShape();\r\n        //\r\n        this._createEVentName();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._createEventShape = function () {\r\n\r\n        //\r\n        var height = Const.BO_EVENT_HEIGHT,\r\n            x = this._startPos.x + 1,\r\n            y = this._startPos.y,\r\n            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\r\n            shape = new graphic.Polygon({\r\n                name: this._data.id,\r\n                shape: {\r\n                    points: [\r\n                        [x, y],\r\n                        [x + width - 10, y],\r\n                        [x + width, y + height / 2],\r\n                        [x + width - 10, y + height],\r\n                        [x, y + height]]\r\n                },\r\n\r\n                style: {\r\n                    fill: '#FFCCCC',\r\n                    stroke: '#000000',\r\n                    lineWidth: 0.75\r\n                }\r\n\r\n            });\r\n\r\n        if (this._clickable) {\r\n            shape.clickable = this._clickable;\r\n            shape._data = this._data;\r\n            shape._popupOpts = this._popupOpts;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._click = function () {\r\n        var options = Object.assign(\r\n            {\r\n                DATA: this._data\r\n            }, this._popupOpts);\r\n\r\n        nodeOptions.bindBoClickEvent(options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._createEVentName = function () {\r\n        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n            y = this._startPos.y,\r\n\r\n            eventNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_EVENT_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        if (this._clickable) {\r\n            eventNameShape.clickable = this._clickable;\r\n            eventNameShape._data = this._data;\r\n            eventNameShape._popupOpts = this._popupOpts;\r\n            eventNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(eventNameShape);\r\n    };\r\n\r\n    module.exports = EventDecisionNode;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/EventDecisionNode.js\n// module id = 77\n// module chunks = 0","/**\r\n * BO\r\n * @module fish-topo-bo/node/LineNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require('zrender/lib/core/util');\r\n    /**\r\n     * BO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function BoLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\r\n        return _line(startPos, endPos);\r\n    }\r\n\r\n    /**\r\n     * BO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * BOBO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @param {int} attrHeight, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrEventLine(startPos, attrHeight) {\r\n        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {{x: *, y: *}} startPos, \r\n     * @param {{x: *, y: *}} endPos, \r\n     * @param {Object} style, ,\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @private\r\n     */\r\n    function _line(startPos, endPos, style) {\r\n\r\n        var _style = {\r\n            strokeColor: '#000000',\r\n            lineWidth: 0.5,\r\n            percent: 1\r\n        };\r\n\r\n        util.extend(_style, style);\r\n\r\n        var shape = new graphic.Line({\r\n            shape: {\r\n                // Start point\r\n                x1: startPos.x,\r\n                y1: startPos.y,\r\n\r\n                // End point\r\n                x2: endPos.x,\r\n                y2: endPos.y,\r\n\r\n                percent: 1\r\n            },\r\n\r\n            style: _style\r\n        });\r\n\r\n        return shape;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        BoLine: BoLine,\r\n        AttrLine: AttrLine,\r\n        AttrEventLine: AttrEventLine\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/LineNode.js\n// module id = 78\n// module chunks = 0","/**\r\n * BO\r\n * 1.BO\r\n * 2.BO\r\n * 3.BO\r\n * @module fish-topo-bo/node/BoAttrNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String bo,\r\n     *          code: String bo\r\n     *          keyValue: boolean ,\r\n     *          dataType: String ,\r\n     *          boAttrEventArr:[] \r\n     *          }} boAttrData BO,\r\n     * @param {{\r\n     *          startPos: {x: number, y: number},\r\n     *          displayDataType: boolean ,\r\n     *          displayEventDecision: boolean ,\r\n     *          eventClickable: boolean BO,  false,\r\n     *          eventPopupOpts: Object BOurl,width,height,\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BoAttr(boAttrData, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boAttrData;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._keyValue = boAttrData.keyValue || false;\r\n\r\n        /**\r\n         * \r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayDataType = opts.displayDataType || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayEventDecision = opts.displayEventDecision || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._eventClickable = opts.eventClickable || false;\r\n        this._eventPopupOpts = opts.eventPopupOpts;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //BO\r\n        this._render();\r\n    }\r\n\r\n    var boAttrProto = BoAttr.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boAttrProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boAttrProto._render = function () {\r\n        //\r\n        this._createText();\r\n\r\n        //\r\n        this._createDataType();\r\n\r\n        //\r\n        this._createEventDecision();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createText = function () {\r\n\r\n        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n            y = this._startPos.y,\r\n\r\n            attrNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top',\r\n                    //lineWidth: 1,\r\n                    fill: this._keyValue ? 'red' : 'black'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        // =  + padding-top + padding-bottom\r\n        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n        // = BORelation\r\n        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\r\n        //B = \r\n        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\r\n        this._group.add(attrNameShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createDataType = function () {\r\n        if (!this._displayDataType) {\r\n            return;\r\n        }\r\n\r\n        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n            y = this._startPos.y,\r\n            textAlign = 'right';\r\n\r\n        //\r\n        if (this._displayEventDecision) {\r\n            textAlign = 'left';\r\n            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n        }\r\n\r\n        var _dataTypeShape = new graphic.Text({\r\n            style: {\r\n                text: this._data.dataType || '',\r\n                textFont: Const.BO_ATTR_FONT,\r\n                textAlign: textAlign,  //\r\n                textBaseline: 'top',\r\n                lineWidth: 1\r\n            },\r\n\r\n            position: [x, y]\r\n        });\r\n\r\n        this._group.add(_dataTypeShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createEventDecision = function () {\r\n        if (!this._displayEventDecision) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n            _boAttrEventLen = _boAttrEventArr.length,\r\n            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n            _startPos = {\r\n                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n                y: this._startPos.y\r\n            };\r\n\r\n        //\r\n        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n                startPos: _startPos,\r\n                type: 'boAttrEvent',\r\n                clickable: this._eventClickable,\r\n                popupOpts: this._eventPopupOpts,\r\n                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n            }).getShape());\r\n            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n        }\r\n        /*_startPos = {\r\n         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n         y: this._startPos.y};\r\n\r\n         for (var i = 0; i < _boAttrEventLen; i++) {\r\n         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n         }*/\r\n\r\n\r\n    };\r\n\r\n    module.exports = BoAttr;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoAttrNode.js\n// module id = 79\n// module chunks = 0","/**\r\n * \r\n * \r\n * @module fish-topo-bo/node/Relation\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    /**\r\n     *\r\n     * @param sourceShape, \r\n     * @param targetShape, \r\n     * @param {String} sourceText, ,\r\n     * @param {String} targetText, ,\r\n     * @param {String} lineStyle, \r\n     * @param {String} lineHoverStyle, hover\r\n     * @param {String} arrowStyle, \r\n     * @param {String} arrowHoverStyle, hover\r\n     * @constructor\r\n     */\r\n    function Relation(sourceShape, targetShape, sourceText, targetText, lineStyle, lineHoverStyle, arrowStyle, arrowHoverStyle) {\r\n        this._sourceText = sourceText;\r\n        this._targetText = targetText;\r\n\r\n        this._group = new graphic.Group();\r\n\r\n        //\r\n        this._lStartPos = {\r\n            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._lEndPos = {\r\n            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._rStartPos = {\r\n            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._rEndPos = {\r\n            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\r\n        //\r\n        this._lineStyle = lineStyle;\r\n\r\n        //hover\r\n        this._lineHoverStyle = lineHoverStyle;\r\n\r\n        //\r\n        this._arrowStyle = arrowStyle;\r\n\r\n        //hover\r\n        this._arrowHoverStyle = arrowHoverStyle;\r\n\r\n        //\r\n        this._render();\r\n    }\r\n\r\n    var relationProto = Relation.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {*}\r\n     */\r\n    relationProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._render = function () {\r\n        //\r\n        this._createLine();\r\n\r\n        //\r\n        this._createArrow();\r\n\r\n        //\r\n        this._createText();\r\n\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createLine = function () {\r\n        var _linePoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //\r\n            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n            //\r\n            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n        }\r\n        else {\r\n            //\r\n            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n            //\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n            //\r\n            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n        }\r\n\r\n        var _lineShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _linePoints\r\n            },\r\n\r\n            style: {\r\n                //fill: 'blue',\r\n                stroke: this._lineStyle.stroke,\r\n                lineWidth: this._lineStyle.lineWidth,\r\n                lineDash: this._lineStyle.lineDash\r\n            }\r\n\r\n        });\r\n\r\n        this._group.add(_lineShape);\r\n\r\n        //hover\r\n        this._createHoverStyle(_lineShape, this._lineHoverStyle);\r\n\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createArrow = function () {\r\n        var _arrowPoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n        else {\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n\r\n        var _arrowShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _arrowPoints\r\n            },\r\n\r\n            style: {\r\n                fill: this._arrowStyle.fill,\r\n                stroke: this._arrowStyle.stroke\r\n            }\r\n        });\r\n\r\n        this._group.add(_arrowShape);\r\n\r\n        //hover\r\n        this._createHoverStyle(_arrowShape, this._arrowHoverStyle);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createText = function () {\r\n        var _sourceTextPos,\r\n            _targetTextPos,\r\n            _textAlign;\r\n\r\n        if (this._leftDirection) {\r\n            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'right';\r\n        }\r\n        else {\r\n            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'left';\r\n        }\r\n\r\n        //\r\n        if (this._sourceText) {\r\n            var _srcTextShape = new graphic.Text({\r\n                position: _sourceTextPos,\r\n\r\n                style: {\r\n                    text: this._sourceText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_srcTextShape);\r\n        }\r\n\r\n        //\r\n        if (this._targetText) {\r\n            var _targetTextShape = new graphic.Text({\r\n                position: _targetTextPos,\r\n\r\n                style: {\r\n                    text: this._targetText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_targetTextShape);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * hover\r\n     * @private\r\n     */\r\n    relationProto._createHoverStyle = function (el, style) {\r\n        if (style) {\r\n            graphic.setElementHoverStl(el, style);\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                graphic.doEnterHover(el);\r\n                this._group.eachChild(function(line) {\r\n                    graphic.doEnterHover(line);\r\n                });\r\n            }, this))\r\n            .on('mouseout', zrUtil.bind(function() {\r\n                graphic.doLeaveHover(el);\r\n                this._group.eachChild(function(line) {\r\n                    graphic.doLeaveHover(line);\r\n                });\r\n            }, this));\r\n        }\r\n    };\r\n\r\n    module.exports = Relation;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/Relation.js\n// module id = 80\n// module chunks = 0","\r\n    if (typeof Object.assign != 'function') {\r\n        // Must be writable: true, enumerable: false, configurable: true\r\n        Object.defineProperty(Object, \"assign\", {\r\n            value: function assign(target, varArgs) { // .length of function is 2\r\n                'use strict';\r\n                if (target == null) { // TypeError if undefined or null\r\n                    throw new TypeError('Cannot convert undefined or null to object');\r\n                }\r\n\r\n                var to = Object(target);\r\n\r\n                for (var index = 1; index < arguments.length; index++) {\r\n                    var nextSource = arguments[index];\r\n\r\n                    if (nextSource != null) { // Skip over if undefined or null\r\n                    for (var nextKey in nextSource) {\r\n                        // Avoid bugs when hasOwnProperty is shadowed\r\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n                        to[nextKey] = nextSource[nextKey];\r\n                        }\r\n                    }\r\n                    }\r\n                }\r\n                return to;\r\n            },\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/objectAssignPolyfill.js\n// module id = 81\n// module chunks = 0","require(\"./graphic\");\n\nvar _zrender = require(\"../zrender\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = require(\"./Painter\");\n\nregisterPainter('vml', Painter);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/vml.js\n// module id = 82\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z  [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = function (value, maxValue) {\n    if (typeof value === 'string') {\n      if (value.lastIndexOf('%') >= 0) {\n        return parseFloat(value) / 100 * maxValue;\n      }\n\n      return parseFloat(value);\n    }\n\n    return value;\n  };\n  /***************************************************\n   * PATH\n   **************************************************/\n\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash != null) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type == 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); //  round \n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image  img IE8 \n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME  group  left, top  0 \n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform  IE11 \n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode != cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition;\n      var distance = style.textDistance; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      //  appendChild \n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/graphic.js\n// module id = 83\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\n    doCreateNode = function (tagName) {\n      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function (tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nexports.doc = doc;\nexports.createNode = createNode;\nexports.initVML = initVML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/core.js\n// module id = 84\n// module chunks = 0","var zrLog = require(\"../core/log\");\n\nvar vmlCore = require(\"./core\");\n\nvar _util = require(\"../core/util\");\n\nvar each = _util.each;\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n/**\n * @alias module:zrender/vml/Painter\n */\n\n\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n  getType: function () {\n    return 'vml';\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._vmlViewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * \n   */\n  refresh: function () {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n  _paintList: function (list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME  removeChild \n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n  resize: function (width, height) {\n    var width = width == null ? this._getWidth() : width;\n    var height = height == null ? this._getHeight() : height;\n\n    if (this._width != width || this._height != height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n  getWidth: function () {\n    return this._width;\n  },\n  getHeight: function () {\n    return this._height;\n  },\n  clear: function () {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n  _getWidth: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n  },\n  _getHeight: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\neach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/Painter.js\n// module id = 85\n// module chunks = 0"]}